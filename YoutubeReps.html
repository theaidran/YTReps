<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YoutubeReps App</title>
    <style>
        .view { display: none; }
        .view.active { display: block; }
        #indexView, #repsView {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            padding: 10px;
            box-sizing: border-box;
        }
        /* Style dla tła */
        #indexView {
            /* background-color: white !important; */
        }
        body {
            margin: 0 10px !important;
            padding: 0 !important;
            /* background-color: white; */
        }
        /* Style dla przycisku settings */
        .settings-button {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 0 10px;
            margin-left: 10px;
            position: relative;
            transform: none !important;
            transition: none !important;
        }
        @media (max-width: 520px) and (orientation: portrait)     {
            .main-container {
                flex-direction: column; 
            }
        }
        .settings-button:hover {
            color: #777;
            transform: none !important;
        }
        /* Dodatkowe style dla modali */
        .modal {
            position: fixed !important;
            z-index: 1000 !important;
        }
        .modal-backdrop {
            position: fixed !important;
            z-index: 999 !important;
        }
    </style>
<style>
                                /* Style CSS */
        body {
            font-family: 'Roboto', sans-serif;
        }

        .main-title {
            font-size: 28px;
            font-weight: 700;
            color: #333;
            margin-bottom: 20px;
        }

        /* Zaktualizuj .header-container */
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .watched-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.5);
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            z-index: 1000;
        }

        .player-container {
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 56.25%; /* Aspect ratio 16:9 */
            transition: all 0.5s ease;
            border-radius: 5px; /* Dodajemy zaokrąglenie rogów */
            overflow: hidden; /* Ważne, aby zawartość nie wystawała poza zaokrąglone rogi */
        }

        #player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 12px; /* Dodajemy zaokrąglenie rogów również dla iframe */
        }

        /* Dodajemy cień dla lepszego efektu wizualnego 
        .player-container {
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        */
        .player-resizer {
            display: none; /* Ukrywa przycisk resize */
            position: absolute;
            right: 0;
            bottom: 0;
            width: 20px;
            height: 20px;
            background-color: rgba(0, 123, 255, 0.3);
            cursor: se-resize;
            border-top-left-radius: 5px;
        }

        /* Ukrywamy również pseudoelementy */
        .player-resizer::before,
        .player-resizer::after {
            display: none;
        }

        .autoplay-button {
            margin-top: 20px;
            padding: 10px;
            background-color: #007BFF;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }

        .autoplay-button.active {
            background-color: #28A745;
        }

        ul {
            list-style-type: none;
            padding: 0;
        }

        ul li {
            padding: 5px 0;
            display: flex;
            align-items: center;
        }

        ul li a {
            color: #007BFF;
            text-decoration: none;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: inline-block;
            max-width: 100%;
        }

        ul li a:hover {
            text-decoration: underline;
        }

        .note-icon {
            margin-left: 10px;
            cursor: pointer;
        }

        #note-form {
            margin-top: 20px;
            max-width: 50%; /* Ograniczamy szerokość do 50% strony */
            box-sizing: border-box; /* Uwzględniamy padding w szerokości */
        }

        .clear-button {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        .clear-button:hover {
            background-color: #c82333;
        }

        .custom-playlist-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            height: auto;
            margin-top: 0;
            margin-left: 20px; /* Zmieniamy z 25px na 20px */
        }

        .custom-playlist-container input {
            width: 200px;
            height: 36px;
            padding: 0 10px;
            font-size: 16px;
            margin-right: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
        }

        .custom-playlist-container button {
            height: 36px;
            padding: 0 20px;
            background-color: #28A745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            line-height: 36px;
        }

        .playlist-button-container {
            display: flex;
            align-items: center;
            margin-right: 5px; /* Zmniejszamy z 10px na 5px */
            margin-bottom: 5px; /* Zmniejszamy z 10px na 5px */
        }

        .remove-playlist-button {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 5px;
        }

        .remove-playlist-button:hover {
            background-color: #c82333;
        }

        .playlist-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
            margin-bottom: 10px;
            width: 50%; /* Ustawiamy szerokość na 50% strony */
        }

        .playlist-row {
            display: flex;
            flex-wrap: wrap;
            width: 100%; /* Ustawiamy szerokość na 100% kontenera */
            margin-bottom: 5px;
        }

        .playlist-button-container {
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .playlist-button {
            padding: 10px 20px; /* Przywracamy oryginalny padding */
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 5px; /* Przywracamy oryginalny border-radius */
            cursor: pointer;
            font-size: 16px; /* Przywracamy oryginalny rozmiar czcionki */
            transition: background-color 0.3s;
        }

        .playlist-row {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 5px;
            align-items: center;
        }

        .custom-playlist-row {
            width: 100%;
            margin-top: 10px;
        }

        .playlist-button:hover {
            background-color: #0056b3;
        }

        .playlist-button.active {
            background-color: #28A745;
        }

        .trim-button {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #17a2b8;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        .trim-button:hover {
            background-color: #138496;
        }

        .playlist-row {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 3px; /* Zmniejszamy z 5px na 3px */
            align-items: center;
        }

        .custom-playlist-row {
            justify-content: flex-start;
            width: 100%;
            margin-top: 0; /* Usuwamy górny margines */
        }

        .last-button-row {
            margin-bottom: 3px; /* Zmniejszamy z 5px na 3px */
        }

        .toggle-input-button {
            padding: 10px 20px; /* Dostosowujemy padding do innych przycisków */
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px; /* Zmieniamy rozmiar czcionki, aby pasowa do innych przycisków */
            margin-left: 10px;
            transition: background-color 0.3s;
            line-height: 1; /* Dodajemy to, aby tekst był wycentrowany w pionie */
            height: 38px; /* Ustawiamy stałą wysokość, która powinna odpowiadać wysokości innych przycisków */
            box-sizing: border-box; /* Dodajemy to, aby padding nie zwiększał cakowitej wysokości */
        }

        .toggle-input-button:hover {
            background-color: #0056b3;
        }

        #note-form {
            margin-top: 20px;
        }

        .word-translation-pair {
            display: flex;
            margin-bottom: 5px;
        }

        .word-translation-pair textarea {
            width: 100%;
            margin-bottom: 5px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            resize: none;
            overflow-y: hidden;
            box-sizing: border-box;
            min-height: 30px;
            transition: height 0.1s ease;
        }

        .note-form {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .word-list-button {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #17a2b8;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        .word-list-button:hover {
            background-color: #138496;
        }

        #word-list-container {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 600px;
            height: 80vh;
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            resize: both;
            overflow: auto; /* Zmieniamy z hidden na auto */
            min-width: 400px;
            min-height: 200px;
            border-radius: 8px;
        }

        #word-list-header {
            position: sticky;
            top: 0;
            z-index: 2;
            background-color: #007BFF;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 11px 15px; /* Zwiększamy padding z 10px na 11px */
            color: white;
            border-bottom: 1px solid #0056b3;
            user-select: none;
        }

        #word-list-header h2 {
            margin: 0;
            font-size: 19px; /* Zwiększamy rozmiar czcionki z 18px na 19px */
            font-weight: 525; /* Zwiększamy font-weight z 500 na 525 */
        }

        #word-list-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0;
        }

        #word-list-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
        }

        #word-list-table thead {
            position: sticky;
            top: 0;
            background-color: #f2f2f2;
            z-index: 1;
        }

        #word-list-table th {
            background-color: #f2f2f2;
            font-weight: bold;
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        #word-list-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        /* Reszta stylów pozostaje bez zmian */

        #word-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background-color: #007BFF;
            color: white;
            font-weight: bold;
            border-bottom: 1px solid #0056b3;
            cursor: move;
            user-select: none;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
        }

        #close-word-list {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 5px 11px; /* Zwiększamy padding */
            border-radius: 3px;
            cursor: pointer;
            font-size: 15px; /* Zwiększamy rozmiar czcionki */
            transition: background-color 0.3s;
        }

        #close-word-list:hover {
            background-color: #c82333;
        }

        #word-list-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
        }

        #word-list-table th, #word-list-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        #word-list-table th {
            background-color: #f2f2f2;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        #word-list-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        #word-list-table tr:hover {
            background-color: transparent; /* Zmieniamy z #f0f0f0 na transparent */
        }

        /* Styl dla kolumny z numeracją */
        #word-list-table td:first-child,
        #word-list-table th:first-child {
            width: 40px;
            text-align: center;
            background-color: #e9ecef;
            font-weight: bold;
        }

        .main-container {
            display: flex;
            width: 100%;
            min-height: 105vh; /* Zmniejszamy ze 120vh na 105vh */
            padding-bottom: 5%; /* Zmniejszamy z 20% na 5% */
        }

        .left-column {
            width: 44%;
            padding-right: 15px;
            min-height: 100vh; /* Zmniejszamy ze 120vh na 105vh */
        }

        .right-column {
            width: calc(56% - 0px);
            display: flex;
            flex-direction: column;
            position: relative;
            padding-left: 20px;
            padding-right: 10px;
            min-height: 85vh;
            max-height: 131vh;
            overflow-x: visible;
            overflow-y: visible;
        }

        .right-column h3 {
            margin-bottom: 10px;
            color: #007BFF;
        }

        #dictionary-select {
            margin-bottom: 10px;
            padding: 8px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: border-color 0.3s, box-shadow 0.3s;
            
        }

        #dictionary-select:hover, #dictionary-select:focus {
            border-color: #007BFF;
            box-shadow: 0 1px 3px rgba(0, 123, 255, 0.3);
            outline: none;
        }

        #dictionary-frame {
            width: 100%;
            height: 85vh; /* Zmieniamy z 75vh na 85vh */
            border: none;
        }

        /* Dostosuj szerokość player-container */
        .player-container {
            width: 100%;
        }

        /* Dostosuj szerokość playera YouTube */
        #player {
            width: 100%;
            height: 360px;
        }

        .note-form button {
            margin-top: 5px;
            padding: 5px 10px;
            background-color: #007BFF;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 3px;
            font-size: 14px;
        }

        .note-form button:hover {
            background-color: #0056b3;
        }

        .iframe-container {
            position: relative;
            width: 100%;
            height: 85vh;
            margin-top: 1px;
            border: 1px solid #ddd;
            border-top: 1px solid #ccc;
            border-radius: 8px;
            overflow: visible;
            background-color: #f8f9fa;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            resize: none;
        }

        .iframe-container iframe {
            border-radius: 8px;
            background-color: #f8f9fa;
        }

        #dictionary-frame {
            width: 100%;
            height: 85vh;
            border: none;
        }

        #iframe-resizer {
            display: none;
        }

        #iframe-resizer {
            position: absolute;
            right: 0;
            bottom: 0;
            width: 20px; /* Zmniejszamy z powrotem do 20px */
            height: 20px; /* Zmniejszamy z powrotem do 20px */
            background-color: #007BFF;
            cursor: se-resize;
            border-top-left-radius: 8px;
        }

        #iframe-resizer::before,
        #iframe-resizer::after {
            content: '';
            position: absolute;
            right: 3px; /* Zmniejszamy z powrotem do 3px */
            bottom: 3px; /* Zmniejszamy z powrotem do 3px */
            width: 50%;
            height: 2px; /* Zmniejszamy z powrotem do 2px */
            background-color: white;
        }

        #iframe-resizer::after {
            transform: rotate(90deg);
            transform-origin: bottom right;
        }

        .right-column h3 {
            margin-bottom: 10px;
            color: #007BFF;
            font-size: 18px;
        }

        #dictionary-select {
            margin-bottom: 10px;
            padding: 8px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
        }

        #iframe-resizer:hover {
            background-color: #0056b3;
        }

        .right-column {
            display: flex;
            flex-direction: column;
            transition: margin-top 0.3s ease;
            
        }

        #dictionary-select {
            transition: margin-bottom 0.3s ease;
        }

        .iframe-container {
            flex-grow: 1;
            transition: height 0.3s ease;
            height: 85vh; /* Zmniejszamy z 85vh na 75vh */
        }

        .right-column {
            display: flex;
            flex-direction: column;
            position: relative;
            
        }

        .dictionary-select-container {
            position: sticky;

            z-index: 100;
            padding: 0;
        }

        .dictionary-select-container.sticky {
            position: sticky;
            top: 0px;
        }

        .note-form[style*="display: block"] ~ .right-column .dictionary-select-container {
            position: sticky;
            
            
        }

        .iframe-container {
            position: relative;
            width: 100%;
            height: 85vh; /* Zmniejszamy z 85vh na 75vh */
            margin-top: 1px;
            border: 1px solid #ddd;
            border-top: 1px solid #ccc;
            border-radius: 8px;
            overflow: visible;
            background-color: #f8f9fa; /* Dodajemy jasno-szare tło */
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            resize: none;
        }

        #separator {
            height: 130px;
            width: 100%;
           /*        border-bottom: 1px solid #ffffff; /* Zmieniamy kolor linii na biały */
            /* lub */
            /* box-shadow: 0 2px 4px rgba(255,255,255,0.05); */ /* Jeśli używasz cienia, zmieniamy go na biały */
        }

        #spacer {
            height: 10px; /* Możesz dostosować tę wartość */
            width: 100%;
            visibility: hidden; /* Element jest niewidoczny, ale zajmuje miejsce */
        }

        .note-form {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 5px;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden; /* Dodajemy to, aby zapobiec wystawaniu zawartości */
        }

        .word-translation-pair {
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 10px;
        }

        .word-translation-pair:last-child {
            border-bottom: none;
        }

        .word-translation-pair textarea {
            width: 100%;
            margin-bottom: 5px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            resize: none;
            min-height: 30px;
            overflow-y: hidden;
            box-sizing: border-box;
            transition: height 0.1s ease;
        }

        .note-form button {
            margin-top: 10px;
            padding: 5px 10px;
            background-color: #007BFF;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 3px;
            font-size: 14px;
        }

        .note-form button:hover {
            background-color: #0056b3;
        }

        body {
            min-height: 100vh;
        }

        .main-container {
            min-height: 100vh;
        }
     
        .count-normal {
            font-weight: normal;
        }

        #export-word-list {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 5px 11px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 15px;
            transition: background-color 0.3s;
            margin-right: 10px;
        }

        #export-word-list:hover {
            background-color: #218838;
        }

        #word-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 11px 15px;
        }

        #word-list-header > div {
            display: flex;
            align-items: center;
        }

        .button {
            background-color: #007BFF;
            color: white;
            border: none;
            padding: 5px 11px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 15px;
            transition: background-color 0.3s;
            text-decoration: none;
            display: inline-block;
        }

        .button:hover {
            background-color: #0056b3;
        }

        /* Dodaj na początku pliku */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
        }

        header h1 {
            margin: 0;
            font-size: 24px;
            color: #333;
        }

        .quiz-button {
            background-color: #17a2b8; /* Taki sam kolor jak przycisk "Lista słów" */
            color: white;
            border: none;
            padding: 5px 22px;
            border-radius: 5px; /* Zmienione na 5px, aby pasowało do przycisku "Lista słów" */
            cursor: pointer;
            font-size: 16px; /* Zmienione na 16px, aby pasowało do przycisku "Lista słów" */
            text-decoration: none;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.3s;
            margin-left: 10px;
            height: 38px; /* Dostosowane do wysokości przycisku "Lista słów" */
            width: 100px;
        }

        .quiz-button:hover {
            background-color: #138496; /* Ciemniejszy odcień przy najechaniu */
        }

        /* Reszta stylów pozostaje bez zmian */

        /* Dodaj te style na początku pliku lub w odpowiednim miejscu */
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .quiz-button {
            background-color: #17a2b8; /* Błękitny kolor */
            color: white;
            border: none;
            padding: 5px 22px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 15px;
            text-decoration: none;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.3s;
            margin-left: 10px;
            height: 28px;
            width: 100px;
        }

        .quiz-button:hover {
            background-color: #138496; /* Ciemniejszy odcień błękitnego przy najechaniu */
        }

        /* Zaktualizuj .header-container */
        .header-container {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin-bottom: 20px;
        }

        .header-container h1 {
            margin-right: auto;
        }

        /* Usuń niepotrzebne style */
        /* Usuń lub zakomentuj poprzednie definicje .quiz-button */

        /* Style dla przycisków w formularzu Lista słów */
        #word-list-container button {
            background-color: #007BFF;
            color: white;
            border: none;
            padding: 5px 11px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 15px;
            transition: background-color 0.3s;
            margin-right: 10px;
        }

        #word-list-container button:hover {
            background-color: #0056b3;
        }

        #clear-watched-videos {
            background-color: #dc3545 !important;
        }

        #clear-watched-videos:hover {
            background-color: #c82333 !important;
        }

        /* Pozostałe style... */

        .dictionary-select-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .dictionary-select-row select {
            margin-right: 10px;
        }

        .dictionary-select-row label {
            display: flex;
            align-items: center;
            cursor: pointer;
            position: relative; /* Dodajemy to, aby tooltip był pozycjonowany względem tego elementu */
        }

        .dictionary-select-row input[type="checkbox"] {
            margin: 0;
            padding-left: 15px; /* Dodajemy odstęp z lewej strony */
            cursor: pointer;
            transform: translateY(-4px);
        }

        /* Zmodyfikowany styl dla tooltipa */
        .dictionary-select-row label[title]:hover:before {
            content: attr(title);
            position: absolute;
            background: #333;
            color: #fff;
            padding: 5px;
            border-radius: 3px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            right: 100%; /* Ustawiamy tooltip na lewo od checkboxa */
            top: 50%; /* Centrujemy tooltip w pionie */
            transform: translateY(-50%); /* Dokładne wycentrowanie w pionie */
            margin-right: 10px; /* Dodajemy odstęp między checkboxem a toolipem */
        }

        /* ... (pozostałe style bez zmian) ... */

        dialog {
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        dialog h3 {
            margin-top: 0;
        }

        dialog select {
            width: 100%;
            margin-bottom: 10px;
            padding: 5px;
        }

        dialog button {
            margin-right: 10px;
            padding: 5px 10px;
            cursor: pointer;
        }
/* 
        .main-container {
            display: flex;
            position: relative;
        }

       .left-column {
            width: 65%;
            transition: width 0.3s ease;
        }

        .right-column {
            width: 35%;
            transition: width 0.3s ease;
        }
*/
        .column-resizer {
            position: absolute;
            top: 50%;
            right: 55%;
            transform: translateY(-50%);
            z-index: 1000;
            transition: right 0.3s ease;
        }

        #expand-collapse-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px;
            cursor: pointer;
            font-size: 20px;
            transition: transform 0.3s ease;
        }

        .expanded .left-column {
            width: 100%;
        }

        .expanded .right-column {
            width: 0;
            
        }

        .expanded .column-resizer {
            right: 0;
        }

        .expanded #expand-collapse-btn {
            transform: rotate(180deg);
        }

        
@media (max-width: 920px) and (orientation: landscape) {

    .right-column { /* kolumna słownika */
        width: 100%;
        padding-right: 5px;   /* odstep od prawej */
        min-height: 250vh;
       /* max-height: auto;*/
    }

    .left-column {
        width: 100%;
    }

    #dictionary-select {
        margin-bottom: 10px;
        padding: 8px;
        font-size: 16px;
        border: 1px solid #ddd;
        border-radius: 4px;
        width: 100%;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition: border-color 0.3s, box-shadow 0.3s;
        
    }
}

@media (max-width: 520px) and (orientation: portrait)     {
    .main-container {
        flex-direction: column;
    }

    .right-column { /* kolumna słownika */
        width: 105%;
        padding-right: 85px;   /* odstep od prawej */
        min-height: 110vh;
        max-height: none;
    }

    .left-column { /* kolumna palyera */
        width: 115%;
        padding-right: 40px; /* nie dziala */
        padding-left: 20px; /* Dodajemy 40px wolnej przestrzeni z lewej strony */
        margin-right: 10px;
    }

    .iframe-container {
        height: 110vh;
    }

    .column-resizer {
        display: none; /* Ukrywamy resizer na małych ekranach */
    }

    #expand-collapse-btn {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
        padding: 15px;
        font-size: 24px;
        border-radius: 50%;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .expanded .left-column {
        display: none;
        
    }

    .expanded .right-column {
        display: block;
        width: 100%;
    }

    .mobile-view .left-column {
        
        display: block;
    }

    .mobile-view .right-column {
        display: block;
    }
}

.hidden-button {
    display: none;
}

.tabs-container {
    display: flex;
    flex-wrap: wrap; /* Dodajemy zawijanie, gdyby było zbyt wiele zakładek */
    background-color: #f1f1f1;
    border-bottom: 1px solid #ddd;
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
    overflow: hidden;
}

.tab {
    display: inline-flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    background-color: #f1f1f1;
    border: none;
    outline: none;
    transition: 0.3s;
    margin-right: 2px;
    position: relative; /* Dodajemy to */
}

.tab span {
    flex-grow: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 150px;
    pointer-events: none; /* Dodajemy to */
}

.close-tab {
    background: none;
    border: none;
    color: #888;
    font-size: 18px;
    cursor: pointer;
    padding: 0 5px;
    margin-left: 5px;
    position: relative; /* Dodajemy to */
    z-index: 1; /* Dodajemy to */
}

.close-tab:hover {
    color: #333;
}

.tab:hover {
    background-color: #ddd;
}

.tab.active {
    background-color: #fff;
    border-bottom: 2px solid #007BFF;
}

#add-tab {
    padding: 5px 12px;
    background-color: #f1f1f1;
    color: #555555; /* Zmieniamy kolor na ciemniejszy odcień szarego */
    border: none;
    cursor: pointer;
    font-weight: bold;
    font-size: 24px;
    line-height: 1;
    transition: background-color 0.3s, color 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 40px;
    min-height: 40px;
}

#add-tab:hover {
    background-color: #ddd;
    color: #333333; /* Pozostawiamy kolor przy najechaniu bez zmian */
}

#iframe-container {
    display: flex;
    height: calc(100% - 41px); /* Wysokość kontenera minus wysokość zakładek */
}

#iframe-container iframe {
    flex: 1;
    border: none;
    border-radius: 8px;
    background-color: #f8f9fa;
}

/* Istniejący styl */
.dictionary-select-row label {
    display: flex;
    align-items: center;
    cursor: pointer;
    position: relative;
}

/* Zmodyfikowane style dla checkboxa */
.dictionary-select-row input[type="checkbox"] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 13px;
    height: 13px;
    border: 1px solid #007BFF;
    border-radius: 2px;
    outline: none;
    transition: all 0.3s;
    position: relative;
    cursor: pointer;
    margin-left: 0; /* Usuwamy lewy margines */
    padding: 0;
}

.dictionary-select-row input[type="checkbox"]:checked {
    background-color: #007BFF;
}

.dictionary-select-row input[type="checkbox"]:checked::before {
    content: '\2714';
    font-size: 12px; /* Zwiększamy rozmiar znacznika */
    color: white;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

/* Zachowaj istniejący styl dla tooltipa */
.dictionary-select-row label[title]:hover:before {
    content: attr(title);
    position: absolute;
    background: #333;
    color: #fff;
    padding: 5px;
    border-radius: 3px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 1000;
    right: 100%;
    top: 50%;
    transform: translateY(-50%);
    margin-right: 10px;
}

#leitnerBoxesChart {
    margin-top: 2rem;
    max-width: 100%;
    height: auto;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.column-divider {
    width: 2%;
    background-color: transparent;
    cursor: col-resize;
    position: relative;
    transition: background-color 0.3s;
}

.column-divider::after {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 2px;
    height: 100%;
    background-color: transparent; /* Zmieniono z #ddd na transparent */
    transition: background-color 0.3s;
}

.column-divider:hover::after,
.column-divider:active::after {
    background-color: #007bff; /* Pojawia się tylko przy najechaniu/aktywności */
}

/* Usuwamy niepotrzebne style */
.column-divider:hover,
.column-divider:active {
    background-color: transparent; /* Zmieniono z #007bff na transparent */
}

.settings-button {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    padding: 0 10px;
    margin-left: 10px;
    position: relative; /* Dodane dla pozycjonowania tooltipa */
}

/* Dodajemy style dla tooltipa */
.settings-button::after {
    content: "Settings";
    position: absolute;
    bottom: 25px;
    left: 70%;
    transform: translateX(-50%);
    background-color: #333;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}

.settings-button:hover::after {
    opacity: 1;
    visibility: visible;
}

/* Usuwamy hover effect z obracaniem 
.settings-button:hover {
     color: #777; Opcjonalnie: delikatna zmiana koloru przy najechaniu 
}*/

.settings-form {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    z-index: 1000;
    width: 90%;
    max-width: 300px; /* Zmniejszamy szerokość */
}

.settings-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.settings-header h3 {
    margin: 0;
}

.close-button {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    color: #666;
}

.close-button:hover {
    color: #333;
}

.checkbox-label {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
}

.checkbox-label input[type="checkbox"] {
    width: 16px;
    height: 16px;
}

.settings-overlay {
    position: fixed;
    visibility: hidden;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 999;
}

.settings-group {
    margin-bottom: 15px;
}

.settings-group label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
}

.settings-group select {
    width: 100%;
    padding: 8px;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    font-size: 14px;
}

.algorithm-description {
    background-color: #f8f9fa;
    padding: 10px;
    border-radius: 4px;
    margin: 15px 0;
}

.description-text {
    font-size: 14px;
    color: #667;
    margin: 5px 0;
}

.button-group {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 20px;
}

/* Style dla przycisku trybu ciemnego */
#index-dark-mode {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    padding: 5px 10px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: #333;
    transition: background-color 0.3s;
}

#index-dark-mode:hover {
    background-color: rgba(0, 0, 0, 0.1); /* Takie samo podświetlenie jak settings */
    border-radius: 4px; /* Zaokrąglone rogi jak w settings */
}

body.index-dark-mode #index-dark-mode:hover {
    background-color: rgba(255, 255, 255, 0.1); /* Jaśniejsze podświetlenie w trybie ciemnym */
}

.dark-mode-icon {
    font-size: 22px;
    line-height: 1;
}


/* Style dla trybu ciemnego w index.html */
body.index-dark-mode {
    background-color: #1a1a1a;
    color: #e0e0e0;
}

/* Aktualizujemy wszystkie selektory */
body.index-dark-mode .main-title {
    color: #e0e0e0;
}

body.index-dark-mode .player-container {
    background-color: #1a1a1a;
}

/* ... i tak dalej dla wszystkich selektorów używających .dark-mode */

/* Style dla trybu ciemnego w index.html */
body.index-dark-mode {
    background-color: #1a1a1a;
    color: #e0e0e0;
}

body.index-dark-mode .main-title {
    color: #e0e0e0;
}

body.index-dark-mode .player-container {
    background-color: #1a1a1a;
}

body.index-dark-mode ul li a {
    color: #66b3ff;
}

body.index-dark-mode .word-list-button,
body.index-dark-mode .settings-button,
body.index-dark-mode #autoplay-btn {
    background-color: #333;
    color: #e0e0e0;
}

body.index-dark-mode #separator {
    border-color: #404040;
    background-color: #1a1a1a;
    border-bottom: 1px solid #1a1a1a; /* Zmieniamy kolor linii na biały */
}

body.index-dark-mode .dictionary-select-container {
    background-color: #1a1a1a;
}

body.index-dark-mode .dictionary-select-container h3 {
    color: #e0e0e0;
}

body.index-dark-mode #dictionary-select {
    background-color: #333;
    color: #e0e0e0;
    border-color: #404040;
}

body.index-dark-mode .tabs-container {
    background-color: #1a1a1a;
}

body.index-dark-mode .tab {
    background-color: #333;
    color: #e0e0e0;
}

body.index-dark-mode .tab.active {
    background-color: #404040;
    border-bottom-color: #007BFF;
}

body.index-dark-mode #add-tab {
    background-color: #333;
    color: #e0e0e0;
}

body.index-dark-mode #word-list-container {
    background-color: #1a1a1a;
    border-color: #404040;
}

body.index-dark-mode #word-list-table th {
    background-color: #333;
    color: #e0e0e0;
    border-color: #404040;
}

body.index-dark-mode #word-list-table td {
    color: #e0e0e0;
    border-color: #404040;
}

body.index-dark-mode #word-list-table tr:nth-child(even) {
    background-color: #262626;
}

body.index-dark-mode #word-list-table td:first-child,
body.index-dark-mode #word-list-table th:first-child {
    background-color: #333;
}

body.index-dark-mode .note-form {
    background-color: #333;
    border-color: #404040;
}

body.index-dark-mode .note-form textarea {
    background-color: #1a1a1a;
    color: #e0e0e0;
    border-color: #404040;
}

body.index-dark-mode .settings-form {
    background-color: #404040;
    color: #e0e0e0;
    border-color: #404040;
}

body.index-dark-mode .iframe-container {
    border: 1px solid #404040;
    background-color: #1a1a1a;
}

body.index-dark-mode .iframe-container iframe {
    background-color: #1a1a1a;
}

body.index-dark-mode .iframe-container .tabs-container {
    border-color: #404040;
    background-color: #1a1a1a;
}

/* Podstawowy styl dla ikony */
#index-dark-mode {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    padding: 5px 10px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: #333;
    transition: background-color 0.3s;
}

/* Hover w trybie jasnym */
#index-dark-mode:hover {
    background-color: rgba(0, 0, 0, 0.1);
    border-radius: 4px;
}

/* Kolor ikony w trybie ciemnym */
body.index-dark-mode #index-dark-mode {
    color: #e0e0e0; /* Jasny kolor dla ikony w trybie ciemnym */
}

/* Hover w trybie ciemnym */
body.index-dark-mode #index-dark-mode:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

/* Dodaj te style na końcu pliku CSS */
.column-divider-tooltip {
    position: absolute;
    top: 20%;
    left: 20px; /* Zmieniamy z 50% na stałą wartość */
    transform: translate(0, -50%); /* Zmieniamy transform, usuwamy przesunięcie w poziomie */
    background-color: #333;
    color: white;
    padding: 12px 20px;
    border-radius: 6px;
    font-size: 14px;
    white-space: nowrap;
    z-index: 1000;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    animation: fadeIn 0.3s ease-in-out;
}

.column-divider-tooltip::before {
    content: '';
    position: absolute;
    top:50%;
    right: 100%;
    transform: translateY(-50%);
    border: 8px solid transparent;
    border-right-color: #333;
    margin-right: 0; /* Usuwamy margines, jeśli był */
}

.tooltip-close {
    background: none;
    border: none;
    color: white;
    font-size: 18px;
    padding: 0 0 0 10px;
    cursor: pointer;
    vertical-align: middle;
}

.tooltip-close:hover {
    color: #ff4444;
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translate(10px, -50%); /* Dostosowujemy animację */
    }
    to {
        opacity: 1;
        transform: translate(0, -50%); /* Dostosowujemy animację */
    }
}

/* Dodaj style dla trybu ciemnego */
body.index-dark-mode .column-divider-tooltip {
    background-color: #404040;
    color: #e0e0e0;
}

body.index-dark-mode .column-divider-tooltip::before {
    border-right-color: #404040;
}

/* Dodaj nową klasę dla podświetlonego dividera */
.column-divider.highlighted::after {
    background-color: #007bff !important; /* Używamy !important aby nadpisać hover */
    opacity: 0.5;
    box-shadow: 0 0 8px rgba(0, 123, 255, 0.5);
}

/* Dla trybu ciemnego */
body.index-dark-mode .column-divider.highlighted::after {
    background-color: #4da3ff !important; /* Jaśniejszy niebieski w trybie ciemnym */
    opacity: 0.6;
}

/* Dodaj style dla suwaka ratio */
.ratio-control {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 5px;
}

.ratio-slider {
    flex-grow: 1;
    height: 4px;
    background: #ddd;
    border-radius: 2px;
    outline: none;
}

.ratio-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    background: #007bff;
    border-radius: 50%;
    cursor: pointer;
    transition: background 0.3s;
}

.ratio-slider::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: #007bff;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    transition: background 0.3s;
}

.ratio-slider:hover::-webkit-slider-thumb {
    background: #0056b3;
}

.ratio-slider:hover::-moz-range-thumb {
    background: #0056b3;
}

/* Style dla trybu ciemnego */
body.index-dark-mode .ratio-slider {
    background: #404040;
}

body.index-dark-mode .ratio-slider::-webkit-slider-thumb {
    background: #4da3ff;
}

body.index-dark-mode .ratio-slider::-moz-range-thumb {
    background: #4da3ff;
}

body.index-dark-mode .ratio-slider:hover::-webkit-slider-thumb {
    background: #3385ff;
}

body.index-dark-mode .ratio-slider:hover::-moz-range-thumb {
    background: #3385ff;
}

/* Style dla etykiet w ustawieniach w trybie ciemnym */
body.dark-mode .settings-group label {
    color: #bbb;  /* Szary kolor dla etykiet */
}

/* Style dla nagłówków sekcji w trybie ciemnym */
body.dark-mode .settings-section h3 {
    color: #bbb;  /* Szary kolor dla nagłówków sekcji */
}

/* Style dla tekstu w trybie ciemnym */
body.dark-mode .settings-group span,
body.dark-mode .settings-description,
body.dark-mode #ratioValue {
    color: #bbb;  /* Szary kolor dla tekstu */
}

/* Style dla checkboxów i ich etykiet w trybie ciemnym */
body.dark-mode .checkbox-label {
    color: #bbb;  /* Szary kolor dla tekstu obok checkboxów */
}

/* Style dla tooltipów w trybie ciemnym */
body.dark-mode .settings-group .checkbox-label[data-tooltip]::before {
    color: #e0e0e0;  /* Jaśniejszy kolor dla tekstu w tooltipie */
}

/* Style dla różnych orientacji na urządzeniach mobilnych */
@media (max-width: 520px) {


    /* Style dla trybu ciemnego */
    body.index-dark-mode.portrait-mode {
        background-color: #1a1a1a;
    }

    body.index-dark-mode.landscape-mode {
        background-color: #222222;
    }
}

/* Style dla przycisku Buy Me a Coffee */
.bmc-button {
    margin: 0 !important;
    height: 24px !important;
    line-height: 24px !important;
    min-width: auto !important;
    display: inline-flex !important;
    align-items: center !important;
    transform: scale(0.9) !important;
}

/* Dostosowanie dla małych ekranów */
@media (max-width: 768px) {
    .bmc-button {
        margin-left: 0 !important;
        margin-top: 5px !important;
        width: 100% !important;
        height: 36px !important;
        line-height: 36px !important;
    }
}

/* Style dla kontenera przycisku Buy Me a Coffee */
.bmc-button-container {
    display :none;  /* ukryj */
    position: absolute;
    top: -10px;
    right: -10px;
    transform: scale(0.6);
    z-index: 100;
}

/* Dodajemy pozycjonowanie względne dla kontenera nadrzędnego */
.right-column {
    position: relative;
}


                        body {
    font-family: 'Roboto', Arial, sans-serif;
    line-height: 1.6;
    color: #333;
    background-color: #f4f4f4;
    margin: 0;
    padding: 0;
}

header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    background-color: #f8f9fa;
    border-bottom: 1px solid #e0e0e0;
}

.header-content {
    display: flex;
    align-items: center;
}

.language-select {
    margin-left: auto;
}

.language-select select {
    padding: 5px;
    font-size: 14px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

/* Style dla głównego tytułu */
.main-title {
    margin: 0;
    color: #333;
    font-size: 28px;
    font-weight: 700;
}

/* Style dla głównego tytułu w trybie ciemnym */
body.dark-mode .main-title {
    color: #e0e0e0;
}

.back-button, .center-button {
    display: inline-block;
    padding: 0.5rem 1rem;
    background-color: #005A9E;
    color: #fff;
    text-decoration: none;
    border-radius: 5px;
    transition: background-color 0.3s ease;
    cursor: pointer;
}

.back-button:hover, .center-button:hover {
    background-color: #003F6B;
}

.center-button {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    background-color: #007bff; /* Zmieniamy kolor na niebieski */
    color: #fff;
    height: 28px;
    width: 120px;
    font-size: 16px;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.center-button:hover {
    background-color: #0056b3; /* Ciemniejszy odcień niebieskiego przy najechaniu myszką */
}

main {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
}

nav {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 1rem;
    margin-bottom: 2rem;
}

.nav-button, .submit-button, .info-button, .close-button, .review-button {
    padding: 0.5rem 1rem;
    color: #fff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    text-decoration: none;
    font-size: 16px;
}

.nav-button {
    background-color: #007ACC;
}

.nav-button:hover {
    background-color: #005A9E;
}

.nav-button.active {
    background-color: #28a745; /* Zielony kolor dla aktywnego przycisku */
}

.submit-button {
    background-color: #28a745;
}

.submit-button:hover {
    background-color: #218838;
}

.info-button {
    background-color: #17a2b8;
    margin-left: 1rem;
}

.info-button:hover {
    background-color: #138496;
}

.close-button {
    background-color: #dc3545;
    margin-top: 1rem;
}

.close-button:hover {
    background-color: #c82333;
}

.review-button {
    background-color: #4CAF50;
    white-space: nowrap;
}

.review-button:hover {
    background-color: #45a049;
    box-shadow: 0 12px 16px 0 rgba(0,0,0,0.24), 0 17px 50px 0 rgba(0,0,0,0.19);
}

.container {
    background-color: #fff;
    border-radius: 5px;
    padding: 2rem;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    margin-bottom: 2rem;

}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid #007ACC;
}

.section-header h2 {
    margin: 0;
    padding: 0;
    color: #007ACC;
}

.section-header .info-button {
    margin-left: 1rem;
}

form input, textarea {
    width: 100%;
    padding: 0.5rem;
    margin-bottom: 1rem;
    border: 1px solid #ddd;
    border-radius: 5px;
}

textarea {
    min-height: 18px;
    resize: vertical;
    overflow: hidden;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 1rem;
}

th, td {
    padding: 0.5rem;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

th {
    background-color: #f8f9fa;
    font-weight: bold;
}

.info-box {
    background-color: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 1rem;
    margin-top: 1rem;
}

.hidden {
    display: none;
}

.button-container {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 20px;
    padding: 0 10px;
}

.card-content {
    background-color: #fff; /* Zmieniono na biały */
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 20px;
    margin-bottom: 20px;
}

.button-row {
    display: flex;
    justify-content: space-between;
    margin-top: 10px;
}

.button-row button {
    flex: 1;
    margin: 0 5px;
    padding: 10px;
}



.known-button {
    background-color: #28a745;
    color: white;
}

.unknown-button {
    background-color: #dc3545;
    color: white;
}

.translation {
    margin-top: 10px;
    padding: 10px;
    background-color: #fff;
    border: 1px solid #fff; /* Zmieniono kolor ramki na biały */
    border-radius: 5px;
}

#flashcardTable {
    table-layout: auto;
    width: 100%;
}

#flashcardTable th, #flashcardTable td {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 190px; /* Zmniejszamy maksymalną szerokość komórek do 190px */
}

#flashcardTable th {
    position: sticky;
    top: 0;
    z-index: 10;
}

#flashcardTable tr:last-child td {
    border-bottom: none;
}

#flashcardTable td img {
    max-width: 50px;
    max-height: 50px;
    object-fit: cover;
}

#flashcardTable td audio {
    max-width: 200px;
}

#flashcardTable tr:hover {
    background-color: #f5f5f5;
}

#view {
    overflow-x: auto;
    max-width: 100%;
    /* Usuwamy padding-right: 10px; */
}

.edit-form {
    background-color: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 20px;
    margin-top: 20px;
}

.edit-form h2 {
    margin-top: 0;
    margin-bottom: 20px;
    color: #007bff;
}

.form-group {
    margin-bottom: 15px;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
}

.button-group {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 20px;
}

.card-content pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    background-color: #fff;
    border-radius: 5px;
    padding: 10px;
    margin: 10px 0;
    font-family: inherit;
    font-size: inherit;
}

#learningProgressChart {
    margin-top: 2rem;
    margin-bottom: 3rem;
    max-width: 300px;
    display: block;
    margin-left: 0;
    margin-right: auto;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    width: 100% !important;
    height: auto !important;
}

@media (max-width: 768px) {
    nav {
        flex-direction: column;
    }

    .nav-button {
        width: 100%;
    }
}

/* Style dla przycisków w sekcji Powtórki */
.known-button, .unknown-button, .show-translation {
    padding: 0.5rem 1rem;
    color: #fff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    font-size: 16px;
    margin: 0 5px;
}

.known-button {
    background-color: #28a745; /* Zielony kolor dla przycisku "Znam" */
}

.known-button:hover {
    background-color: #218838;
}

.unknown-button {
    background-color: #dc3545; /* Czerwony kolor dla przycisku "Nie znam" */
}

.unknown-button:hover {
    background-color: #c82333;
}


.show-translation:hover {
    background-color: #5f5f5f;
}

/* Styl dla kontenera przycisków */
.button-row {
    display: flex;
    justify-content: space-between;
    margin-top: 10px;
}

.button-row button {
    flex: 1;
}

/* Style dla tooltipów */
[title] {
    position: relative;
}

[title]:hover::before {
    content: attr(title);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    padding: 5px 10px;
    background-color: #333;
    color: #fff;
    border-radius: 4px;
    font-size: 14px;
    white-space: nowrap;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s;
}

[title]:hover::after {
    content: '';
    position: absolute;
    top: -5px;
    left: 50%;
    transform: translateX(-50%);
    border-width: 5px;
    border-style: solid;
    border-color: #333 transparent transparent transparent;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s;
}

[title]:hover::before,
[title]:hover::after {
    opacity: 1;
}

/* Dodatkowe style dla tooltipów na przyciskach */
button[title]:hover::before {
    bottom: 120%;
}

button[title]:hover::after {
    top: -10px;
}

/* Resetujemy stare style dla dymków */
[title]:after {
    content: none !important;
}

/* Nowe style dla dymków */
[title] {
    position: relative;
}

[title]:hover::before {
    content: attr(title);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    padding: 5px 10px;
    background-color: #333;
    color: #fff;
    border-radius: 4px;
    font-size: 14px;
    white-space: nowrap;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s;
}

[title]:hover::after {
    content: '';
    position: absolute;
    top: -5px;
    left: 50%;
    transform: translateX(-50%);
    border-width: 5px;
    border-style: solid;
    border-color: #333 transparent transparent transparent;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s;
}

[title]:hover::before,
[title]:hover::after {
    opacity: 1;
}

/* Dodatkowe style dla tooltipów na przyciskach */
button[title]:hover::before {
    bottom: 120%;
}

button[title]:hover::after {
    top: -10px;
}

/* Style dla przycisków w formularzu edycji */
.edit-form button,
.button-group button,
.submit-button {
    padding: 0.5rem 1rem;
    color: #fff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    font-size: 16px;
    margin: 0 5px;
    width: auto;
    display: inline-block;
}

/* Styl dla przycisku "Zapisz zmiany" */
.edit-form button[type="submit"],
.button-group button[type="submit"],
.submit-button {
    background-color: #28a745;
}

.edit-form button[type="submit"]:hover,
.button-group button[type="submit"]:hover,
.submit-button:hover {
    background-color: #218838;
}

/* Styl dla przycisku "Anuluj" */
.edit-form button[type="button"],
.button-group button[type="button"],
.cancel-button {
    background-color: #dc3545;
}

.edit-form button[type="button"]:hover,
.button-group button[type="button"]:hover,
.cancel-button:hover {
    background-color: #c82333;
}

/* Kontener dla przycisków w formularzu edycji */
.edit-form .button-group,
.button-group {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 20px;
}

.button-group button {
    flex: 0 0 auto;
}

.nav-button.center-button {
    background-color: #17a2b8; /* Taki sam kolor jak przycisk "Repetitions" */
    color: #fff;
    height: 28px;
    width: 120px;
    font-size: 16px;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.nav-button.center-button:hover {
    background-color: #138496; /* Ciemniejszy odcień przy najechaniu myszką */
}

.info-icon {
    cursor: help;
    position: relative;
    display: inline-block;
    margin-left: 5px;
}

.info-icon:hover::before {
    content: attr(title);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    padding: 5px 10px;
    background-color: #333;
    color: #fff;
    border-radius: 4px;
    font-size: 14px;
    white-space: pre-line;
    z-index: 1000;
    width: max-content;
    max-width: 300px;
}

.info-icon:hover::after {
    content: '';
    position: absolute;
    top: -5px;
    left: 50%;
    transform: translateX(-50%);
    border-width: 5px;
    border-style: solid;
    border-color: #333 transparent transparent transparent;
}

.info-tooltip {
    position: relative;
    cursor: default; /* Zmieniamy 'help' na 'default' */
}

.info-tooltip::after {
    content: attr(data-tooltip);
    position: absolute;
    left: 0;
    top: 100%;
    background-color: #333;
    color: #fff;
    padding: 5px 10px;
    border-radius: 4px;
    white-space: pre-line;
    font-size: 14px;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
    width: max-content;
    max-width: 300px;
    z-index: 1000;
}

.info-tooltip:hover::after {
    opacity: 1;
    visibility: visible;
}

/* Usuń lub zakomentuj te style */
/*
#learningProgressLineChart {
    margin-top: 2rem;
    max-width: 75%;
    height: auto;
    max-height: 275px;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}
*/

/* Dodaj te style, aby poprawić wygląd wykresu słupkowego */
#learningProgressChart {
    margin-top: 2rem;
    max-width: 100%;
    height: auto;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.cancel-button {
    background-color: #dc3545;
    color: white;
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s ease;
}

.cancel-button:hover {
    background-color: #c82333;
}

.button-group {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 20px;
}

.button-group button {
    flex: 1;
}

.delete-all-button {
    background-color: #6c757d; /* Zmieniono na szary kolor */
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s;
}

.delete-all-button:hover {
    background-color: #5a6268; /* Ciemniejszy odcień szarego przy najechaniu */
}

.delete-all-button {
    width: 100%;
    box-sizing: border-box;
}

.go-back-button {
    background-color: transparent;
    color: #007ACC;
    border: none;
    font-size: 100px;
    font-weight: normal;
    cursor: pointer;
    padding: 0 10px;
    transition: color 0.3s;
    line-height: 1;
    position: relative;
    transform: translateY(-4px); /* Add this line to move the icon up by 4px */
}

.go-back-button:hover {
    color: #005A9E;
}

.go-back-button::before {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    padding: 8px 12px;
    background-color: #333;
    color: #fff;
    border-radius: 4px;
    font-size: 14px; /* Zmniejszono rozmiar czcionki z 18px na 14px */
    font-weight: normal;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
    pointer-events: none;
    width: max-content;
    max-width: 250px; /* Zmniejszono maksymalną szerokość */
    text-align: center;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

.go-back-button:hover::before {
    opacity: 1;
    visibility: visible;
    transition-delay: 1s; /* Opóźnienie 1 sekundy */
}

.review-header-left {
    display: flex;
    align-items: center;
}


.go-back-button:hover {
    color: #005A9E;
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid #007ACC;
}

.review-header-left, .review-header-right {
    display: flex;
    align-items: center;
}

.review-header-right {
    gap: 10px;
}

.go-back-button {
    background-color: transparent;
    color: #007ACC;
    border: none;
    font-size: 32px;
    cursor: pointer;
    padding: 0 10px;
    transition: color 0.3s;
}

.go-back-button:hover {
    color: #005A9E;
}

.selected-row {
  background-color: #e0e0e0;
}

#flashcardTable tbody tr:hover {
  background-color: #f5f5f5;
  cursor: pointer;
}

.settings-button {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    padding: 0 10px;
    transition: transform 0.3s ease;
}

.settings-button:hover {
    transform: rotate(30deg);
}

.review-header-right {
    display: flex;
    align-items: center;
    gap: 10px;
}

.more-options-button {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    padding: 0 10px;
    color: #007ACC;
    position: relative;
}

.more-options-button:hover {
    color: #005A9E;
}

.more-options-button::before {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    padding: 5px 10px;
    background-color: #333;
    color: #fff;
    border-radius: 4px;
    font-size: 14px;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
    transition-delay: 1s;
    pointer-events: none;
}

.more-options-button:hover::before {
    opacity: 1;
    visibility: visible;
}

.settings-form {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    z-index: 1000;
    width: 90%;
    max-width: 500px;
}

/*.settings-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 999;
}
*/
.settings-group {
    margin-bottom: 15px;
}

.settings-group label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
}

.settings-group select {
    width: 100%;
    padding: 8px;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    font-size: 14px;
}

.algorithm-description {
    background-color: #f8f9fa;
    padding: 10px;
    border-radius: 4px;
    margin: 15px 0;
}

.description-text {
    font-size: 14px;
    color: #667;
    margin: 5px 0;
}

.button-group {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 20px;
}

.quality-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 15px;
}

.grade-button {
    flex: 1;
    min-width: 150px;
    /* height: 35px; /* Stała wysokość */
    padding: 10px;
    border: none;
    white-space: nowrap;
    overflow: hidden; /* Ukrywa tekst, który nie mieści się w przycisku */
    text-overflow: ellipsis; /* Dodaje kropki, jeśli tekst jest za długi */
    font-size: 16px;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.2s ease;
    color: white;
    position: relative;
    transform: translateY(0); /* Początkowa pozycja */
    will-change: transform; /* Optymalizacja dla animacji */
    backface-visibility: hidden; /* Zapobiega migotaniu */
}

.grade-button.grade-0 { background-color: #777777; }
.grade-button.grade-1 { background-color: #777777;}
.grade-button.grade-2 { background-color: #777777; }
.grade-button.grade-3 { background-color: #777777; }
.grade-button.grade-4 { background-color: #777777;}
.grade-button.grade-5 { background-color: #777777; }

.grade-button:hover {
    background-color: #5f5f5f;
    transform: translateY(-2px);
    box-shadow: 0 2px 5px rgba(17, 17, 17, 0.3);
}

.grade-button:active {
    transform: translateY(0);
    box-shadow: none;
}

.difficulty-indicator {
    display: inline-block;
    padding: 3px 8px;
    border-radius: 3px;
    font-size: 12px;
    font-weight: bold;
    margin-left: 10px;
}

.difficulty-easy { background-color: #28a745; color: white; }
.difficulty-medium { background-color: #ffc107; color: black; }
.difficulty-hard { background-color: #fd7e14; color: white; }
.difficulty-veryHard { background-color: #dc3545; color: white; }

.review-mode-selection {
    padding: 20px;
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.review-modes {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin: 20px 0;
}

.review-mode-card {
    padding: 20px;
    background-color: #f8f9fa;
    border: 2px solid #dee2e6;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
}

.review-mode-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    border-color: #007bff;
}

.review-mode-card.selected {
    background-color: #e7f5ff;
    border-color: #007bff;
}

.card-count {
    font-size: 24px;
    font-weight: bold;
    color: #007bff;
    margin: 10px 0;
}

.review-options {
    margin-top: 20px;
    padding: 20px;
    background-color: #f8f9fa;
    border-radius: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 20px;
}

.number-selector {
    display: flex;
    align-items: center;
    gap: 10px;
}

.number-selector select,
.number-selector input {
    padding: 8px;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    font-size: 14px;
}

.start-review-button {
    display: block;
    width: 100%;
    margin: 20px auto 0;
    padding: 10px 20px;
    background-color: #28a745;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s ease;
}

.start-review-button:hover {
    background-color: #218838;
}

.cards-number-selection {
    margin-bottom: 10px;
}

.review-complete {
    text-align: center;
    padding: 40px;
    background-color: #f8f9fa;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    animation: fadeInOut 2s ease-in-out;
}

@keyframes fadeInOut {
    0% { opacity: 0; }
    20% { opacity: 1; }
    80% { opacity: 1; }
    100% { opacity: 0; }
}

.settings-form .button-group .submit-button {
    background-color: #28a745;  /* zielony */
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.settings-form .button-group .submit-button:hover {
    background-color: #218838;  /* ciemniejszy zielony przy najechaniu */
}

.settings-form .button-group .cancel-button {
    background-color: #dc3545;  /* czerwony */
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.settings-form .button-group .cancel-button:hover {
    background-color: #c82333;  /* ciemniejszy czerwony przy najechaniu */
}

.cards-number-options {
    margin: 15px 0;
}

.checkbox-group {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin-top: 10px;
}

.checkbox-option {
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
    padding: 5px 10px;
    border-radius: 4px;
}

.checkbox-option:hover {
    background-color: transparent;
}

.checkbox-option input[type="radio"] {
    margin: 0;
    cursor: pointer;
}

.checkbox-option span {
    font-size: 14px;
}

#customNumberInput {
    width: 60px;
    padding: 2px 5px;
    margin-left: 5px;
    border: 1px solid #dee2e6;
    border-radius: 4px;
}

#customNumberInput:not(.hidden) {
    display: inline-block;
}

#leitnerBoxesChart, #superMemoChart, #superMemoIntervalsChart {
    margin-top: 2rem;
    margin-bottom: 2rem;
    width: 100% !important;
    height: auto !important;
    max-width: 600px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    display: block;
    margin-left: 0;
    margin-right: auto;
}

body.dark-mode #leitnerBoxesChart,
body.dark-mode #superMemoChart,
body.dark-mode #superMemoIntervalsChart {
    border-color: #404040;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
}

/* Dodaj specyficzny odstęp dla pierwszego wykresu */
#learningProgressChart {
    margin-top: 2rem;
    margin-bottom: 3rem;
    max-width: 300px;
    display: block;
    margin-left: 0;
    margin-right: auto;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    width: 100% !important;
    height: auto !important;
}

.button-row {
    display: flex;
    justify-content: space-between;
    margin-top: 10px;
    align-items: center; /* Align items vertically */
}

.show-translation {
    background-color: #777777;
    color: white;
    flex: 1; /* Allow the button to grow and fill space */
    margin-right: 10px; /* Add some space between the buttons */
}

.quality-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 0; /* Remove top margin to align with the button row */
    flex: 1; /* Allow the buttons to grow and fill space */
}

.hidden {
    display: none;
}


/* Usuwamy poprzednie style dla tooltipów i dodajemy nowe */


.grade-button.grade-0[data-tooltip]:after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: calc(100% - 32px); /* Zmieniono z calc(100% + 10px) na calc(100% - 35px) */
    left: 50%;
    transform: translateX(-50%);
    background-color: #777777;
    color: white;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 14px;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: all 0.2s ease;
    transition-delay: 5s;
    z-index: 1000;
}


.grade-button.grade-0[data-tooltip]:hover:after {
    opacity: 1;
    visibility: hidden; /* tool tip disabled */
    background-color:#5f5f5f;
}

.more-info {
    margin: 15px 0;
    padding: 10px;
    border-top: 1px solid #dee2e6;
    text-align: left;
    font-size: 14px;
    line-height: 1;
}

.more-info p {
    margin: 0;
    display: block;
}

.more-info span {
    margin-left: 0; /* Zmieniono z 10px na 0 */
    color: inherit;
    font-size: 14px;
}

.more-info a {
    margin-left: 0; /* Zmieniono z 10px na 0 */
    color: #007bff;
    text-decoration: none;
    font-size: 14px;
}

.more-info a:hover {
    text-decoration: underline;
}

/* Style dla przycisku Sync */
.sync-button {
    background-color: #28a745;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.3s ease;
    font-size: 14px;
    height: 32px;
}

.sync-button:hover {
    background-color: #218838;
}

.sync-button.syncing {
    background-color: #dc3545;
    animation: pulse 2s infinite;
    cursor: wait;
}

.sync-button.syncing:hover {
    background-color: #c82333;
}

.sync-button.new-sync {
    background-color: #dc3545;
    animation: pulse 2s infinite;
}

.sync-button.new-sync:hover {
    background-color: #c82333;
}

.sync-icon {
    display: inline-block;
    transition: transform 0.3s ease;
}

.syncing .sync-icon {
    animation: rotate 1s linear infinite;
}

@keyframes rotate {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

@keyframes pulse {
    0% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.05);
    }
    100% {
        transform: scale(1);
    }
}

/* Style dla powiadomień */

.notification {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 15px 20px;
    border-radius: 4px;
    color: white;
    max-width: 300px;
    z-index: 1000;
    animation: slideIn 0.3s ease-out;
}

.notification-content {
    display: flex;
    align-items: center;
    gap: 12px;
}

.notification-message {
    flex-grow: 1;
    font-size: 14px;
    line-height: 1.4;
}

.notification-close {
    background: none;
    border: none;
    color: inherit;
    font-size: 20px;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s;
    padding: 0;
    margin: 0;
}

.notification-close:hover {
    opacity: 1;
}

/* Kolory powiadomień */
.notification.info {
    background-color:#17a2b8; /* #cce5ff; */

}

.notification.success {
    background-color: #28a745; /* #d4edda; */

}

.notification.error {
    background-color: #dc3545; /* #f8d7da; */

}

.notification.warning {
    background-color: #f3c23c;

}

/* Animacje dla powiadomień */
@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.notification.fade-out {
    animation: fadeOut 0.3s ease-in forwards;
}

@keyframes fadeOut {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(100%);
        opacity: 0;
    }
}

/* Dostosowanie dla małych ekranów */
@media (max-width: 768px) {
    .notification {
        top: auto;
        bottom: 20px;
        left: 20px;
        right: 20px;
        max-width: none;
    }
}

/* Style dla okna dialogowego Pushbullet */
.pushbullet-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 24px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 1001;
    width: 90%;
    max-width: 400px;
}

.dialog-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1000;
}

.pushbullet-dialog h3 {
    margin: 0 0 16px 0;
    color: #333;
}

.pushbullet-dialog p {
    margin: 0 0 16px 0;
    color: #667;
}

.pushbullet-dialog input {
    width: 100%;
    padding: 8px;
    margin-bottom: 16px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

.dialog-buttons {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
}

/* Dodatkowe style dla przycisku w headerze */
.header-right .sync-button {
    margin-right: 10px;
}

/* Style dla przycisku podczas usuwania notatek */
.sync-button.deleting {
    opacity: 0.7;
    cursor: not-allowed;
}

/* Style dla przycisku MainSettings */
.main-settings-button {
    background: rgba(0, 0, 0, 0) !important; /* Przezroczyste tło */
    color: #333;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 32px;
    min-width: 40px;
    position: relative;
    transition: background-color 0.2s ease !important;
}

/* Zmiana tła przy najechaniu */
.nav-button.main-settings-button:hover,
.main-settings-button:hover {
    background: rgba(0, 0, 0, 0.05) !important; /* Lekko przyciemnione tło przy hover */
    color: #333 !important;
    transform: none !important;
    box-shadow: none !important;
}

.main-settings-button[data-tooltip]:hover::before {
    content: attr(data-tooltip);
    position: absolute;
    top: -35px;
    left: 50%;
    transform: translateX(-50%);
    padding: 5px 10px;
    background-color: #333;
    color: white;
    font-size: 14px;
    border-radius: 4px;
    white-space: nowrap;
    z-index: 1000;
}

.main-settings-button[data-tooltip]:hover::after {
    content: '';
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    border-width: 5px;
    border-style: solid;
    border-color: #333 transparent transparent transparent;
    z-index: 1000;
}

/* Dostosowanie dla małych ekranów */
@media (max-width: 768px) {
    .main-settings-button {
        width: 100%;
        height: 40px;
        margin: 5px 0;
    }
}

/* Style dla okna ustawień głównych */
.main-settings-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 30px;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    z-index: 1001;
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    overflow-y: auto;
    animation: slideDown 0.3s ease-out;
}

.main-settings-dialog h2 {
    margin: 0 0 20px 0;
    color: #333;
    font-size: 24px;
    border-bottom: 2px solid #007bff;
    padding-bottom: 10px;
}

.settings-section {
    margin-bottom: 25px;
}

.settings-section h3 {
    color: #555;
    font-size: 18px;
    margin-bottom: 15px;
}

.settings-content {
    padding: 15px;
    background: #f8f9fa;
    border-radius: 6px;
    margin-bottom: 20px;
}

.settings-footer {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #dee2e6;
}

.settings-footer button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
}

.settings-save {
    background-color: #28a745;
    color: white;
}

.settings-save:hover {
    background-color: #218838;
}

.settings-cancel {
    background-color: #dc3545;
    color: white;
}

.settings-cancel:hover {
    background-color: #c82333;
}

.settings-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: transparent;
    z-index: 1000;
    backdrop-filter: none;
}

/* Animacja dla okna dialogowego */
@keyframes slideDown {
    from {
        transform: translate(-50%, -60%);
        opacity: 0;
    }
    to {
        transform: translate(-50%, -50%);
        opacity: 1;
    }
}

.main-settings-dialog {
    animation: slideDown 0.3s ease-out;
}

/* Style dla sekcji API key */
.settings-group {
    margin-bottom: 15px;
}

.settings-group label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    color: #333;
}

.api-key-input {
    display: flex;
    gap: 8px;
    align-items: center;
}

.api-key-input input {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

.toggle-password {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 16px;
    padding: 4px 8px;
    color: #667;
    transition: color 0.2s ease;
}

.toggle-password:hover {
    color: #333;
}

.api-key-info {
    margin-top: 8px;
    font-size: 12px;
}

.api-key-info a {
    color: #007bff;
    text-decoration: none;
}

.api-key-info a:hover {
    text-decoration: underline;
}

/* Style dla opcji synchronizacji */
.sync-settings {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #dee2e6;
}

.auto-sync-option {
    margin-bottom: 15px;
}

.checkbox-label {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
}

.checkbox-label input[type="checkbox"] {
    width: 16px;
    height: 16px;
    cursor: pointer;
}

.sync-interval-option {
    display: flex;
    align-items: center;
    gap: 10px;
    transition: opacity 0.3s ease;
}

.sync-interval-option.disabled {
    opacity: 0.5;
}

.sync-interval-option select {
    padding: 6px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    width: 100px;
}

.sync-interval-option select:disabled {
    background-color: #f8f9fa;
    cursor: not-allowed;
}

/* Style dla przycisku usuwania notatek */
.delete-notes-option {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #dee2e6;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.delete-notes-button {
    background-color: #6c757d; /* Zmieniono z #dc3545 (czerwony) na #6c757d (szary) */
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    width: auto;
    min-width: 120px;
    transition: background-color 0.2s ease;
}

.delete-notes-button:hover {
    background-color: #5a6268; /* Zmieniono z #c82333 na ciemniejszy odcień szarego */
}

.delete-notes-button.deleting {
    opacity: 0.7;
    cursor: not-allowed;
}

.delete-notes-info {
    margin-top: 8px;
    font-size: 12px;
    color: #6c757d; /* Zmieniono kolor tekstu ostrzeżenia również na szary */
    text-align: center;
    width: 100%;
}

.delete-notes-info span {
    display: block;
    line-height: 1.4;
}

/* Style dla okna potwierdzenia */
.confirm-dialog {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1002;
}

.confirm-content {
    background: white;
    padding: 24px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    max-width: 400px;
    width: 90%;
}

.confirm-content h3 {
    margin: 0 0 16px 0;
    color: #dc3545;
}

.confirm-content p {
    margin: 0 0 20px 0;
    color: #667;
    line-height: 1.5;
}

.confirm-buttons {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

.confirm-yes {
    background-color: #dc3545;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.confirm-yes:hover {
    background-color: #c82333;
}

.confirm-no {
    background-color: #6c757d;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.confirm-no:hover {
    background-color: #5a6268;
}

/* Style dla ikony ładowania */
.loading-icon {
    display: inline-block;
    animation: rotate 1s linear infinite;
    margin-right: 8px;
}

.delete-notes-button.deleting {
    opacity: 0.7;
    cursor: not-allowed;
}

.delete-notes-button.deleting .loading-icon {
    display: inline-block;
}

@keyframes rotate {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

/* Style dla wskaźnika postępu usuwania */
.delete-progress {
    margin-left: 8px;
    font-size: 12px;
    opacity: 0.8;
}

.delete-notes-button.deleting {
    min-height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

/* Style dla opisu w sekcji ustawień */
.settings-description {
    margin: 0 0 15px 0;
    color: #667;
    font-size: 14px;
    line-height: 1.4;
}

.sync-warning {
    margin-top: 10px;
    padding: 10px;
    background-color: #fff;
    border: 1px solid #dee2e6;
    color: #666;
    border-radius: 4px;
    font-size: 13px;
    line-height: 1.4;
}

/* Style dla przycisku sync z nową synchronizacją */
.sync-button.new-sync {
    background-color: #dc3545;
    animation: pulse 2s infinite;
}

.sync-button.new-sync:hover {
    background-color: #c82333;
}

@keyframes pulse {
    0% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.05);
    }
    100% {
        transform: scale(1);
    }
}

/* Style dla tooltipa przycisku sync */
.sync-button[data-tooltip]::before {
    content: attr(data-tooltip);
    position: absolute;
    bottom: -80px;
    left: 50%;
    transform: translateX(-50%);
    padding: 8px 12px;
    background-color: #333;
    color: white;
    font-size: 14px;
    border-radius: 4px;
    white-space: normal;
    max-width: 300px;
    width: max-content;
    text-align: center;
    visibility: hidden;
    opacity: 0;
    transition: opacity 0.3s;
    z-index: 1000;
    transition-delay: 1s; /* Dodane: opóźnienie 1 sekunda */
}

/* Usuwamy całkowicie strzałkę */
.sync-button[data-tooltip]::after {
    display: none;
}

.sync-button[data-tooltip]:hover::before {
    visibility: visible;
    opacity: 1;
}

.remove-api-key {
    background: none;
    border: none;
    color: #333;
    cursor: pointer;
    font-size: 16px;
    padding: 4px 8px;
    transition: color 0.2s ease;
}

.remove-api-key:hover {
    color: #000;
}

.header-right {
    position: relative;
    display: flex;
    align-items: center;
    gap: 15px;
    margin-right: 0px;
    overflow: visible; /* Dodane: pozwala na wyświetlanie elementów poza kontenerem */
}

#save-button, #sync-button {
    margin-right: 0; /* Usuwamy wszystkie dodatkowe marginesy */
}

.save-container {
    position: relative;
    display: inline-block;
}

.save-link {
    position: absolute;
    top: 100%;
    left: -100px; /* Przesunięcie w lewo */
    margin-top: 5px;
    font-size: 12px;
    z-index: 1000;
    white-space: nowrap;
    padding-right: 10px;
    pointer-events: auto; /* Dodane: zapewnia działanie linku */
    width: fit-content; /* Dodane: szerokość dopasowana do zawartości */
}

.save-link a {
    color: #007bff;
    text-decoration: none;
}

.save-link a:hover {
    text-decoration: underline;
}

/* Style dla przycisku Save */
#save-button {
    min-width: 85px; /* Dodane: stała minimalna szerokość */
    width: 85px;    /* Dodane: stała szerokość */
}

#save-button .sync-icon {
    animation: none !important; /* Wyłączenie animacji dla ikony w przycisku Save */
}

/* Zachowujemy animację tylko dla przycisku Sync */
#sync-button .sync-icon {
    display: inline-block;
    transition: transform 0.3s ease;
}

#sync-button.syncing .sync-icon {
    animation: rotate 1s linear infinite;
}

#save-button {
    display: none; /* Domyślnie ukryty */
}

#save-button.show {
    display: flex; /* Pokazujemy tylko gdy ma klasę show */
}

.header-right {
    position: relative;
    display: flex;
    align-items: center;
    gap: 15px;
    margin-right: 0px;
    overflow: visible;
}

.buttons-container {
    position: relative;
    display: flex;
    align-items: center;
    gap: 15px;
    margin-right: 8px;  /* usuwa lukę z prawej */
}

#save-button {
    display: none;
}

#save-button.show {
    display: flex;
}

.save-link {
    position: absolute;
    top: 100%;
    /* left: -105px; */
    margin-top: 5px;
    font-size: 12px;
    z-index: 1000;
    white-space: nowrap;
 
}

.save-link a {
    color: #007bff;
    text-decoration: none;
}

.save-link a:hover {
    text-decoration: underline;
}

/* Dodajemy media query dla małych ekranów */
@media (max-width: 768px) {
    .save-link {
        left: 0; /* Resetujemy przesunięcie w lewo */
   
      
    }
}

/* Resetowanie opóźnienia gdy myszka opuści przycisk */
.sync-button[data-tooltip]:not(:hover)::before {
    transition-delay: 0s;
}

/* Media query dla małych ekranów */
@media (max-width: 768px) {
    #sync-button[data-tooltip]::before {
        top: -10px;
        bottom: -10px;
        left: 70px; /* Resetujemy left */
        right: 0; /* Przesuwamy w prawo */
        transform: none; /* Usuwamy transformację */
    }
}

/* Dodaj style dla nowej opcji */
.auto-save-option {
    margin-bottom: 15px;
}

.auto-save-option .checkbox-label {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
}

.auto-save-option .checkbox-label input[type="checkbox"] {
    width: 16px;
    height: 16px;
    cursor: pointer;
}

.auto-save-option .checkbox-label span {
    flex: 1; /* Pozwala tekstowi się zawijać */
}

/* Ujednolicone style dla wszystkich opcji w ustawieniach */
.export-server-option,
.auto-save-option,
.sync-check-option,
.sync-after-review-option,
.auto-sync-option {
    margin-bottom: 15px;
}


/* Dodaj style dla tooltipa w ustawieniach */
.settings-group .checkbox-label[data-tooltip] {
    position: relative;
}

.settings-group .checkbox-label[data-tooltip]::before {
    content: attr(data-tooltip);
    position: absolute;
    bottom: calc(100% + 5px);
    left: 0;
    background-color: #333;
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    white-space: normal;
    max-width: 300px;
    visibility: hidden;
    opacity: 0;
    transition: opacity 0.3s;
    transition-delay: 1s;
    z-index: 1000;
    line-height: 1.4;
}

.settings-group .checkbox-label[data-tooltip]:hover::before {
    visibility: visible;
    opacity: 1;
}

/* Resetowanie opóźnienia gdy myszka opuści element */
.settings-group .checkbox-label[data-tooltip]:not(:hover)::before {
    transition-delay: 0s;
}

/* Dark mode styles */
body.dark-mode {
    background-color: #1a1a1a;
    color: #e0e0e0;
}

body.dark-mode .container {
    background-color: #2d2d2d;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

body.dark-mode header {
    background-color: #2d2d2d;
    border-bottom: 1px solid #404040;
}

body.dark-mode .nav-button {
    background-color: #404040;
}

body.dark-mode .nav-button:hover {
    background-color: #505050;
}

body.dark-mode .nav-button.active {
    background-color: #28a745;
}

body.dark-mode textarea,
body.dark-mode input[type="text"] {
    background-color: #333;
    color: #e0e0e0;
    border-color: #404040;
}

body.dark-mode #flashcardTable th {
    background-color: #404040;
    color: #e0e0e0;
}

body.dark-mode #flashcardTable td {
    border-bottom: 1px solid #404040;
}

body.dark-mode #flashcardTable tr:hover {
    background-color: #383838;
}

body.dark-mode .note-form {
    background-color: #333;
    border-color: #404040;
}

body.dark-mode .info-box {
    background-color: #333;
    border-color: #404040;
}

body.dark-mode .section-header {
    border-bottom-color: #404040;
}

body.dark-mode .dark-mode-button {
    background-color: transparent;
    border: none;
    color: #e0e0e0;
    cursor: pointer;
    padding: 8px 16px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background-color 0.3s;
}

body.dark-mode .dark-mode-button:hover {
    background-color: #404040;
}

/* Light mode button styles */
.dark-mode-button {
    background-color: transparent;
    border: none;
    color: #333;
    cursor: pointer;
    padding: 8px 16px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background-color 0.3s;
}

.dark-mode-button:hover {
    background-color: #f0f0f0;
}

/* Dodatkowe style dla element��w w trybie ciemnym */
body.dark-mode .selected-row {
    background-color: #404040;
}

body.dark-mode .grade-button {
    background-color: #404040;
}

body.dark-mode .grade-button:hover {
    background-color: #505050;
}

body.dark-mode select {
    background-color: #333;
    color: #e0e0e0;
    border-color: #404040;
}

body.dark-mode .review-mode-card {
    background-color: #333;
    border-color: #404040;
}

body.dark-mode .review-mode-card:hover {
    background-color: #404040;
}

body.dark-mode .review-mode-card.selected {
    background-color: #28a745;
    color: #fff;
}

body.dark-mode .card-content {
    background-color: #2d2d2d;
    border-color: #404040;
}

/*body.dark-mode .translation {
    background-color: #333;
    border-color: #404040;
}*/

/* Dodatkowe style dla sekcji Review w trybie ciemnym */
body.dark-mode .review-mode-selection {
    background-color: #2d2d2d;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

body.dark-mode .review-options {
    background-color: #333;
    border-color: #404040;
}

body.dark-mode .checkbox-option {
    color: #e0e0e0;
}

body.dark-mode .checkbox-option:hover {
    background-color: #404040;
}

body.dark-mode #customNumberInput {
    background-color: #333;
    color: #e0e0e0;
    border-color: #404040;
}

body.dark-mode .quality-buttons button {
    background-color: #404040;
    color: #e0e0e0;
}

body.dark-mode .quality-buttons button:hover {
    background-color: #505050;
}

body.dark-mode .show-translation {
    background-color: #404040;
    color: #e0e0e0;
}

body.dark-mode .show-translation:hover {
    background-color: #505050;
}

body.dark-mode .review-complete {
    background-color: #333;
    color: #e0e0e0;
}

body.dark-mode .cards-number-options {
    color: #e0e0e0;
}

body.dark-mode .start-review-button {
    background-color: #28a745;
    color: #e0e0e0;
}

body.dark-mode .start-review-button:hover {
    background-color: #218838;
}

/* Style dla tooltipów w trybie ciemnym */
body.dark-mode [data-tooltip]::before {
    background-color: #505050;
    color: #e0e0e0;
}

body.dark-mode [data-tooltip]::after {
    border-color: #505050 transparent transparent transparent;
}

/* Style dla przycisków oceny w trybie ciemnym */
body.dark-mode .grade-button {
    background-color: #404040;
    color: #e0e0e0;
    border: 1px solid #505050;
}

body.dark-mode .grade-button:hover {
    background-color: #505050;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

/* Style dla komunikatów w trybie ciemnym */
body.dark-mode .review-complete,
body.dark-mode .no-flashcards-message {
    background-color: #333;
    color: #e0e0e0;
    border-color: #404040;
}

/* Style dla pól tekstowych w trybie ciemnym */
body.dark-mode .card-content pre {
    background-color: #333;
    color: #e0e0e0;
    border: 1px solid #404040;
}

body.dark-mode .card-content p {
    color: #e0e0e0;
}

body.dark-mode .card-content p strong {
    color: #e0e0e0;
}

/* Style dla tekstu "No context provided" w trybie ciemnym */
body.dark-mode .card-content pre:empty::before,
body.dark-mode .card-content pre:only-child::before {
    content: "No context provided";
    color: #888;
}

/* Styl dla pierwszego wykresu */
#learningProgressChart {
    margin-top: 2rem;
    margin-bottom: 3rem;
    max-width: 300px;
    display: block;
    margin-left: 0;
    margin-right: auto;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    width: 100% !important;
    height: auto !important;
}

/* Style dla trybu ciemnego */
body.dark-mode #learningProgressChart {
    border-color: #404040;
}

/* Style dla przycisków w tabeli w trybie ciemnym */
body.dark-mode #flashcardTable button {
    background-color: #404040;
    color: #e0e0e0;
    border: none;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s;
}

body.dark-mode #flashcardTable button:hover {
    background-color: #505050;
}

/* Specyficzne style dla przycisku Delete */
body.dark-mode #flashcardTable button[onclick*="deleteFlashcard"] {
    background-color: #404040;
}

body.dark-mode #flashcardTable button[onclick*="deleteFlashcard"]:hover {
    background-color: #505050;
}

/* Specyficzne style dla przycisku Edit */
body.dark-mode #flashcardTable button[onclick*="editFlashcard"] {
    background-color: #404040;
}

body.dark-mode #flashcardTable button[onclick*="editFlashcard"]:hover {
    background-color: #505050;
}

/* Style dla formularza edycji w trybie ciemnym */
body.dark-mode .edit-form {
    background-color: #2d2d2d;
    border-color: #404040;
    color: #e0e0e0;
}

body.dark-mode .edit-form h2 {
    color: #e0e0e0;
}

body.dark-mode .edit-form textarea,
body.dark-mode .edit-form input[type="text"] {
    background-color: #333;
    color: #e0e0e0;
    border-color: #404040;
}

body.dark-mode .edit-form textarea:focus,
body.dark-mode .edit-form input[type="text"]:focus {
    border-color: #505050;
    outline: none;
}

body.dark-mode .edit-form .button-group button {
    background-color: #404040;
    color: #e0e0e0;
}

body.dark-mode .edit-form .button-group button:hover {
    background-color: #505050;
}

body.dark-mode .edit-form .button-group .submit-button {
    background-color: #28a745;
}

body.dark-mode .edit-form .button-group .submit-button:hover {
    background-color: #218838;
}

body.dark-mode .edit-form .button-group .cancel-button {
    background-color: #dc3545;
}

body.dark-mode .edit-form .button-group .cancel-button:hover {
    background-color: #c82333;
}

/* Style dla okna ustawień głównych w trybie ciemnym */
body.dark-mode .main-settings-dialog {
    background-color: #2d2d2d;
    color: #e0e0e0;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

body.dark-mode .main-settings-dialog h2 {
    color: #e0e0e0;
    border-bottom-color: #404040;
}

body.dark-mode .main-settings-dialog h3 {
    color: #e0e0e0;
}

body.dark-mode .settings-content {
    background-color: #333;
    border-color: #404040;
}

body.dark-mode .settings-description {
    color: #bbb;
}

/* Style dla inputów i selectów w ustawieniach */
body.dark-mode .main-settings-dialog input[type="text"],
body.dark-mode .main-settings-dialog input[type="password"],
body.dark-mode .main-settings-dialog select {
    background-color: #333;
    color: #e0e0e0;
    border-color: #404040;
}

body.dark-mode .main-settings-dialog input[type="text"]:focus,
body.dark-mode .main-settings-dialog input[type="password"]:focus,
body.dark-mode .main-settings-dialog select:focus {
    border-color: #505050;
    outline: none;
}

/* Style dla przycisków w ustawieniach */
body.dark-mode .main-settings-dialog .toggle-password,
body.dark-mode .main-settings-dialog .remove-api-key {
    color: #e0e0e0;
}

body.dark-mode .main-settings-dialog .toggle-password:hover,
body.dark-mode .main-settings-dialog .remove-api-key:hover {
    color: #fff;
}

/* Style dla sekcji API key */
body.dark-mode .api-key-info {
    color: #bbb;
}

body.dark-mode .api-key-info a {
    color: #66b3ff;
}

/* Style dla opcji synchronizacji */
body.dark-mode .sync-settings {
    border-top-color: #404040;
}

body.dark-mode .checkbox-label {
    color: #e0e0e0;
}

body.dark-mode .sync-interval-option select:disabled {
    background-color: #2d2d2d;
    color: #666;
}

/* Style dla przycisku usuwania notatek */
body.dark-mode .delete-notes-button {
    background-color: #404040;
}

body.dark-mode .delete-notes-button:hover {
    background-color: #505050;
}

body.dark-mode .delete-notes-info {
    color: #bbb;
}

/* Style dla stopki ustawień */
body.dark-mode .settings-footer {
    border-top-color: #404040;
}

/* Style dla tooltipów w ustawieniach */
body.dark-mode .settings-group .checkbox-label[data-tooltip]::before {
    background-color: #505050;
    color: #e0e0e0;
}

/* Style dla opisu algorytmu */
body.dark-mode .algorithm-description {
    background-color: #333;
    border: 1px solid #404040;
}

body.dark-mode .description-text {
    color: #bbb;
}

/* Style dla linków "More information" */
body.dark-mode .more-info {
    border-top-color: #404040;
}

body.dark-mode .more-info a {
    color: #66b3ff;
}

/* Style dla okna Review Settings w trybie ciemnym */
body.dark-mode .settings-form {
    background-color: #2d2d2d;
    color: #e0e0e0;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

body.dark-mode .settings-form h3 {
    color: #e0e0e0;
}

body.dark-mode .settings-group {
    border-color: #404040;
}

body.dark-mode .settings-group select {
    background-color: #333;
    color: #e0e0e0;
    border-color: #404040;
}

body.dark-mode .settings-group select:focus {
    border-color: #505050;
    outline: none;
}

body.dark-mode .review-modes-options {
    color: #e0e0e0;
}

body.dark-mode .algorithm-description {
    background-color: #333;
    border: 1px solid #404040;
}

body.dark-mode .description-text {
    color: #bbb;
}

body.dark-mode .more-info {
    border-top-color: #404040;
}

body.dark-mode .more-info a {
    color: #66b3ff;
}

body.dark-mode .checkbox-label {
    color: #e0e0e0;
}

body.dark-mode .checkbox-option input[type="checkbox"] {
    background-color: #333;
    border-color: #404040;
}

/* Style dla przycisków w oknie ustawień */
body.dark-mode .settings-form .button-group button {
    background-color: #404040;
    color: #e0e0e0;
}

body.dark-mode .settings-form .button-group button:hover {
    background-color: #505050;
}

body.dark-mode .settings-form .button-group .submit-button {
    background-color: #28a745;
}

body.dark-mode .settings-form .button-group .submit-button:hover {
    background-color: #218838;
}

body.dark-mode .settings-form .button-group .cancel-button {
    background-color: #dc3545;
}

body.dark-mode .settings-form .button-group .cancel-button:hover {
    background-color: #c82333;
}

/* Style dla przycisku z trzema kropkami w trybie ciemnym */
body.dark-mode .more-options-button {
    color: #e0e0e0;
}

body.dark-mode .more-options-button:hover {
    color: #fff;
}

/* Tooltip dla przycisku w trybie ciemnym */
body.dark-mode .more-options-button::before {
    background-color: #505050;
    color: #e0e0e0;
}

/* Style dla przycisku Main Settings (⋮) */
.main-settings-button {
    color: #333;
}

/* Style dla przycisku Main Settings (⋮) w trybie ciemnym */
body.dark-mode .main-settings-button {
    color: #e0e0e0;
}

body.dark-mode .main-settings-button:hover {
    color: #fff;
    background-color: rgba(255, 255, 255, 0.1);
}

/* Tooltip dla przycisku w trybie ciemnym */
body.dark-mode .main-settings-button[data-tooltip]:hover::before {
    background-color: #505050;
    color: #e0e0e0;
}

body.dark-mode .main-settings-button[data-tooltip]:hover::after {
    border-color: #505050 transparent transparent transparent;
}

/* Style dla przycisku Dictionary */
#toggle-dictionary {
    background-color: #777777;
    color: white;
}

/* Style dla przycisku Dictionary w trybie ciemnym */
body.dark-mode #toggle-dictionary {
    background-color: #404040;
    color: #e0e0e0;
}

body.dark-mode #toggle-dictionary:hover {
    background-color: #505050;
}

/* Style dla ikon trybu ciemnego */
.dark-mode-icon {
    font-size: 22px; /* Zwiększamy rozmiar z domyślnego na 24px */
    line-height: 1;
    display: inline-block;
    vertical-align: middle;
}

/* Dodajemy padding dla lepszego wycentrowania */
.dark-mode-button {
    padding: 4px 12px;
}

/* Style dla zielonych przycisków w trybie ciemnym */
body.dark-mode .nav-button.active,
body.dark-mode .submit-button,
body.dark-mode .settings-form .button-group .submit-button,
body.dark-mode .main-settings-dialog .button-group .submit-button,
body.dark-mode .edit-form .button-group .submit-button,
body.dark-mode .start-review-button,
body.dark-mode .review-mode-card.selected {
    background-color: #1a7f37; /* Ciemniejszy odcień zielonego */
}

body.dark-mode .nav-button.active:hover,
body.dark-mode .submit-button:hover,
body.dark-mode .settings-form .button-group .submit-button:hover,
body.dark-mode .main-settings-dialog .button-group .submit-button:hover,
body.dark-mode .edit-form .button-group .submit-button:hover,
body.dark-mode .start-review-button:hover {
    background-color: #155d2a; /* Jeszcze ciemniejszy odcień przy najechaniu */
}

/* Style dla przycisku Info w trybie ciemnym */
body.dark-mode .info-button {
    background-color: #404040;
    color: #e0e0e0;
}

body.dark-mode .info-button:hover {
    background-color: #505050;
}

/* Style dla tooltipa przycisku trybu ciemnego */
.dark-mode-button[data-tooltip]::before {
    content: attr(data-tooltip);
    position: absolute;
    bottom: -35px; /* Zmienione z top na bottom */
    left: 50%;
    transform: translateX(-50%);
    padding: 5px 10px;
    background-color: #333;
    color: white;
    font-size: 14px;
    border-radius: 4px;
    white-space: nowrap;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0s linear 1s;
}

/* Usuwamy strzałkę (after) */
.dark-mode-button[data-tooltip]::after {
    display: none;
}

.dark-mode-button[data-tooltip]:hover::before {
    opacity: 1;
    visibility: visible;
    transition-delay: 1s;
}

/* Resetowanie opóźnienia gdy myszka opuści przycisk */
.dark-mode-button[data-tooltip]:not(:hover)::before {
    opacity: 0;
    visibility: hidden;
    transition-delay: 0s;
}

/* Style dla przycisku Sync w trybie ciemnym */
body.dark-mode .sync-button {
    background-color: #1a7f37; /* Ten sam ciemniejszy odcień zielonego co inne przyciski */
    color: #e0e0e0;
}

body.dark-mode .sync-button:hover {
    background-color: #155d2a; /* Ten sam ciemniejszy odcień przy najechaniu */
}

/* Style dla przycisku Start Review w trybie ciemnym */
body.dark-mode .start-review-button {
    background-color: #1a7f37; /* Ten sam ciemniejszy odcień zielonego co inne przyciski */
    color: #e0e0e0;
}

body.dark-mode .start-review-button:hover {
    background-color: #155d2a; /* Ten sam ciemniejszy odcień przy najechaniu */
}

.radio-group.horizontal {
    display: flex;
    align-items: center;
    gap: 20px;
    margin-top: 10px;
}

.radio-group .radio-option {
    display: flex;
    align-items: center;
    cursor: pointer;
}

.radio-group .radio-label {
    font-size: 16px;  /* Taki sam rozmiar czcionki jak inne opcje */
    margin-left: 5px;
    font-family: inherit;  /* Dziedziczy czcionkę z formularza */
}

.radio-group input[type="number"] {
    width: 60px;
    margin-left: 10px;
    padding: 2px 5px;
    font-size: 16px;
}

/* Stylizacja radio buttonów */
.radio-group input[type="radio"] {
    margin-right: 5px;
}

/* Dopasowanie do trybu ciemnego */
.dark-mode .radio-group .radio-label {
    color: #e0e0e0;
}

@media (max-width: 768px) {
    .header-right {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: flex-end;
    }

    .buttons-container {
        order: 1;
        display: flex;
        align-items: center;
    }

    .language-select {
        order: 2;
        margin-left: 10px;
    }

    /* Usuwamy niepotrzebne style dla main-settings-button */
    .main-settings-button {
        height: 40px;
        margin: 0 5px;
    }


}

/* Istniejące style dla header-right */
.header-right {
    display: flex;
    align-items: center;
    gap: 10px;
}

/* Dodaj nowe style dla bardzo małych ekranów */
@media (max-width: 390px) {
    .header-right {
        gap: 10px;  /*Zmniejszamy odstępy między elementami */
    }

    .language-select select {
        padding: 5px 2px; /* Zmniejszamy padding */
        font-size: 13px; /* Zmniejszamy czcionkę */
        min-width: 70px; /* Minimalna szerokość selecta */
    }

    .main-settings-button {
        padding: 5px 8px; /* Zmniejszamy padding przycisku */
        min-width: auto; /* Usuwamy minimalną szerokość */
    }

    .buttons-container {
        gap: 5px; /* Zmniejszamy odstępy między przyciskami */
    }

    /* Opcjonalnie: zmniejszamy inne przyciski w headerze */
    .sync-button, .dark-mode-button {
        padding: 5px 20px;
    }

    /* Biały formularz */
    .container {
        width: 100% !important;
        padding: 25px !important;
        margin: 0 !important;
        box-sizing: border-box !important;
    }

    /* Przycisk My Playlists */
    .playlist-button {
        height: 40px !important;
        white-space: nowrap !important;
    }

    /* Przyciski w headerze */
    .section-header {
        padding: 0 10px !important;
        width: calc(100% - 20px) !important;
        box-sizing: border-box !important;
        display: flex !important;
        justify-content: space-between !important;
        align-items: center !important;
    }

    /* Przycisk Info */
    .info-button {
        padding: 5px 5px !important;
    }
}


/* Style dla kontenera słownika w reps.html */
.reps-dictionary-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    position: fixed;
    top: 200px;
    right: -33.33%;
    width: 33.33%;
    height: calc(100% - 220px);
    transition: right 0.3s ease-in-out;
    z-index: 1000;
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.reps-dictionary-container.show {
    right: 0;
}

.reps-dictionary-header {
    display: flex;
    align-items: center;
    padding: 10px;
    background-color: #f8f9fa;
    border-bottom: 1px solid #dee2e6;
}

.reps-back-arrow {
    font-size: 24px;
    cursor: pointer;
    margin-right: 15px;
    width: 30px;
    height: 30px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 2px 2px;
    border-radius: 4px;
}

.reps-back-arrow:hover {
    background-color: rgba(0, 0, 0, 0.1);
}

.reps-dictionary-select-container {
    flex: 1;
}

.reps-dictionary-select {
    width: 100%;
    padding: 5px;
    border: 1px solid #dee2e6;
    border-radius: 4px;
}

.reps-default-checkbox-container {
    padding: 10px;
    background-color: #f8f9fa;
    border-bottom: 1px solid #dee2e6;
    display: flex;
    align-items: center;
    gap: 8px;
}

.reps-default-indicator {
    font-size: 12px;
    color: #666;
    margin-left: 8px;
}

.reps-iframe-container {
    flex: 1;
    overflow: hidden;
}

.reps-dictionary-frame-mobile {
    width: 100%;
    height: 100%;
    border: none;
}

/* Style dla wersji mobilnej */
@media (max-width: 768px) {
    .reps-dictionary-container {
        position: static;
        width: 90%;
        height: 0;
        margin: 20px auto; 
        margin-right: 40px;
        margin-left: 30px;
        transition: height 0.3s ease-in-out;
        overflow: hidden;
        box-shadow: none;
    }

    .reps-dictionary-container.show {
        height: 110vh;
        max-height: none;
    }
}

/* Dodajemy specjalne style dla orientacji portrait */
@media (max-width: 768px) and (orientation: landscape) {
    .reps-dictionary-container.show {
        height: 300vh; /* Zwiększona wysokość dla orientacji portrait */
        max-height: none;
    }
}

/* Style dla trybu ciemnego */
body.dark-mode .reps-dictionary-header,
body.dark-mode .reps-default-checkbox-container {
    background-color: #2d2d2d;
    border-color: #404040;
}

body.dark-mode .reps-dictionary-select {
    background-color: #333;
    color: #e0e0e0;
    border-color: #404040;
}

body.dark-mode .reps-back-arrow {
    color: #e0e0e0;
}

body.dark-mode .reps-default-indicator {
    color: #aaa;
}

body.dark-mode .reps-dictionary-container {
    background-color: #2d2d2d;
    border-color: #404040;
}

/* Zaktualizuj style dla okienka Translation w trybie ciemnym */
body.dark-mode .translation {
    background-color: #2d2d2d; /* Taki sam kolor tła jak inne pola */
    border-color: #2d2d2d;
    color: #e0e0e0;
}

body.dark-mode .card-content {
    background-color: #2d2d2d;
    border-color: #404040;
}

body.dark-mode .card-content pre {
    background-color: #2d2d2d;
    color: #e0e0e0;
    border-color: #404040;
}

/* Dodaj style dla scrolla w formularzu ustawień */
.settings-form {
    max-height: 80vh; /* Maksymalna wysokość to 80% wysokości okna */
    overflow-y: auto; /* Dodaj scroll pionowy gdy zawartość przekracza wysokość */
    scrollbar-width: thin; /* Cienki scrollbar dla Firefox */
    scrollbar-color: #888 #f1f1f1; /* Kolor scrollbara dla Firefox */
}

/* Style dla scrollbara w Chrome/Safari/Edge */
.settings-form::-webkit-scrollbar {
    width: 8px;
}

.settings-form::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

.settings-form::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 4px;
}

.settings-form::-webkit-scrollbar-thumb:hover {
    background: #555;
}

/* Style dla trybu ciemnego */
body.dark-mode .settings-form::-webkit-scrollbar-track {
    background: #2d2d2d;
}

body.dark-mode .settings-form::-webkit-scrollbar-thumb {
    background: #666;
}

body.dark-mode .settings-form::-webkit-scrollbar-thumb:hover {
    background: #888;
}

body.dark-mode .settings-form {
    scrollbar-color: #666 #2d2d2d;
}

/* Style dla przycisku Edit w sekcji Review */
.review-edit-button {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: transparent; /* Przezroczyste tło */
    color: #777777; /* Kolor tekstu taki jak poprzedni kolor tła */
    border: none;
    border-radius: 4px;
    padding: 5px 15px;
    cursor: pointer;
    font-size: 14px;
    transition: color 0.3s, background-color 0.3s;
}

.review-edit-button:hover {
    background-color: rgba(0, 0, 0, 0.1); /* Lekko przyciemnione tło przy najechaniu */
    color: #5f5f5f;
}

/* Dla trybu ciemnego */
body.dark-mode .review-edit-button {
    background-color: transparent;
    color: #e0e0e0;
}

body.dark-mode .review-edit-button:hover {
    background-color: rgba(255, 255, 255, 0.1); /* Lekko rozjaśnione tło przy najechaniu w trybie ciemnym */
    color: #ffffff;
}

/* Dodaj pozycjonowanie względne dla kontenera karty */
.card-content {
    position: relative;
}

/* Style dla przycisku Buy Me a Coffee */
.bmc-button {
    margin-left: 10px !important;
    height: 28px !important; /* Taka sama wysokość jak przycisk My Playlists */
    line-height: 28px !important;
    min-width: auto !important;
    display: inline-flex !important;
    align-items: center !important;
}

/* Dostosowanie dla małych ekranów */
@media (max-width: 768px) {
    .bmc-button {
        margin-left: 0 !important;
        margin-top: 5px !important;
        width: 100% !important;
        height: 40px !important; /* Taka sama wysokość jak inne przyciski na mobile */
        line-height: 40px !important;
    }
}



.show-examples-button small {
    font-size: 14px;
    line-height: 24px;
    display: flex;
    align-items: center;
    height: 100%;
    margin-top: -1px;
}

.show-examples-button:hover {
    background-color: rgba(0, 0, 0, 0.1) !important;
    color: #5f5f5f !important;
}

/* Dla trybu ciemnego */
body.dark-mode .show-examples-button {
    background-color: transparent !important;
    color: #e0e0e0 !important;
}

body.dark-mode .show-examples-button:hover {
    background-color: rgba(255, 255, 255, 0.1) !important;
    color: #ffffff !important;
}

/* Dodajemy style dla textarea w formularzu edycji */
#editFlashcardForm textarea {
    margin-bottom: 5px; /* Zmniejszamy margines dolny dla wszystkich textarea */
}

#editFlashcardForm #editContext {
    margin-bottom: 2px; /* Zmniejszamy z 8px na 2px */
    position: relative;  /* Dodajemy pozycjonowanie względne */
}

#editFlashcardForm #editTranslation {
    margin-top: 0; /* Usuwamy górny margines */
}

.examples-button-container {
    position: relative;  /* Dodajemy pozycjonowanie względne dla kontenera */
    margin-bottom: 5px;
}

.show-examples-button {
    width: auto;
    padding: 2px 8px;
    margin: 0;
    background-color: transparent !important;
    color: #777777 !important;
    border: none !important;
    border-radius: 4px;
    cursor: pointer;
    transition: color 0.3s, background-color 0.3s;
    text-decoration: none;
    outline: none !important;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    height: 24px;
    white-space: nowrap;
    position: absolute;
    top: -16px;
    left: 50%;                    /* Ustawiamy na środek */
    transform: translateX(-50%);  /* Przesuwamy o połowę szerokości w lewo */
}

/* Usuwamy position: relative z #editContext, bo teraz jest w kontenerze */
#editFlashcardForm #editContext {
    margin-bottom: 2px;
    width: 100%;
}

/* Style dla formularza edycji */
#editFlashcardForm {
    display: flex;
    flex-direction: column;
    gap: 10px;  /* Zwiększamy gap dla lepszej czytelności */
}

#editFlashcardForm textarea,
#editFlashcardForm input[type="text"] {
    margin: 0;
    padding: 10px;
    width: 100%;
    min-height: 20px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

.examples-button-container {
    position: relative;
    margin: 0;
}

#editFlashcardForm .button-group {
    margin-top: 10px;
}

/* Usuń gap z formularza */
#editFlashcardForm {
    display: flex;
    flex-direction: column;
}

/* Dodaj indywidualne marginesy */
#editFlashcardForm #editWord {
    margin-bottom: 12px;
}

#editFlashcardForm #editContext {
    margin-bottom: 8px;
}

#editFlashcardForm #editTranslation {
    margin-bottom: 12px;
}

#editFlashcardForm input[type="text"] {
    margin-bottom: 12px;
}

/* Zachowaj podstawowe style dla pól */
#editFlashcardForm textarea,
#editFlashcardForm input[type="text"] {
    padding: 10px;
    width: 100%;
    min-height: 20px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

/* Ostatni input nie potrzebuje dolnego marginesu */
#editFlashcardForm input[type="text"]:last-of-type {
    margin-bottom: 0;
}

/* Grupa przycisków na końcu formularza */
#editFlashcardForm .button-group {
    margin-top: 10px;
}

/* Dodaj margines dla pola audio URL używając poprawnego ID */
#editFlashcardForm #editAudioUrl {
    margin-bottom: 10px;
}

.examples-text {
    font-size: 12px;
    margin: 0;
    padding: 0;
    color: #777777;
    height: 14px;           /* Dodajemy stałą wysokość */
    line-height: 16px;      /* Wyrównujemy line-height do wysokości */
    overflow: hidden;       /* Ukrywamy tekst, który nie mieści się w polu */
}

/* Style dla textarea w formularzu dodawania fiszek */
#addForm textarea {
    min-height: 10px;  /* Zwiększamy minimalną wysokość */
    resize: vertical;  /* Pozwalamy na ręczne rozciąganie w pionie */
    padding: 10px;
    width: 100%;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

/* Możemy też ustawić różne wysokości dla różnych pól */
#addForm #word {
    min-height: 16px;  /* Mniejsza wysokość dla pola word */
}

#addForm #context {
    min-height: 16px;  /* Większa wysokość dla pola context */
}

#addForm #translation {
    min-height: 16px;  /* Standardowa wysokość dla pola translation */
}

/* Style dla textarea w formularzu ustawień */
#exampleButtonPrompt {
    min-height: 120px;  /* Minimalna wysokość */
    height: auto;      /* Wysokość automatyczna */
    resize: vertical;  /* Pozwalamy na ręczne rozciąganie w pionie */
    padding: 8px;
    width: 100%;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    line-height: 1.4;
    font-family: inherit;
    margin-bottom: 4px;
}

/* Style dla opisu pod textarea */
#exampleButtonPrompt + small {
    color: #667;
    font-size: 12px;
    display: block;
    margin-top: 4px;
}




                        
                    </style>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Playlists</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://www.youtube.com/iframe_api" defer></script>
    <script src="script.js"></script>
    <!-- Dodajemy linki do favicon -->
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">


    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-translate="repetitions">Repetitions</title>
    <link rel="stylesheet" href="reps.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="stats.js" defer></script>
    <script src="translations.js"></script>
    <script src="algorithms.js"></script>
    <script src="synchronization.js"></script>
    <script src="reps.js" defer></script>
    <style>
        /* Istniejące style... */

        #dictionary-frame {
            position: fixed;
            top: 200px;
            right: -33.33%;
            width: 33.33%;
            height: calc(100% - 200px);
            border: none;
            transition: right 0.3s ease-in-out;
            z-index: 1000;
        }

        #dictionary-frame.show {
            right: 0;
        }

        #toggle-dictionary {
            margin-right: 10px;
            height: auto;
            padding: 5px 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 100px;
            background-color: #007bff; /* Zmieniono na niebieski kolor */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #toggle-dictionary:hover {
            background-color: #0056b3; /* Ciemniejszy odcień niebieskiego przy najechaniu myszką */
        }

        @media (max-width: 768px) {
            #dictionary-frame {
                position: static;
                top: auto;
                right: auto;
                width: 100%;
                height: 0;
                margin-top: 20px;
                transition: height 0.3s ease-in-out;
                overflow: hidden;
            }

            #dictionary-frame.show {
                height: 500px;
                border: 1px solid #ddd;
            }

            .container {
                padding-bottom: 20px;
            }
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }
        .header-left, .header-right {
            display: flex;
            align-items: center;
        }
        .nav-button.center-button {
            margin-top: 0;
            height: auto;
            padding: 5px 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 120px; /* Dodajemy minimalną szerokość */
        }
        #toggle-dictionary {
            margin-right: 10px;
            height: auto;
            padding: 5px 10px;
            display: inline-block;
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                align-items: stretch;
            }

            .header-left, .header-right {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: flex-start; /* Zmieniono z space-between na flex-start */
                margin-bottom: 10px;
            }

            .nav-button.center-button {
                margin-left: 100px; /* Zmieniono z 110px na 115px */
            }

            #toggle-dictionary {
                margin-right: 10px;
            }

            .language-select {
                flex: 1;
                margin-left: auto; /* Przesuwa wybór języka na prawą stronę */
            }

            #language-select {
                width: auto; /* Zmieniono z width: 100% na width: auto */
            }

            nav {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: space-between;
            }

            nav button {
                flex: 0 1 auto;
                margin: 5px 0;
            }

            #toggle-dictionary {
                width: 100%;
                height: 40px; /* Taka sama wysokość jak inne przyciski */
                margin: 5px 0;
                padding: 0 10px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            nav button, #toggle-dictionary {
                width: 100%;
                height: 40px; /* Ustawiamy stałą wysokość dla wszystkich przycisków */
                margin: 5px 0;
                padding: 0 10px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 16px; /* Ustawiamy jednakowy rozmiar czcionki */
            }

            #toggle-dictionary {
                margin-right: 0;
            }
        }
    </style>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">

</head>
<body>
    <div id="indexView" class="view active">

    <div class="main-container">
        <div class="left-column">
            <div class="header-container">
                <h1 class="main-title">My Playlists</h1>
                <div class="buttons-container">
                    <a href="reps.html" class="quiz-button">Repetitions</a>
                </div>
            </div>
            <div id="playlist-container" class="playlist-container"></div>
            <div class="player-container">
                <div id="player"></div>
                <div id="watched-overlay" class="watched-overlay">
                    ✔ Obejrzano
                </div>
                <div class="player-resizer"></div>
            </div>
            <button id="autoplay-btn" class="autoplay-button" onclick="toggleAutoplay()">Auto-play: OFF</button>
            <!-- Ukrywamy przycisk "Wyczyść obejrzane filmy" -->
            <button class="clear-button" onclick="clearWatchedVideos()" style="display: none;">Wyczyść obejrzane filmy</button>
            <!-- Ukrywamy przycisk "Przytnij video" -->
            <button class="trim-button" onclick="setTrimTime()" style="display: none;">Przytnij video</button>
            <button class="word-list-button" onclick="toggleWordList()">Word List</button>
            <button class="settings-button" onclick="openSettings()">⋮</button>
            <button id="index-dark-mode" class="index-dark-mode-button" onclick="toggleIndexDarkMode()">
                <span class="dark-mode-icon">☽</span>
            </button>
            <p style="display: none;">Całkowita liczba filmów w playliście: <span id="total-videos"></span></p>
            <h2 class="count-normal">List of watched videos (<span id="watched-count">0</span>/<span id="total-videos-2">0</span>)</h2>
            <ul id="video-list"></ul>
            <button id="toggle-add-to-watched" class="hidden-button" onclick="toggleAddToWatchedOnStart()">Create a note on beginning of movie</button>
        </div>
        <div class="column-divider"></div>
        <div class="right-column">
            <div class="dictionary-select-container">
                <h3>Select Dictionary</h3>
                <div class="dictionary-select-row">
                    <select id="dictionary-select" onchange="changeDictionary()">
                        <option value="https://www.onelook.com/">onelook.com</option>
                        <option value="https://www.you.com/">you.com (ai)</option>
                        <option value="https://www.diki.pl/">diki.pl</option>
                        <option value="https://dict.com/angielsko-polski">dict.com</option>
                        <option value="https://ling.pl/">ling.pl</option>
                
                        <option value="add_new">Add new</option>
                        <option value="remove_dictionary">Remove dictionary</option>
                    </select>
                    <label for="default-dictionary-checkbox" title="Set as default dictionary">
                        <input type="checkbox" id="default-dictionary-checkbox" onchange="setDefaultDictionary()">
                    </label>
                </div>
            </div>
            <div id="separator"></div>
            <div class="iframe-container">
                <div class="tabs-container">
                    <div id="tabs"></div>
                    <button id="add-tab" onclick="addNewTab()">+</button>
                </div>
                <div id="iframe-container"></div>
                <div id="iframe-resizer"></div>
            </div>
            
            <!-- Kontener dla przycisku Buy Me a Coffee -->
            <div class="bmc-button-container">
                <script 
                    type="text/javascript" 
                    src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" 
                    data-name="bmc-button" 
                    data-slug="IuodipUQmJ" 
                    data-color="#007BFF"
                    data-emoji="🚗" 
                    data-font="Cookie" 
                    data-text="Get that App" 
                    data-outline-color="#000000" 
                    data-font-color="#ffffff" 
                    data-coffee-color="#FFDD00" >
                </script>
            </div>
        </div>
    </div>
    <div id="word-list-container" style="display: none;">
        <div id="word-list-header">
            <h2>List of all words</h2>
            <div>
                <button id="export-word-list" onclick="exportWordList()">Export to file</button>
                <button id="clear-watched-videos" onclick="clearWatchedVideos()">Clear all data</button>
                <button id="close-word-list" onclick="toggleWordList()">Close</button>
            </div>
        </div>
        <div id="word-list-content">
            <table id="word-list-table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Word/Phrase</th>
                        <th>Context</th>
                        <th>Translation</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    <div class="note-form" style="display: none;">
        <div class="word-translation-pairs"></div>
        <button onclick="addWordTranslationPair('${videoId}')">+ Add word/phrase</button>
        <button onclick="saveNote('${videoId}')">Save note</button>
    </div>

    </div>
    <div id="repsView" class="view">

    <header>
        <div class="header-content">
            <div class="header-left">
                <h1 class="main-title" data-translate="repetitions">Repetitions</h1>
                <a href="index.html" class="nav-button center-button" data-translate="myPlaylists">My Playlists</a>
            </div>
            <div class="header-right">
                <div class="buttons-container">
                    <button id="save-button" class="sync-button" data-tooltip="saveTooltip">
                        <span class="sync-icon">↓</span>
                        <span data-translate="save">Save</span>
                    </button>
                    <button id="sync-button" class="sync-button" data-tooltip="syncButtonTooltip">
                        <span class="sync-icon">↻</span>
                        <span data-translate="sync">Sync</span>
                    </button>
                    <button id="dark-mode-toggle" class="dark-mode-button" data-tooltip="darkModeTooltip">
                        <span class="dark-mode-icon">☽</span>
                    </button>
                    <button id="main-settings" class="nav-button main-settings-button" data-tooltip="Settings">⋮</button>
                    <div id="save-link" class="save-link"></div>
                </div>
                <div class="language-select">
                    <select id="language-select" onchange="changeLanguage()">
                        <option value="en">English</option>
                        <option value="pl">Polish</option>
                    </select>
                </div>
            </div>
        </div>
    </header>
    <main>
        <nav>
            <button onclick="showSection('review'); startReview();" class="nav-button" data-translate="review">Review</button>
            <button onclick="showSection('view')" class="nav-button" data-translate="browseFlashcards">Browse Flashcards</button>
            <button onclick="showSection('add')" class="nav-button" data-translate="addFlashcard">Add Flashcard</button>
            <button onclick="showSection('stats')" class="nav-button" data-translate="statistics">Statistics</button>
            <button onclick="exportFlashcards()" class="nav-button" data-translate="exportToFile">Export to File</button>
            <button onclick="importFlashcards()" class="nav-button" data-translate="importFromFile">Import from File</button>
            <button id="toggle-dictionary" class="nav-button" data-translate="dictionary">Dictionary</button>
        </nav>
  
        <div class="container">
            <section id="add" class="section hidden">
                <h2 data-translate="addNewFlashcard">Add New Flashcard</h2>
                <form id="addForm">
                    <textarea id="word" data-placeholder="wordPhrase" required></textarea>
                    <p id="examples-output" class="examples-text"></p>
                    <textarea id="context" data-placeholder="contextExample"></textarea>
                    <div class="examples-button-container">
                        <button type="button" class="show-examples-button" onclick="showExamples(document.getElementById('word').value)">
                            <small data-translate="showExamples">Show examples</small>
                        </button>
                    </div>
                    <p id="examples-output" class="examples-text"></p>
                    <textarea id="translation" data-placeholder="translation" required></textarea>
                    <p id="examples-output" class="examples-text"></p>
                    <input type="text" id="mediaUrl" data-placeholder="imageLink">
                    <input type="text" id="audioUrl" data-placeholder="audioLink">
                    <button type="submit" class="submit-button" data-translate="addFlashcardButton">Add Flashcard</button>
                </form>
            </section>
  
            <section id="view" class="section">
                <h2 data-translate="yourFlashcards">Your Flashcards</h2>
                <table id="flashcardTable">
                    <thead>
                        <tr>
                            <th data-translate="no">No.</th>
                            <th data-translate="wordPhrase">Word / Phrase</th>
                            <th data-translate="contextExample">Context / Example</th>
                            <th data-translate="translation">Translation</th>
                            <th data-translate="known">Known</th>
                            <th data-translate="media">Media</th>
                            <th data-translate="audio">Audio</th>
                            <th data-translate="actions">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Table rows will be generated dynamically -->
                    </tbody>
                </table>
            </section>
  
            <section id="review" class="section hidden">
                <div class="review-header">
                    <h2 data-translate="review">Review</h2>
                    <button onclick="toggleReviewInfo()" class="info-button" data-translate="info">Info</button>
                </div>
                <div id="reviewCard"></div>
                <div id="review-info" class="info-box" style="display: none;">
                    <!-- Content will be dynamically generated in JavaScript -->
                </div>
            </section>
  
            <section id="stats" class="section hidden">
                <div class="section-header">
                    <h2 data-translate="statistics">Statistics</h2>
                    <button onclick="toggleStatsInfo()" class="info-button" data-translate="info">Info</button>
                </div>
                <div class="stats">
                    <p><span data-translate="totalFlashcards">Total number of flashcards:</span> <span id="totalFlashcards">0</span></p>
                    <p><span data-translate="numberOfReviews">Number of reviews:</span> <span id="totalReviews">0</span></p>
                    <p data-translate="currentKnowledgeState">Current knowledge state of all flashcards</p>
                    <p class="info-tooltip" data-tooltip="masteredTooltip">
                        <span data-translate="masteredLast7Days">Number mastered in the last 7 days:</span> <span id="masteredLast7Days">0</span>
                    </p>
                </div>
                <canvas id="learningProgressChart" width="300" height="200"></canvas>
                <canvas id="leitnerBoxesChart" width="300" height="200"></canvas>
                <div id="stats-info" class="info-box" style="display: none;">
                    <!-- Content for stats info-box -->
                </div>
            </section>
        </div>
    </main>
    <iframe id="dictionary-frame" frameborder="0" hidden></iframe>

    <script>
        // Kod JavaScript do obsługi słownika
        const dictionaryFrame = document.getElementById('dictionary-frame');
        const toggleDictionaryBtn = document.getElementById('toggle-dictionary');

        toggleDictionaryBtn.addEventListener('click', () => {
            dictionaryFrame.classList.toggle('show');
        });

        // Dodaj obsługę wiadomości z iframe'a słownika
        window.addEventListener('message', (event) => {
            if (event.data === 'hideDictionary') {
                dictionaryFrame.classList.remove('show');
            }
        });
    </script>
    <!-- Dodaj przed zamknięciem body -->
  

    </div>

    <script>
        function showView(viewId) {
            document.querySelectorAll(".view").forEach(view => {
                view.classList.remove("active");
            });
            document.getElementById(viewId).classList.add("active");
            // Zmiana koloru tła w zależności od widoku
           // document.body.style.backgroundColor = viewId === "indexView" ? "white" : "";
        }

        document.addEventListener("DOMContentLoaded", function() {
          //  document.body.style.backgroundColor = "white";
            document.querySelectorAll('a[href="reps.html"]').forEach(link => {
                link.onclick = (e) => {
                    e.preventDefault();
                    localStorage.setItem("currentView", "repsView");
                    location.reload();
                };
            });

            document.querySelectorAll('a[href="index.html"]').forEach(link => {
                link.onclick = (e) => {
                    e.preventDefault();
                    localStorage.setItem("currentView", "indexView");
                    location.reload();
                };
            });

            // Przywróć ostatni widok po odświeżeniu
            const lastView = localStorage.getItem("currentView");
            if (lastView) {
                showView(lastView);
            }
        });
    </script>

<script>let isIndexDarkMode = false;
var isPortrait = window.innerHeight > window.innerWidth ;
var isLandscape = window.innerWidth  > window.innerHeight;

// Funkcja do przełączania trybu ciemnego
function toggleIndexDarkMode() {
    isIndexDarkMode = !isIndexDarkMode;
    document.body.classList.toggle('index-dark-mode', isIndexDarkMode);
   // localStorage.setItem('indexDarkMode', isIndexDarkMode);
    
    // Zmień ikonę
    const darkModeIcon = document.querySelector('#index-dark-mode .dark-mode-icon');
    if (darkModeIcon) {
        darkModeIcon.textContent = isIndexDarkMode ? '☼' : '☽';
    }
}

// Inicjalizacja trybu ciemnego przy ładowaniu strony
document.addEventListener('DOMContentLoaded', function() {
    if (isIndexDarkMode) {
        document.body.classList.add('index-dark-mode');
        const darkModeIcon = document.querySelector('#index-dark-mode .dark-mode-icon');
        if (darkModeIcon) {
            darkModeIcon.textContent = '☼';
        }
    }
});

var player;
var watchedVideos = {}; // Obiekt przechowujący obejrzane filmy dla każdej playlisty
var currentVideoId = null;
var currentVideoTitle = null;
var isAutoplayEnabled = false;
var currentPlaylistId = '';

var playlistVideoIds = [];
var videoIdToIndexMap = {};
var listItemVideoId = null;

var playlists = [
    { id: 'PLcetZ6gSk96-FECmH9l7Vlx5VDigvgZpt', name: '6 Minute English' },
    { id: 'PLcetZ6gSk96_Fprtuj6gKN9upPjaDrARH', name: 'English In A Minute' },
    { id: 'PLcetZ6gSk96_sototkO7HFkGA8zL8H0lq', name: 'The English We Speak' },
    { id: 'PLcetZ6gSk96--2ELXoJeyafP6wg4n53uh', name: 'Phrasal Verbs' },
    { id: 'PLcetZ6gSk96_zHuVg6Ecy2F7j4Aq4valQ', name: '6 Minute Grammar' } // Dodana nowa playlista
];

var trimTimes = {};

// Dodaj tę linię na początku skryptu, wraz z innymi globalnymi zmiennymi
var previousState;

// Dodaj tę funkcję na początku skryptu
function initializeDefaultTrimTimes() {
    playlists.forEach(function(playlist) {
        if (!playlist.custom && !trimTimes.hasOwnProperty(playlist.id)) {
            trimTimes[playlist.id] = 366; // 6:06 w sekundach
        }
    });
    saveTrimTimesToLocalStorage();
}

// Zmień inicjalizację zmiennej globalnej
var addToWatchedOnStart = true;

// Dodaj tę funkcję na początku pliku, wraz z innymi zmiennymi globalnymi
function showColumnDividerTooltip() {
    // Nie pokazuj tooltipa na małych ekranach
    if (window.innerWidth  <= 915) {
        return;
    }

    if (localStorage.getItem('columnDividerTooltipShown') !== 'true') {
        const tooltip = document.createElement('div');
        tooltip.className = 'column-divider-tooltip';
        tooltip.innerHTML = `
            Change the width of the player / dictionary using the column handle
            <button class="tooltip-close">×</button>
        `;
        
        const columnDivider = document.querySelector('.column-divider');
        columnDivider.appendChild(tooltip);
        
        // Dodaj klasę highlighted do dividera
        columnDivider.classList.add('highlighted');
        
        // Obsługa zamknięcia tooltipa
        tooltip.querySelector('.tooltip-close').addEventListener('click', () => {
            tooltip.remove();
            columnDivider.classList.remove('highlighted');
            localStorage.setItem('columnDividerTooltipShown', 'true');
        });
        
        // Automatyczne zamknięcie po 40 sekundach
        setTimeout(() => {
            if (tooltip.parentElement) {
                tooltip.remove();
                columnDivider.classList.remove('highlighted');
                localStorage.setItem('columnDividerTooltipShown', 'true');
            }
        }, 40000);

        // Dodaj nasłuchiwanie na zmianę rozmiaru okna
        const resizeHandler = () => {
            if (window.innerWidth  <= 520 && tooltip.parentElement) {
                tooltip.remove();
                columnDivider.classList.remove('highlighted');
                localStorage.setItem('columnDividerTooltipShown', 'true');
            }
        };

        window.addEventListener('resize', resizeHandler);
    }
}

function createPlaylistButtons() {
    var container = document.getElementById('playlist-container');
    container.innerHTML = '';

    playlists.forEach(function(playlist) {
        var buttonContainer = document.createElement('div');
        buttonContainer.className = 'playlist-button-container';

        var button = document.createElement('button');
        button.textContent = playlist.name;
        button.className = 'playlist-button';
        button.onclick = function() { loadPlaylist(playlist.id); };
        buttonContainer.appendChild(button);

        if (playlist.custom) {
            var removeButton = document.createElement('button');
            removeButton.textContent = 'X';
            removeButton.className = 'remove-playlist-button';
            removeButton.onclick = function(e) {
                e.stopPropagation();
                removePlaylist(playlist.id);
            };
            buttonContainer.appendChild(removeButton);
        }

        container.appendChild(buttonContainer);
    });

    // Dodaj przycisk "+" do pokazywania/ukrywania inputa
    var toggleButton = document.createElement('button');
    toggleButton.textContent = '+';
    toggleButton.className = 'toggle-input-button';
    toggleButton.onclick = toggleCustomPlaylistInput;
    container.appendChild(toggleButton);

    // Dodaj input i przycisk do dodawania nowej playlisty
    var customContainer = document.createElement('div');
    customContainer.className = 'custom-playlist-container';
    customContainer.style.display = 'none';

    var input = document.createElement('input');
    input.type = 'text';
    input.id = 'custom-playlist-link';
    input.placeholder = 'Paste the link to a YouTube playlist or video.';
    customContainer.appendChild(input);

    var addButton = document.createElement('button');
    addButton.textContent = 'Add';
    addButton.onclick = addCustomPlaylistOrVideo;
    customContainer.appendChild(addButton);

    container.appendChild(customContainer);
    addNoteIconHoverListeners();
}

function loadPlaylist(playlistId) {
    currentPlaylistId = playlistId;
    var playlist = playlists.find(p => p.id === playlistId);
    
    if (player) {
        player.destroy();
    }
    
    var playerContainer = document.getElementById('player');
    playerContainer.innerHTML = ''; // Wyczyść kontener przed utworzeniem nowego odtwarzacza
    
    if (playlist && playlist.singleVideo) {
        loadSingleVideo(playlistId, playlist.singleVideo);
    } else {
        player = new YT.Player('player', {
            height: '360',
            width: '640',
            playerVars: {
                'listType': 'playlist',
                'list': playlistId,
                'autoplay': 0,
                'controls': 1,
                'rel': 0,
                'modestbranding': 1,
                'iv_load_policy': 3,
                'cc_load_policy': 1,
                'cc_lang_pref': 'en'
            },
            events: {
                'onReady': onPlayerReady,
                'onStateChange': onPlayerStateChange
            }
        });
    }
    
    updateActivePlaylistButton(playlistId);
    loadWatchedVideosFromLocalStorage();
    updateWatchedVideosList();
    updateWatchedCount();
    
    setTimeout(autosizePlayer, 100);
}

function onPlayerReady(event) {
    console.log("Player gotowy do odtwarzania!");
    updatePlaylistData();
    loadWatchedVideosFromLocalStorage();
    setTimeout(autosizePlayer, 100); // Dodaj małe opóźnienie
    setInterval(function() {
        updatePlaylistData();
    }, 120000);
}

function onPlayerStateChange(event) {
    console.log("Stan odtwarzacza:", event.data);

    if (event.data === YT.PlayerState.PLAYING) {
        var videoData = player.getVideoData();
        currentVideoId = videoData.video_id;
        currentVideoTitle = videoData.title;
        console.log("Aktualny film:", currentVideoTitle);

        // Dodaj film do listy obejrzanych na początku odtwarzania tylko jeśli flaga jest true
        if (addToWatchedOnStart) {
            markVideoAsWatched(currentVideoId, currentVideoTitle);
        }

        // Sprawdzamy czas przycinania przy każdym odtworzeniu
        checkTrimTime();
        
        setTimeout(autosizePlayer, 100);
    }

    if (event.data === YT.PlayerState.UNSTARTED && previousState === YT.PlayerState.PLAYING) {
        console.log("Film zakończył odtwarzanie.");

        // Dodaj film do listy obejrzanych na końcu odtwarzania, jeśli flaga jest false
        if (!addToWatchedOnStart) {
            markVideoAsWatched(currentVideoId, currentVideoTitle);
        }

        if (!isAutoplayEnabled) {
            console.log("Auto-play wyłączony, zatrzymuję odtwarzanie.");
            player.stopVideo();
        }
    }

    previousState = event.data;
}

function checkTrimTime() {
    if (trimTimes[currentPlaylistId] !== undefined) {
        var checkInterval = setInterval(function() {
            if (player && player.getCurrentTime) {
                var currentTime = player.getCurrentTime();
                var duration = player.getDuration();
                if (trimTimes[currentPlaylistId] > 0 && currentTime >= trimTimes[currentPlaylistId] && currentTime < duration - 3) {
                    player.seekTo(duration - 3, true);
                    clearInterval(checkInterval);
                } else if (currentTime >= duration - 1) {
                    // Zatrzymaj sprawdzanie, gdy film jest blisko końca
                    clearInterval(checkInterval);
                }
            }
        }, 1000); // Sprawdzaj co sekundę
    }
}

function updatePlaylistData() {
    var newPlaylistVideoIds = player.getPlaylist();

    if (JSON.stringify(playlistVideoIds) !== JSON.stringify(newPlaylistVideoIds)) {
        playlistVideoIds = newPlaylistVideoIds;
        console.log("Playlista została zaktualizowana.");
        videoIdToIndexMap = {};
        playlistVideoIds.forEach(function(videoId, index) {
            videoIdToIndexMap[videoId] = index;
        });
        document.getElementById('total-videos').textContent = playlistVideoIds.length;
        document.getElementById('total-videos-2').textContent = playlistVideoIds.length;
        updateWatchedVideosList();
        updateWatchedCount();
    }
}

function updateWatchedVideosList() {
    var videoListElement = document.getElementById('video-list');
    videoListElement.innerHTML = '';

    if (!watchedVideos[currentPlaylistId]) {
        watchedVideos[currentPlaylistId] = [];
    }

    // Tworzymy kopię tablicy i odwracamy ją
    const reversedVideos = [...watchedVideos[currentPlaylistId]].reverse();

    reversedVideos.forEach(function(video, index) {
        var videoId = video.id;
        var title = video.title.replace(/[⏲️⏰✈️]/g, '').trim();
        var videoIndex = videoIdToIndexMap[videoId];
        var videoNumber = videoIndex !== undefined ? videoIndex + 1 : 1;

        var listItem = document.createElement('li');
        listItem.id = videoId;

        listItem.innerHTML = `
            <a onclick="playPlaylistFromIndex('${videoId}')">${videoNumber}. ${title}</a>
            <span class="note-icon" onclick="toggleNoteForm('${videoId}')">${video.notes && video.notes.length > 0 ? '📝' : '➕'}</span>
            <div class="note-form" style="display: none;">
                <div class="word-translation-pairs"></div>
                <button onclick="addWordTranslationPair('${videoId}')">+ Add word/phrase</button>
                <button onclick="saveNote2('${videoId}')">Save note</button>
            </div>
        `;
        videoListElement.appendChild(listItem);

        if (video.notes && video.notes.length > 0) {
            video.notes.forEach(note => {
                addWordTranslationPair(videoId, note.word, note.context, note.translation);
            });
        }
    });

    adjustAllTextareas();
}

function markVideoAsWatched(videoId, title) {
    console.log("Oznaczanie filmu jako obejrzany:", title);
    console.log("Stan watchedVideos przed oznaczeniem:", JSON.parse(JSON.stringify(watchedVideos)));
    if (!watchedVideos[currentPlaylistId]) {
        watchedVideos[currentPlaylistId] = [];
    }
    // Sprawdź, czy film już istnieje w liście obejrzanych
    const existingVideo = watchedVideos[currentPlaylistId].find(video => video.id === videoId);
    if (!existingVideo) {
        // Jeśli to pojedynczy film, użyj nazwy playlisty jako tytułu
        var playlist = playlists.find(p => p.id === currentPlaylistId);
        var videoTitle = playlist && playlist.singleVideo ? playlist.name : title;
        watchedVideos[currentPlaylistId].push({ id: videoId, title: videoTitle });
        console.log("Stan watchedVideos po oznaczeniu:", JSON.parse(JSON.stringify(watchedVideos)));
        updateWatchedVideosList();
        saveWatchedVideosToLocalStorage();
        updateWatchedCount();
    } else {
        console.log("Film już był oznaczony jako obejrzany");
    }
}

function playPlaylistFromIndex(videoId) {
    var videoIndex = videoIdToIndexMap[videoId];
    if (videoIndex !== undefined) {
        player.loadPlaylist({
            'list': currentPlaylistId,
            'index': videoIndex,
            'startSeconds': 0,
            'suggestedQuality': 'default'
        });
        jumpPerformed = false;
        previousState = null;
    } else {
        console.log("Nie znaleziono identyfikatora wideo w playliście.");
    }
}

function toggleNoteForm(videoId) {
    var listItem = document.getElementById(videoId);
    var noteForm = listItem.querySelector('.note-form');
    var noteIcon = listItem.querySelector('.note-icon');
    var pairsContainer = listItem.querySelector('.word-translation-pairs');
    
    if (noteForm.style.display === 'none') {
        noteForm.style.display = 'block';
        noteIcon.textContent = '➖'; // Zmieniamy ikonę na minus
        document.querySelector('.dictionary-select-container').classList.add('sticky');
        if (pairsContainer.children.length === 0) {
            addWordTranslationPair(videoId);
        } else {
            adjustAllTextareas();
        }
        
        // Przewiń do notatki z animacją
        setTimeout(() => {
            const noteFormRect = noteForm.getBoundingClientRect();
            const offset = noteFormRect.top + window.pageYOffset - (window.innerHeight / 2) + (noteFormRect.height / 2);
            
            // Użyj animacji do przewijania
            if (window.innerWidth  > 915) { //nie mobile, wacz przewijanie
            smoothScrollTo(offset, 1000); // 1000ms (1 sekunda) na animację
            }
            // Dostosuj pozycję playera YouTube
            adjustYouTubePlayerPosition(videoId, true);
        }, 100); // Dajemy trochę czasu na renderowanie formularza
    } else {
        saveNote(videoId);
        noteForm.style.display = 'none';
        noteIcon.textContent = noteIcon.textContent === '➖' ? '➕' : '📝'; // Przywracamy oryginalną ikonę
        document.querySelector('.dictionary-select-container').classList.remove('sticky');
        // Przywróć oryginalną pozycję playera YouTube
        resetYouTubePlayerPosition();
    }
    setTimeout(() => adjustIframeSize(videoId), 0);
}

function adjustYouTubePlayerPosition(videoId, isResizing = false) {
    var playerContainer = document.querySelector('.player-container');
    var activeNoteForm = document.querySelector('.note-form[style="display: block;"]');
    var listItem = document.getElementById(videoId);
    var leftColumn = document.querySelector('.left-column');
    
    if (activeNoteForm && listItem) {
        var noteFormRect = activeNoteForm.getBoundingClientRect();
        var leftColumnRect = leftColumn.getBoundingClientRect();
        
        // Ustaw pozycję playera pod formularzem notatki
        var newTop = noteFormRect.bottom + window.pageYOffset + 10; // 10px odstępu
        
        playerContainer.style.position = 'absolute';
        playerContainer.style.top = newTop + 'px';
        playerContainer.style.left = '20px';
        playerContainer.style.zIndex = '1000';
        
        // Wywołaj autosizePlayer aby dostosować rozmiar
        autosizePlayer();
        
        // Jeśli to nie jest zmiana rozmiaru, przewiń do formularza
        
        if (!isResizing) {
            var scrollTarget = noteFormRect.top + window.pageYOffset - 50; // 50px offset
            if (window.innerWidth  > 915) { //wlacz tylko dla desktop
                smoothScrollTo(scrollTarget, 500);
            }
        }
        
    } else {
        resetYouTubePlayerPosition();
    }
}

function resetYouTubePlayerPosition() {
    var playerContainer = document.querySelector('.player-container');
    playerContainer.style.position = 'relative';
    playerContainer.style.width = '100%';
    playerContainer.style.maxWidth = '2160px';
    playerContainer.style.height = '0';
    playerContainer.style.paddingBottom = '56.25%'; // Przywracamy aspect ratio 16:9
    playerContainer.style.top = 'auto';
    playerContainer.style.left = 'auto';
    playerContainer.style.zIndex = 'auto';
}

// Zmodyfikuj funkcję autosizePlayer
function autosizePlayer() {
    const leftColumn = document.querySelector('.left-column');
    const playerContainer = document.querySelector('.player-container');
    const youtubeIframe = playerContainer.querySelector('iframe');
    
    if (youtubeIframe) {
        const maxWidth = leftColumn.offsetWidth - 40; // 20px padding z każdej strony
        const defaultAspectRatio = 16 / 9;
        
        let newWidth = maxWidth; // Usuwamy ograniczenie do 640px
        let newHeight = newWidth / defaultAspectRatio;
        
        // Usuwamy ograniczenie wysokości do 360px
        
        playerContainer.style.width = newWidth + 'px';
        playerContainer.style.height = newHeight + 'px';
        playerContainer.style.paddingBottom = '0';
        
        youtubeIframe.style.width = '100%';
        youtubeIframe.style.height = '100%';
    }
    
    console.log("autosizePlayer wykonane, nowe wymiary:", playerContainer.style.width, playerContainer.style.height);
}

// Dodaj wywołanie autosizePlayer w funkcji onPlayerReady
function onPlayerReady(event) {
    console.log("Player gotowy do odtwarzania!");
    updatePlaylistData();
    loadWatchedVideosFromLocalStorage();
    setTimeout(autosizePlayer, 100); // Dodaj małe opóźnienie
    setInterval(function() {
        updatePlaylistData();
    }, 120000);
}

// Dodaj wywołanie autosizePlayer po załadowaniu filmu
function onPlayerStateChange(event) {
    console.log("Stan odtwarzacza:", event.data);

    if (event.data === YT.PlayerState.PLAYING) {
        var videoData = player.getVideoData();
        currentVideoId = videoData.video_id;
        currentVideoTitle = videoData.title;
        console.log("Aktualny film:", currentVideoTitle);

        // Dodaj film do listy obejrzanych na początku odtwarzania tylko jeśli flaga jest true
        if (addToWatchedOnStart) {
            markVideoAsWatched(currentVideoId, currentVideoTitle);
        }

        // Sprawdzamy czas przycinania przy każdym odtworzeniu
        checkTrimTime();
        
        setTimeout(autosizePlayer, 100);
    }

    if (event.data === YT.PlayerState.UNSTARTED && previousState === YT.PlayerState.PLAYING) {
        console.log("Film zakończył odtwarzanie.");

        // Dodaj film do listy obejrzanych na końcu odtwarzania, jeśli flaga jest false
        if (!addToWatchedOnStart) {
            markVideoAsWatched(currentVideoId, currentVideoTitle);
        }

        if (!isAutoplayEnabled) {
            console.log("Auto-play wyłączony, zatrzymuję odtwarzanie.");
            player.stopVideo();
        }
    }

    previousState = event.data;
}

// Dodaj tę funkcję, aby obsłużyć zmiany rozmiaru okna
function handleResize() {
    var activeNoteForm = document.querySelector('.note-form[style="display: block;"]');
    if (activeNoteForm) {
        var videoId = activeNoteForm.closest('li').id;
        adjustYouTubePlayerPosition(videoId, true);
    } else {
        autosizePlayer();
    }
}

// Zmodyfikuj nasłuchiwanie na zmianę rozmiaru okna
window.removeEventListener('resize', handleResize); // Usuń poprzednie nasłuchiwanie, jeli istnieje
window.addEventListener('resize', handleResize);

// Wywołaj autosizePlayer po załadowaniu strony
window.addEventListener('load', function() {
    autosizePlayer();
    console.log("autosizePlayer wywołane po załadowaniu strony");
});

// Dodaj tę nową funkcję do płynnego przewijania
function smoothScrollTo(targetPosition, duration) {
    const startPosition = window.pageYOffset;
    const distance = targetPosition - startPosition;
    let startTime = null;

    function animation(currentTime) {
        if (startTime === null) startTime = currentTime;
        const timeElapsed = currentTime - startTime;
        const run = ease(timeElapsed, startPosition, distance, duration);
        window.scrollTo(0, run);
        if (timeElapsed < duration) requestAnimationFrame(animation);
    }

    function ease(t, b, c, d) {
        t /= d / 2;
        if (t < 1) return c / 2 * t * t + b;
        t--;
        return -c / 2 * (t * (t - 2) - 1) + b;
    }

    requestAnimationFrame(animation);
}

function addWordTranslationPair(videoId, word = '', context = '', translation = '') {
    var listItem = document.getElementById(videoId);
    var pairsContainer = listItem.querySelector('.word-translation-pairs');
    var pairDiv = document.createElement('div');
    pairDiv.className = 'word-translation-pair';
    pairDiv.innerHTML = `
        <textarea class="word-input" placeholder="Word/Phrase">${word}</textarea>
        <textarea class="context-input" placeholder="Context">${context}</textarea>
        <textarea class="translation-input" placeholder="Translation">${translation}</textarea>
    `;
    pairsContainer.appendChild(pairDiv);

    // Dodaj obsługę automatycznego rozszerzania
    var textareas = pairDiv.querySelectorAll('textarea');
    textareas.forEach(textarea => {
        textarea.addEventListener('input', autoResize);
        autoResize.call(textarea); // Wywołaj raz, aby ustawić początkową wysokość
    });

    // Ustaw focus na pierwszym polu textarea, jeśli to pierwsza para
    if (pairsContainer.children.length === 1) {
        pairDiv.querySelector('.word-input').focus();
    }

    // Aktualizuj przyciski na angielskie wersje
    var addButton = listItem.querySelector('button[onclick^="addWordTranslationPair"]');
    var saveButton = listItem.querySelector('button[onclick^="saveNote"]');
    if (addButton) addButton.textContent = '+ Add word/phrase';
    if (saveButton) saveButton.textContent = 'Save note';
    // Dodajemy opóźnienie, aby dać czas na renderowanie nowego pola
    setTimeout(() => {
        adjustIframeSize();
        adjustYouTubePlayerPosition(videoId, false);
        if (window.innerWidth  > 915 ) { //wlacz tylko dla desktop
            // Przewiń do 1/3 strony zamiast 1/6 (zwiększamy wartość)
            var newPairRect = pairDiv.getBoundingClientRect();
            var targetScrollPosition = newPairRect.top + window.pageYOffset - (window.innerHeight / 20) + 31;
            smoothScrollTo(targetScrollPosition, 500);
        }
        else if (isPortrait) { // 1/4 strony dla mobile 1/3.65
            var newPairRect = pairDiv.getBoundingClientRect();
            var targetScrollPosition = newPairRect.top + window.pageYOffset - (window.innerHeight / 3.65) ;
         smoothScrollTo(targetScrollPosition, 500);
        }
     // Dla wszytkicj mniejszych niz 915px w trybie landscape, wyłacz przewijanie

    }, 100);
	
    //Zapisz aktualny stan notki
    saveNote2(videoId);	
}

function autoResize() {
    this.style.height = 'auto';
    this.style.height = (this.scrollHeight) + 'px';
    var videoId = this.closest('.note-form').parentElement.id;
    adjustYouTubePlayerPosition(videoId, true);
    adjustIframeSize(); // Dodajemy to wywołanie
}

function adjustAllTextareas() {
    document.querySelectorAll('.word-translation-pair textarea').forEach(textarea => {
        autoResize.call(textarea);
    });
}

function saveNote2(videoId) {
    var listItem = document.getElementById(videoId);
    var pairs = listItem.querySelectorAll('.word-translation-pair');
    var notes = [];
    pairs.forEach(pair => {
        var word = pair.querySelector('.word-input').value.trim();
        var context = pair.querySelector('.context-input').value.trim();
        var translation = pair.querySelector('.translation-input').value.trim();
        if (word || context || translation) {
            notes.push({ word, context, translation });
        }
    });

    var video = watchedVideos[currentPlaylistId].find(v => v.id === videoId);
    if (video) {
        video.notes = notes;
        saveWatchedVideosToLocalStorage();
        //updateWatchedVideosList();
    }
	
}

function saveNote(videoId) {
    var listItem = document.getElementById(videoId);
    var pairs = listItem.querySelectorAll('.word-translation-pair');
    var notes = [];
    pairs.forEach(pair => {
        var word = pair.querySelector('.word-input').value.trim();
        var context = pair.querySelector('.context-input').value.trim();
        var translation = pair.querySelector('.translation-input').value.trim();
        if (word || context || translation) {
            notes.push({ word, context, translation });
        }
    });

    var video = watchedVideos[currentPlaylistId].find(v => v.id === videoId);
    if (video) {
        video.notes = notes;
        saveWatchedVideosToLocalStorage();
        updateWatchedVideosList();
    }

    // Aktualizuj ikonę notatki
    var noteIcon = listItem.querySelector('.note-icon');
    noteIcon.textContent = notes.length > 0 ? '📝' : '➕';
    adjustIframeSize();
}

function toggleAutoplay() {
    isAutoplayEnabled = !isAutoplayEnabled;
    var button = document.getElementById('autoplay-btn');
    if (isAutoplayEnabled) {
        button.textContent = "Auto-play: ON";
        button.classList.add('active');
    } else {
        button.textContent = "Auto-play: OFF";
        button.classList.remove('active');
        console.log("Auto-play wyłączony.");
        if (player && player.getPlayerState() === YT.PlayerState.PLAYING) {
            player.stopVideo();
        }
    }
}

function saveWatchedVideosToLocalStorage() {
    try {
        console.log('Próba zapisu do localStorage. Dane przed zapisem:', watchedVideos);
        const watchedVideosJSON = JSON.stringify(watchedVideos);
        console.log('Dane po konwersji do JSON:', watchedVideosJSON);
        localStorage.setItem('watchedVideos', watchedVideosJSON);
        console.log('Zapisano obejrzane filmy do localStorage');
        console.log('Zawartość localStorage po zapisie:', localStorage.getItem('watchedVideos'));
        debugLocalStorage();
    } catch (e) {
        console.error('Błąd przy zapisywaniu do localStorage:', e);
        console.error('Stos wywołań:', e.stack);
    }
}

function loadWatchedVideosFromLocalStorage() {
try {
console.log('Próba odczytu z localStorage');
const storedWatchedVideos = localStorage.getItem('watchedVideos');
console.log('Odczytane dane z localStorage:', storedWatchedVideos);
if (storedWatchedVideos) {
    const parsedData = JSON.parse(storedWatchedVideos);
    if (Array.isArray(parsedData)) {
        // Stary format danych (tablica)
        watchedVideos = {
            [currentPlaylistId]: parsedData
        };
    } else {
        // Nowy format danych (obiekt)
        watchedVideos = parsedData;
    }
    console.log('Sparsowane dane:', watchedVideos);
    updateWatchedVideosList();
} else {
    console.log('Brak zapisanych danych w localStorage');
    watchedVideos = {};
}
} catch (e) {
console.error('Błąd przy odczytywaniu z localStorage:', e);
console.error('Stos wywołań:', e.stack);
watchedVideos = {};
}
}

function debugWatchedVideos() {
    console.log("Debugowanie watchedVideos:");
    console.log("currentPlaylistId:", currentPlaylistId);
    console.log("watchedVideos:", JSON.parse(JSON.stringify(watchedVideos)));
    console.log("localStorage:", localStorage.getItem('watchedVideos'));
}

function clearWatchedVideos() {
    if (confirm("Are you sure you want to clear all data about watched videos?")) {
        localStorage.removeItem('watchedVideos');
        watchedVideos = {};
        updateWatchedVideosList();
        updateWatchedCount();
        updateWordList(); // Dodaj tę linię, aby odświeżyć listę słów
        console.log("Cleared data about watched videos");
        alert("Data about watched videos has been cleared.");
    }
}

window.onerror = function(message, source, lineno, colno, error) {
    console.error("Błąd JavaScript:", message, "w", source, "linia:", lineno);
    return false;
};

function addCustomPlaylistOrVideo() {
    var linkInput = document.getElementById('custom-playlist-link');
    var link = linkInput.value.trim();
    
    if (isPlaylistLink(link)) {
        addCustomPlaylist(link);
    } else if (isVideoLink(link)) {
        addSingleVideo(link);
    } else {
        alert("Invalid link. Please enter a valid link to a YouTube playlist or video.");
    }
}

function addCustomPlaylist(playlistLink) {
    var playlistId = extractPlaylistId(playlistLink);
    
    if (playlistId) {
        var playlistName = prompt("Enter a name for this playlist:");
        if (playlistName) {
            playlists.push({ id: playlistId, name: playlistName, custom: true });
            trimTimes[playlistId] = 0;
            savePlaylistsToLocalStorage();
            saveTrimTimesToLocalStorage();
            createPlaylistButtons();
            document.getElementById('custom-playlist-link').value = '';
            loadPlaylist(playlistId);
        }
    } else {
        alert("Invalid playlist link. Please try again.");
    }
}

function addSingleVideo(videoLink) {
    var videoId = extractVideoId(videoLink);
    
    if (videoId) {
        var videoName = prompt("Enter a name for this video:");
        if (videoName) {
            var customPlaylistId = 'custom_videos_' + Date.now();
            playlists.push({ id: customPlaylistId, name: videoName, custom: true, singleVideo: videoId });
            trimTimes[customPlaylistId] = 0;
            savePlaylistsToLocalStorage();
            saveTrimTimesToLocalStorage();
            createPlaylistButtons();
            document.getElementById('custom-playlist-link').value = '';
            loadSingleVideo(customPlaylistId, videoId);
        }
    } else {
        alert("Invalid video link. Please try again.");
    }
}

function isPlaylistLink(link) {
    return link.includes('list=');
}

function isVideoLink(link) {
    return link.includes('v=') || link.includes('youtu.be/');
}

function extractVideoId(link) {
    var regex = /(?:v=|youtu\.be\/)([^&\?]+)/;
    var match = link.match(regex);
    return match && match[1] ? match[1] : null;
}

function loadSingleVideo(customPlaylistId, videoId) {
    currentPlaylistId = customPlaylistId;
    if (player) {
        player.destroy();
    }
    player = new YT.Player('player', {
        height: '360',
        width: '640',
        videoId: videoId,
        playerVars: {
            'autoplay': 0,
            'controls': 1,
            'rel': 0,
            'modestbranding': 1,
            'iv_load_policy': 3,
            'cc_load_policy': 1,
            'cc_lang_pref': 'en'
        },
        events: {
            'onReady': onPlayerReady,
            'onStateChange': onPlayerStateChange
        }
    });
    updateActivePlaylistButton(customPlaylistId);
    loadWatchedVideosFromLocalStorage();
    updateWatchedVideosList();
    
    // Dodaj to wywołanie, aby oznaczyć pojedynczy film jako obejrzany
    var playlist = playlists.find(p => p.id === customPlaylistId);
    if (playlist && playlist.singleVideo) {
        markVideoAsWatched(videoId, playlist.name);
    }
}

function savePlaylistsToLocalStorage() {
    localStorage.setItem('customPlaylists', JSON.stringify(playlists));
}

    // Domyślne playlisty BBC
    const defaultPlaylists = [
        { id: 'PLcetZ6gSk96-FECmH9l7Vlx5VDigvgZpt', name: '6 Minute English' },
        { id: 'PLcetZ6gSk96_Fprtuj6gKN9upPjaDrARH', name: 'English In A Minute' },
        { id: 'PLcetZ6gSk96_sototkO7HFkGA8zL8H0lq', name: 'The English We Speak' },
        { id: 'PLcetZ6gSk96--2ELXoJeyafP6wg4n53uh', name: 'Phrasal Verbs' },
        { id: 'PLcetZ6gSk96_zHuVg6Ecy2F7j4Aq4valQ', name: '6 Minute Grammar' }
    ];

function loadPlaylistsFromLocalStorage() {
    var storedPlaylists = localStorage.getItem('customPlaylists');
    if (storedPlaylists) {
        playlists = JSON.parse(storedPlaylists);
    }
    
    // Sprawdź ustawienie BBC playlist
    const bbcPlaylistEnabled = localStorage.getItem('bbcPlaylistEnabled') === 'true';
    


    // Dodaj domyślne playlisty tylko jeśli BBC jest włączone
    if (bbcPlaylistEnabled) {
        defaultPlaylists.forEach(function(defaultPlaylist) {
            if (!playlists.some(p => p.id === defaultPlaylist.id)) {
                playlists.push(defaultPlaylist);
            }
        });
    }

    savePlaylistsToLocalStorage(); // Zapisz zaktualizowaną listę
}

function removePlaylist(playlistId) {
    if (confirm("Are you sure you want to remove this playlist?")) {
        playlists = playlists.filter(p => p.id !== playlistId);
        savePlaylistsToLocalStorage();
        createPlaylistButtons();
        if (currentPlaylistId === playlistId) {
            loadPlaylist(playlists[0].id);
        }
    }
}

function updateActivePlaylistButton(playlistId) {
    var buttons = document.getElementsByClassName('playlist-button');
    for (var i = 0; i < buttons.length; i++) {
        buttons[i].classList.remove('active');
        if (buttons[i].textContent === getPlaylistName(playlistId)) {
            buttons[i].classList.add('active');
        }
    }
}

function getPlaylistName(playlistId) {
    var playlist = playlists.find(p => p.id === playlistId);
    return playlist ? playlist.name : 'Unknown playlist';
}

function setTrimTime() {
    var currentTrimTime = trimTimes[currentPlaylistId] || 0;
    var minutes = Math.floor(currentTrimTime / 60);
    var seconds = currentTrimTime % 60;
    var currentTimeString = (minutes < 10 ? '0' : '') + minutes + ':' + (seconds < 10 ? '0' : '') + seconds;

    var timeInput = prompt("Podaj czas w formacie MM:SS, po którym film ma przeskoczyć do końcowych 3 sekund (00:00 aby wyłączy):", currentTimeString);
    if (timeInput !== null) {
        var parts = timeInput.split(':');
        var minutes = parseInt(parts[0], 10);
        var seconds = parseInt(parts[1], 10);
        var trimTime = minutes * 60 + seconds;
        trimTimes[currentPlaylistId] = trimTime;
        saveTrimTimesToLocalStorage();
        var message = trimTime > 0 
            ? "Ustawiono nowy czas przeskoku dla playlisty " + getPlaylistName(currentPlaylistId) + ": " + minutes + " minut " + seconds + " sekund."
            : "Wyłączono przeskok dla playlisty " + getPlaylistName(currentPlaylistId) + ".";
        alert(message);
    }
}

function saveTrimTimesToLocalStorage() {
    localStorage.setItem('trimTimes', JSON.stringify(trimTimes));
}

function loadTrimTimesFromLocalStorage() {
    var storedTrimTimes = localStorage.getItem('trimTimes');
    if (storedTrimTimes) {
        trimTimes = JSON.parse(storedTrimTimes);
    }
}

function toggleCustomPlaylistInput() {
    var customContainer = document.querySelector('.custom-playlist-container');
    var toggleButton = document.querySelector('.toggle-input-button');
    if (customContainer.style.display === 'none') {
        customContainer.style.display = 'flex';
        toggleButton.textContent = '-';
    } else {
        customContainer.style.display = 'none';
        toggleButton.textContent = '+';
    }
}

function toggleWordList() {
    var container = document.getElementById('word-list-container');
    if (container.style.display === 'none') {
        updateWordList();
        container.style.display = 'block';
        makeDraggable(container);
    } else {
        container.style.display = 'none';
    }
}

function updateWordList() {
    var allWords = [];
    Object.values(watchedVideos).forEach(playlist => {
        playlist.forEach(video => {
            if (video.notes) {
                allWords = allWords.concat(video.notes);
            }
        });
    });

    var tableBody = document.querySelector('#word-list-table tbody');
    tableBody.innerHTML = '';

    var maxWordLength = 0;
    var maxContextLength = 0;
    var maxTranslationLength = 0;

    allWords.forEach((note, index) => {
        var row = tableBody.insertRow();
        row.className = index % 2 === 0 ? 'even' : 'odd';
        var cellNumber = row.insertCell(0);
        var cellWord = row.insertCell(1);
        var cellContext = row.insertCell(2);
        var cellTranslation = row.insertCell(3);
        
        cellNumber.textContent = index + 1;
        cellWord.textContent = note.word;
        cellContext.textContent = note.context;
        cellTranslation.textContent = note.translation;

        maxWordLength = Math.max(maxWordLength, note.word.length);
        maxContextLength = Math.max(maxContextLength, note.context.length);
        maxTranslationLength = Math.max(maxTranslationLength, note.translation.length);
    });

    // Ustawiamy szerokość kontenera na podstawie najdłuższych wpisów
    var container = document.getElementById('word-list-container');
    var numberWidth = 30; // Szerokość kolumny z numeracją
    var wordWidth = maxWordLength * 10; // Przybliżona szerokość znaku w pikselach
    var contextWidth = maxContextLength * 10;
    var translationWidth = maxTranslationLength * 10;
    var totalWidth = numberWidth + wordWidth + contextWidth + translationWidth + 100; // Dodajemy margines na obramowanie i padding
    container.style.width = totalWidth + 'px';

    // Ustawiamy szerokość kolumn
    var table = document.getElementById('word-list-table');
    table.style.width = '100%';
    table.style.tableLayout = 'fixed';
    var columns = table.getElementsByTagName('th');
    columns[0].style.width = (numberWidth / totalWidth * 100) + '%';
    columns[1].style.width = (wordWidth / totalWidth * 100) + '%';
    columns[2].style.width = (contextWidth / totalWidth * 100) + '%';
    columns[3].style.width = (translationWidth / totalWidth * 100) + '%';
}

// Dodaj tę funkcj na końcu sekcji <script>
function makeDraggable(elmnt, isIframe = false) {
    var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    var header = isIframe ? null : elmnt.querySelector('#word-list-header');
    var resizer = isIframe ? document.getElementById('iframe-resizer') : elmnt.querySelector('#word-list-resizer');

    if (header) {
        header.onmousedown = dragMouseDown;
    } else if (!isIframe) {
        elmnt.onmousedown = dragMouseDown;
    }

    if (resizer) {
        resizer.onmousedown = resizeMouseDown;
    }

    function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
    }

    function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
        elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
    }

    function resizeMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeResizeElement;
        document.onmousemove = elementResize;
    }

    function elementResize(e) {
        e = e || window.event;
        e.preventDefault();
        var newWidth = elmnt.offsetWidth + (e.clientX - pos3);
        var newHeight = elmnt.offsetHeight + (e.clientY - pos4);
        
        // Ustaw minimalne wymiary
        newWidth = Math.max(newWidth, 300);
        newHeight = Math.max(newHeight, 200);
        
        if (isIframe) {
            // Ogranicz maksymalną wysokość do wysokości okna
            var maxHeight = window.innerHeight - elmnt.getBoundingClientRect().top - 20;
            newHeight = Math.min(newHeight, maxHeight);
        }
        
        elmnt.style.width = newWidth + "px";
        elmnt.style.height = newHeight + "px";
        pos3 = e.clientX;
        pos4 = e.clientY;

        if (isIframe) {
            // Aktualizuj wysokość iframe'a
            var iframe = elmnt.querySelector('iframe');
            iframe.style.height = newHeight + "px";
            iframe.style.width = newWidth + "px";
        }
    }

    function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
    }

    function closeResizeElement() {
        document.onmouseup = null;
        document.onmousemove = null;
    }
}

// Wywołaj tę funkcję po załadowaniu strony
window.addEventListener('load', function() {
    var wordListContainer = document.getElementById("word-list-container");
    makeDraggable(wordListContainer);

    var iframeContainer = document.querySelector('.iframe-container');
    makeDraggable(iframeContainer, true);
});

function changeDictionary() {
    const select = document.getElementById('dictionary-select');
    const checkbox = document.getElementById('default-dictionary-checkbox');
    const selectedUrl = select.value;
    
    if (selectedUrl === 'add_new') {
        addNewDictionary();
    } else if (selectedUrl === 'remove_dictionary') {
        removeDictionary();
    } else {
        // Dodaj parametr dark=1 do URL jeśli tryb ciemny jest aktywny
        const isDarkMode = document.body.classList.contains('dark-mode');
        const urlWithDarkMode = isDarkMode ? 
            `${selectedUrl}${selectedUrl.includes('?') ? '&' : '?'}dark=1` : 
            selectedUrl;
            
        addNewTab();
        // Aktualizuj stan checkboxa
        const defaultDictionary = localStorage.getItem('defaultDictionary');
        checkbox.checked = (defaultDictionary === selectedUrl);
    }
}

function addNewDictionary() {
    const name = prompt("Enter the name of the new dictionary:");
    if (name) {
        let url = prompt("Enter the URL of the new dictionary (without https://):");
        if (url) {
            // Dodaj https:// jeśli nie zostało podane
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                url = 'https://' + url;
            }
            
            const select = document.getElementById('dictionary-select');
            const option = document.createElement('option');
            option.value = url;
            option.textContent = name;
            
            // Wstaw nową opcję przed "Add new"
            const addNewOption = select.querySelector('option[value="add_new"]');
            select.insertBefore(option, addNewOption);
            
            select.value = url;
            changeDictionary();
            
            // Zapisz nowy słownik w localStorage
            const dictionaries = JSON.parse(localStorage.getItem('customDictionaries') || '[]');
            dictionaries.push({ name, url });
            localStorage.setItem('customDictionaries', JSON.stringify(dictionaries));
        }
    }
    // Jeśli użytkownik anulował, przywróć poprzednią wartość
    const select = document.getElementById('dictionary-select');
    if (select.value === 'add_new') {
        select.value = select.querySelector('option:not([value="add_new"]):not([value="remove_dictionary"])').value;
    }
    changeDictionary();
}

function removeDictionary() {
    const select = document.getElementById('dictionary-select');
    
    // Tworzymy nowe okno dialogowe
    const dialog = document.createElement('dialog');
    dialog.innerHTML = `
        <h3>Select a dictionary to remove</h3>
        <select id="dictionary-to-remove">
            ${Array.from(select.options)
                .filter(option => !['add_new', 'remove_dictionary'].includes(option.value))
                .map(option => `<option value="${option.value}">${option.text}</option>`)
                .join('')}
        </select>
        <div>
            <button id="confirm-remove">Remove</button>
            <button id="cancel-remove">Cancel</button>
        </div>
    `;
    
    document.body.appendChild(dialog);
    dialog.showModal();

    // Obsługa przycisków
    dialog.querySelector('#confirm-remove').addEventListener('click', () => {
        const selectToRemove = dialog.querySelector('#dictionary-to-remove');
        const dictionaryToRemove = selectToRemove.options[selectToRemove.selectedIndex].text;
        const optionToRemove = Array.from(select.options).find(option => option.text === dictionaryToRemove);
        
        if (optionToRemove) {
            // Usuń z select
            select.removeChild(optionToRemove);
            
            // Usuń z localStorage
            const dictionaries = JSON.parse(localStorage.getItem('customDictionaries') || '[]');
            const updatedDictionaries = dictionaries.filter(dict => dict.name !== dictionaryToRemove);
            localStorage.setItem('customDictionaries', JSON.stringify(updatedDictionaries));
            
            // Jeśli usunięty słownik był domyślny, usuń ustawienie domyślne
            if (localStorage.getItem('defaultDictionary') === optionToRemove.value) {
                localStorage.removeItem('defaultDictionary');
                document.getElementById('default-dictionary-checkbox').checked = false;
            }
            
            alert(`Dictionary "${dictionaryToRemove}" has been removed.`);
        }
        
        dialog.close();
        dialog.remove();
    });

    dialog.querySelector('#cancel-remove').addEventListener('click', () => {
        dialog.close();
        dialog.remove();
    });

    // Przywróć poprzednią wartość
    select.value = select.querySelector('option:not([value="add_new"]):not([value="remove_dictionary"])').value;
    changeDictionary();
}

// Dodaj tę funkcję, aby ładować niestandardowe słowniki przy starcie
function loadCustomDictionaries() {
    const dictionaries = JSON.parse(localStorage.getItem('customDictionaries') || '[]');
    const select = document.getElementById('dictionary-select');
    
    // Usuń wszystkie opcje z select
    while (select.firstChild) {
        select.removeChild(select.firstChild);
    }
    
    // Dodaj domyślne słowniki
    const defaultDictionaries = [
        { name: 'onelook.com', url: 'https://www.onelook.com/' },
        { name: 'you.com (ai)', url: 'https://you.com/search?q=' + encodeURIComponent('You are an English teacher. Give me the meaning of the word in the next prompt. Just ask about the word. Explain in different words and provide me 3 example sentences with this word.') + '&tbm=youchat&chatMode=default' },
        { name: 'diki.pl', url: 'https://www.diki.pl/' },
        { name: 'dict.com', url: 'https://dict.com/angielsko-polski' },
        { name: 'ling.pl', url: 'https://ling.pl/' }
       
    ];
    
    // Dodaj domyślne i niestandardowe słowniki
    [...defaultDictionaries, ...dictionaries].forEach(dict => {
        const option = document.createElement('option');
        option.value = dict.url;
        option.textContent = dict.name;
        select.appendChild(option);
    });
    
    // Dodaj opcje "Add new" i "Remove" na końcu
    const addNewOption = document.createElement('option');
    addNewOption.value = 'add_new';
    addNewOption.textContent = 'Add new';
    select.appendChild(addNewOption);
    
    const removeOption = document.createElement('option');
    removeOption.value = 'remove_dictionary';
    removeOption.textContent = 'Remove';  // Zmieniono z 'Remove dictionary' na 'Remove'
    select.appendChild(removeOption);
}

// Wywołaj tę funkcję przy ładowaniu strony
window.addEventListener('load', function() {
    loadCustomDictionaries();
    loadDefaultDictionary();
    // ... inne funkcje wywoływane przy ładowaniu ...
});

function adjustIframeSize(videoId) {
    var container = document.querySelector('.iframe-container');
    var rightColumn = document.querySelector('.right-column');
    var dictionarySelect = document.querySelector('#dictionary-select');
    var dictionarySelectContainer = document.querySelector('.dictionary-select-container');
    var separator = document.querySelector('#separator');
    var activeNoteForm = document.querySelector('.note-form[style="display: block;"]');
    
    // Oblicz minimalną górną pozycję (tuż pod separatorem)
    var minTop = dictionarySelect.offsetTop + dictionarySelect.offsetHeight;
    
    if (window.innerWidth  > 520 ) { // tryb desktop, na mobile
        if (activeNoteForm) { //notatka otwarta
        var lastWordPair = activeNoteForm.querySelector('.word-translation-pair:last-child');
        if (lastWordPair) {
            var lastWordPairRect = lastWordPair.getBoundingClientRect();
            var newTop = Math.max(minTop, lastWordPairRect.bottom + window.pageYOffset - 295); // Podwyzszanie słownika
            container.style.top = newTop + 'px';
            dictionarySelectContainer.style.position = 'relative';   //wazne! 
            dictionarySelectContainer.style.top = newTop + 125+ 'px'; // offset
        } else {
            container.style.top = minTop + 'px';
            dictionarySelectContainer.style.position = 'sticky';
        }
    }   else {  // pozycja default słwonika na stronie, notatka zamknieta
            container.style.top = minTop - 213 +'px';   
            dictionarySelectContainer.style.position = 'sticky'; // powrot do sticky , zadziałalo
            dictionarySelectContainer.style.top = 'auto';  // zadziałalo      
        }

    }

    else { //mobile

        if (activeNoteForm) { //notatka otwarta
            var videoList = document.getElementById('video-list');
            var allItems = Array.from(videoList.getElementsByTagName('li'))
            var videoItems = videoList.getElementsByTagName('li');
            var rowHeight = 30; // Przybliżona wysokość jednego wiersza

            var lastWordPair = activeNoteForm.querySelector('.word-translation-pair:last-child');
            var clickedIndex = 0;
            var listOffset = 0;
            if (videoId){
            listItemVideoId = document.getElementById(videoId);
            clickedIndex = allItems.indexOf(listItemVideoId);
            listOffset = (allItems.length - (clickedIndex + 1)) * rowHeight;
            }
            else{
                console.log('No videoID');
                listOffset = 0;
            }
            
        
            console.log('Clicked item index:', clickedIndex + 1); // +1 dla numeracji od 1
            console.log('Total items:', allItems.length);

            if (lastWordPair) {
                var lastWordPairRect = lastWordPair.getBoundingClientRect();
                var newTop = Math.max(minTop, lastWordPairRect.bottom + window.pageYOffset - 295); // Podwyzszanie słownika
                container.style.top = minTop  + 22 - listOffset + 'px';
                dictionarySelectContainer.style.position = 'relative';   //wazne! 
                dictionarySelectContainer.style.top = minTop + 40 + 125 - listOffset + 'px'; // offset
            } else {
                container.style.top = minTop + 'px';
                dictionarySelectContainer.style.position = 'sticky';
            }
        } else {  // pozycja default słwonika na stronie, notatka zamknieta
            container.style.top = minTop - 210 + 'px';   
            dictionarySelectContainer.style.position = 'relative'; // powrot do sticky , zadziałalo
            dictionarySelectContainer.style.top = minTop - 70 + 'px';
        }
        //var separator = document.querySelector('#separator');
        //separator.style.zIndex = '1000';
        //dictionarySelect.style.zIndex = '1000';
        //dictionarySelectContainer.style.zIndex = '1000';
        container.style.zIndex = '1000';
        //container.style.background = 'none';
    }
    // Dostosuj szerokość kontenera do szerokości dropdown menu
    container.style.width = dictionarySelect.offsetWidth + 'px';
}

function calculateNoteFormHeight() {
    var activeNoteForm = document.querySelector('.note-form[style="display: block;"]');
    if (activeNoteForm) {
        return activeNoteForm.offsetHeight + 20; // Dodajemy 20px dodatkowego miejsca
    }
    return 0;
}
/*
function addNoteIconHoverListeners() {
    var noteIcons = document.querySelectorAll('.note-icon');
    noteIcons.forEach(function(icon) {
        icon.addEventListener('mouseenter', adjustIframeSize);
        icon.addEventListener('mouseleave', adjustIframeSize);
    });
}
*/

// Dodaj wywołanie funkcji adjustIframeSize przy adowaniu strony i zmianie rozmiaru okna
window.addEventListener('load', adjustIframeSize);
window.addEventListener('resize', adjustIframeSize);

// Dodaj wywołanie funkcji adjustIframeSize po każdej zmianie w notatkach

function addNoteIconHoverListeners() {
   // var noteIcons = document.querySelectorAll('.note-icon');
  //  noteIcons.forEach(function(icon) {
 //       icon.addEventListener('mouseenter', adjustIframeSize);
 //       icon.addEventListener('mouseleave', adjustIframeSize);
 //   });
}


// Wywołaj addNoteIconHoverListeners po zaadowaniu strony i po każdej aktualizacji listy notatek
window.addEventListener('load', addNoteIconHoverListeners);
// Dodaj wywołanie addNoteIconHoverListeners w funkcji updateWatchedVideosList

// Dodaj nasłuchiwanie na zdarzenie zmiany rozmiaru okna
window.addEventListener('resize', adjustIframeSize);

function checkLocalStorage() {
    try {
        localStorage.setItem('test', 'test');
        localStorage.removeItem('test');
        console.log('localStorage jest dostępny');
        return true;
    } catch(e) {
        console.error('localStorage nie jest dostępny:', e);
        console.error('Stos wywołań:', e.stack);
        return false;
    }
}

// Wywołaj tę funkcję przy ładowaniu strony i po każdej operacji na localStorage
window.addEventListener('load', function() {
    checkLocalStorage();
    debugLocalStorage();
});

// Dodaj tę funkcję, aby sprawdzić stan localStorage w dowolnym momencie
function debugLocalStorage() {
    console.log('Zawartość localStorage:');
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        console.log(`${key}: ${value}`);
    }
}

function initializeWatchedVideos() {
    if (!watchedVideos || typeof watchedVideos !== 'object') {
        watchedVideos = {};
    }
    playlists.forEach(playlist => {
        if (!watchedVideos[playlist.id]) {
            watchedVideos[playlist.id] = [];
        }
    });
}

function makeResizable(element) {
    const resizer = element.querySelector('.player-resizer');
    let isResizing = false;
    let originalWidth, originalHeight, originalX, originalY;

    resizer.addEventListener('mousedown', function(e) {
        isResizing = true;
        originalWidth = parseFloat(getComputedStyle(element, null).getPropertyValue('width').replace('px', ''));
        originalHeight = parseFloat(getComputedStyle(element, null).getPropertyValue('height').replace('px', ''));
        originalX = e.pageX;
        originalY = e.pageY;
        e.preventDefault();
    });

    document.addEventListener('mousemove', function(e) {
        if (!isResizing) return;
        const width = originalWidth + (e.pageX - originalX);
        const height = originalHeight + (e.pageY - originalY);
        element.style.width = width + 'px';
        element.style.height = height + 'px';
        
        // Dostosuj rozmiar iframe'a YouTube
        const youtubeIframe = element.querySelector('iframe');
        if (youtubeIframe) {
            youtubeIframe.style.width = '100%';
            youtubeIframe.style.height = '100%';
        }
        
        adjustResizerPosition(); // Dodajemy to wywołanie
    });

    document.addEventListener('mouseup', function() {
        isResizing = false;
        document.body.style.cursor = 'default';
        adjustResizerPosition(); // Dodajemy to wywołanie
    });
}

// Wywołajmy tę funkcję również po załadowaniu strony
window.addEventListener('load', function() {
    const playerContainer = document.querySelector('.player-container');
    makeResizable(playerContainer);
    adjustResizerPosition();
});

function adjustResizerPosition() {
    const playerContainer = document.querySelector('.player-container');
    const resizer = playerContainer.querySelector('.player-resizer');
    resizer.style.right = '0';
    resizer.style.bottom = '0';
}

window.addEventListener('resize', function() {
    var activeNoteForm = document.querySelector('.note-form[style="display: block;"]');
    if (activeNoteForm) {
        var videoId = activeNoteForm.closest('li').id;
        adjustYouTubePlayerPosition(videoId, false);
    }
});

// Add this function to update the watched count
function updateWatchedCount() {
    var watchedCount = watchedVideos[currentPlaylistId] ? watchedVideos[currentPlaylistId].length : 0;
    document.getElementById('watched-count').textContent = watchedCount;
}

function exportWordList() {
    var allWords = [];
    Object.values(watchedVideos).forEach(playlist => {
        playlist.forEach(video => {
            if (video.notes) {
                video.notes.forEach(note => {
                    allWords.push({
                        front: note.word,
                        back: note.translation,
                        context: note.context,
                        videoTitle: video.title
                    });
                });
            }
        });
    });

    // Export as CSV
    var csvContent = "front;back;context;;;Video Title\n";
    allWords.forEach(note => {
        csvContent += `${escapeCSV(note.front)};`;
        csvContent += `${escapeCSV(note.back)};`;
        csvContent += `${escapeCSV(note.context)};`;
        csvContent += `;;`;
        csvContent += `${escapeCSV(note.videoTitle)}\n`;
    });

    // Create and trigger download for CSV
    downloadFile(csvContent, 'anki_import.csv', 'text/csv;charset=utf-8');
}

function downloadFile(content, fileName, mimeType) {
    var blob = new Blob([content], { type: mimeType });
    var link = document.createElement("a");
    if (link.download !== undefined) {
        var url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", fileName);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
}

function escapeCSV(str) {
    if (str == null) return '';
    return '"' + str.replace(/"/g, '""').replace(/\n/g, ' ') + '"';
}

// Dodaj te funkcje na końcu pliku

function setDefaultDictionary() {
    const select = document.getElementById('dictionary-select');
    const checkbox = document.getElementById('default-dictionary-checkbox');
    if (checkbox.checked) {
        localStorage.setItem('defaultDictionary', select.value);
    } else {
        localStorage.removeItem('defaultDictionary');
    }
    // Dodajemy to wywołanie, aby zaktualizować stan checkboxa
    changeDictionary();
}

function loadDefaultDictionary() {
    const defaultDictionary = localStorage.getItem('defaultDictionary');
    const select = document.getElementById('dictionary-select');
    const checkbox = document.getElementById('default-dictionary-checkbox');
    
    if (defaultDictionary) {
        select.value = defaultDictionary;
        checkbox.checked = true;
    } else {
        // Jeśli nie ma zapisanego domyślnego słownika, ustaw pierwszy z listy
        select.selectedIndex = 0;
        checkbox.checked = false;
    }
    
    // Zwróć URL wybranego słownika
    return select.value;
}

// Upewnijmy się, że loadDefaultDictionary jest wywoływane po załadowaniu strony
window.addEventListener('load', loadDefaultDictionary);

document.addEventListener('DOMContentLoaded', function() {
    const mainContainer = document.querySelector('.main-container');

    function adjustLayoutForMobile() {
        if (window.innerWidth  <= 520) {
            mainContainer.classList.add('mobile-view');
        } else {
            mainContainer.classList.remove('mobile-view');
        }
        
        // Dostosuj rozmiar playera YouTube po zmianie układu
        if (typeof autosizePlayer === 'function') {
            setTimeout(autosizePlayer, 300);
        }
    }

    // Wywołaj funkcję przy załadowaniu strony i przy zmianie rozmiaru okna
    adjustLayoutForMobile();
    window.addEventListener('resize', adjustLayoutForMobile);
});

// Dodaj nową funkcję do przełączania funkcjonalności
function toggleAddToWatchedOnStart() {
    addToWatchedOnStart = !addToWatchedOnStart;
    var button = document.getElementById('toggle-add-to-watched');
    button.textContent = addToWatchedOnStart ? 'Create a note on end of movie' : 'Create a note on beginning of movie';
}

// Dodaj nową funkcję do inicjalizacji przycisku
function initializeAddToWatchedButton() {
    var button = document.getElementById('toggle-add-to-watched');
    button.textContent = 'Create a note on end of movie';
    // Usunięto renderTabs();
}

// Dodaj wywołanie tej funkcji w onYouTubeIframeAPIReady lub w event listener 'load'
window.addEventListener('load', function() {
    // ... inne istniejące wywołania ...
    initializeAddToWatchedButton();
});

let tabs = [];

// Zmodyfikuj funkcję addNewTab
function addNewTab() {
    const dictionarySelect = document.getElementById('dictionary-select');
    const selectedDictionary = dictionarySelect.value;
    const dictionaryName = dictionarySelect.options[dictionarySelect.selectedIndex].text;
    
    // Usuń komunikat "No dictionary selected"
    const iframeContainer = document.getElementById('iframe-container');
    if (iframeContainer.innerHTML.includes('No dictionary selected')) {
        iframeContainer.innerHTML = '';
    }
    
    const newTab = {
        id: Date.now(),
        name: dictionaryName,
        url: selectedDictionary
    };
    
    tabs.push(newTab);
    renderTabs();
    createIframe(newTab);
    switchToTab(newTab.id);
}

// Dodaj nową funkcję createIframe
function createIframe(tab) {
    const iframeContainer = document.getElementById('iframe-container');
    const iframe = document.createElement('iframe');
    iframe.src = tab.url;
    iframe.id = `iframe-${tab.id}`;
    iframe.style.display = 'none';
    iframeContainer.appendChild(iframe);
}

// Zmodyfikuj funkcję switchToTab
function switchToTab(tabId) {
    const tab = tabs.find(t => t.id === tabId);
    if (!tab) return;
    
    const iframeContainer = document.getElementById('iframe-container');
    const iframes = iframeContainer.querySelectorAll('iframe');
    iframes.forEach(iframe => {
        iframe.style.display = 'none';
    });
    
    const activeIframe = document.getElementById(`iframe-${tabId}`);
    if (activeIframe) {
        activeIframe.style.display = 'block';
    }
    
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelector(`.tab[data-id="${tabId}"]`).classList.add('active');
}

// Zmodyfikuj funkcję renderTabs
function renderTabs() {
    const tabsContainer = document.getElementById('tabs');
    tabsContainer.innerHTML = '';
    
    tabs.forEach(tab => {
        const tabElement = document.createElement('div');
        tabElement.className = 'tab';
        tabElement.setAttribute('data-id', tab.id);
        tabElement.onclick = () => switchToTab(tab.id); // Dodajemy to
        
        const tabText = document.createElement('span');
        tabText.textContent = tab.name;
        
        const closeButton = document.createElement('button');
        closeButton.textContent = '×';
        closeButton.className = 'close-tab';
        closeButton.onclick = (e) => {
            e.stopPropagation(); // Zapobiegamy propagacji zdarzenia do rodzica
            closeTab(tab.id);
        };
        
        tabElement.appendChild(tabText);
        tabElement.appendChild(closeButton);
        tabsContainer.appendChild(tabElement);
    });
}

// Dodaj nową funkcję closeTab
function closeTab(tabId) {
    const tabIndex = tabs.findIndex(t => t.id === tabId);
    if (tabIndex === -1) return;

    // Usu�� zakładkę z tablicy
    tabs.splice(tabIndex, 1);

    // Usuń odpowiadający iframe
    const iframe = document.getElementById(`iframe-${tabId}`);
    if (iframe) {
        iframe.remove();
    }

    // Jeśli zamykamy aktywną zakładkę, przełącz na inną
    const activeTab = document.querySelector('.tab.active');
    if (activeTab && activeTab.getAttribute('data-id') == tabId) {
        if (tabs.length > 0) {
            switchToTab(tabs[0].id);
        } else {
            // Jeśli nie ma więcej zakładek, możesz np. pokazać pusty kontener
            const iframeContainer = document.getElementById('iframe-container');
            iframeContainer.innerHTML = '<p></p>';
        }
    }

    // Przerysuj zakładki
    renderTabs();
}

// Zmodyfikuj funkcję changeDictionary
function changeDictionary() {
    const select = document.getElementById('dictionary-select');
    const checkbox = document.getElementById('default-dictionary-checkbox');
    const selectedUrl = select.value;
    
    if (selectedUrl === 'add_new') {
        addNewDictionary();
    } else if (selectedUrl === 'remove_dictionary') {
        removeDictionary();
    } else {
        // Dodaj parametr dark=1 do URL jeśli tryb ciemny jest aktywny
        const isDarkMode = document.body.classList.contains('dark-mode');
        const urlWithDarkMode = isDarkMode ? 
            `${selectedUrl}${selectedUrl.includes('?') ? '&' : '?'}dark=1` : 
            selectedUrl;
            
        addNewTab();
        // Aktualizuj stan checkboxa
        const defaultDictionary = localStorage.getItem('defaultDictionary');
        checkbox.checked = (defaultDictionary === selectedUrl);
    }
}

// Dodaj tę nową funkcję
function updateDefaultDictionaryCheckbox() {
    const select = document.getElementById('dictionary-select');
    const checkbox = document.getElementById('default-dictionary-checkbox');
    const defaultDictionary = localStorage.getItem('defaultDictionary');
    checkbox.checked = (defaultDictionary === select.value);
}

// Zmodyfikuj funkcję initializeFirstTab
function initializeFirstTab() {
    const dictionaryUrl = loadDefaultDictionary();
    const dictionarySelect = document.getElementById('dictionary-select');
    const selectedOption = dictionarySelect.options[dictionarySelect.selectedIndex];
    
    const firstTab = {
        id: Date.now(),
        name: selectedOption.text,
        url: dictionaryUrl
    };
    
    tabs.push(firstTab);
    renderTabs();
    createIframe(firstTab);
    switchToTab(firstTab.id);
    updateDefaultDictionaryCheckbox();
}

// Dodaj nasłuchiwanie na zmiany w select
document.getElementById('dictionary-select').addEventListener('change', updateDefaultDictionaryCheckbox);

// Dodaj tę funkcję, aby inicjalizować pierwszą zakładkę przy ładowaniu strony
function initializeFirstTab() {
    const dictionaryUrl = loadDefaultDictionary();
    const dictionarySelect = document.getElementById('dictionary-select');
    const selectedOption = dictionarySelect.options[dictionarySelect.selectedIndex];
    
    const firstTab = {
        id: Date.now(),
        name: selectedOption.text,
        url: dictionaryUrl
    };
    
    tabs.push(firstTab);
    renderTabs();
    createIframe(firstTab);
    switchToTab(firstTab.id);
    updateDefaultDictionaryCheckbox();
}

// Zmodyfikuj funkcję onYouTubeIframeAPIReady
function onYouTubeIframeAPIReady() {
    console.log("API YouTube IFrame załadowane.");
    loadPlaylistsFromLocalStorage();
    loadTrimTimesFromLocalStorage();
    loadWatchedVideosFromLocalStorage();
    initializeWatchedVideos();
    initializeDefaultTrimTimes();
    createPlaylistButtons();
    loadPlaylist(playlists[0].id);
    updateWatchedCount();
    initializeAddToWatchedButton();
    initializeFirstTab();
    initializeColumnResizer();
    
    // Dodaj to wywołanie
    const ratio = loadDefaultColumnRatio();
    applyColumnRatio(ratio);
    
    setTimeout(autosizePlayer, 100);
}

function initializeColumnResizer() {
    const divider = document.querySelector('.column-divider');
    const leftColumn = document.querySelector('.left-column');
    const rightColumn = document.querySelector('.right-column');
    let isResizing = false;

    // Dodajemy wywołanie funkcji pokazującej tooltip
    showColumnDividerTooltip();

    divider.addEventListener('mousedown', startResizing);

    function startResizing(e) {
        console.log('Started resizing');
        isResizing = true;
        document.body.style.cursor = 'col-resize';
        document.addEventListener('mousemove', resize);
        document.addEventListener('mouseup', stopResizing);
        e.preventDefault();
    }

    function resize(e) {
        if (!isResizing) return;

        const containerWidth = document.querySelector('.main-container').offsetWidth;
        const mouseX = e.clientX;
        const containerLeft = document.querySelector('.main-container').getBoundingClientRect().left;
        const position = mouseX - containerLeft;

        // Oblicz procenty
        const leftPercent = (position / containerWidth) * 100;
        const rightPercent = 100 - leftPercent;

        // Ustaw minimalne szerokości (np. 20%)
        if (leftPercent < 20 || leftPercent > 80) return;

        leftColumn.style.width = leftPercent + '%';
        rightColumn.style.width = (rightPercent - 0.4) + '%';

        // Dostosuj szerokość iframe'a i jego kontenera
        const iframeContainer = document.querySelector('.iframe-container');
        const tabs = document.querySelectorAll('iframe');
        if (iframeContainer) {
            iframeContainer.style.width = '100%';
            tabs.forEach(iframe => {
                iframe.style.width = '100%';
            });
        }

        // Aktualizuj rozmiar playera YouTube
        autosizePlayer();
    }

    function stopResizing() {
        isResizing = false;
        document.body.style.cursor = 'default';
        document.removeEventListener('mousemove', resize);
        document.removeEventListener('mouseup', stopResizing);
        
        // Dodaj zapisywanie aktualnego podziału
        const containerWidth = document.querySelector('.main-container').offsetWidth;
        const leftColumn = document.querySelector('.left-column');
        const leftWidth = (leftColumn.offsetWidth / containerWidth) * 100;
        saveDefaultColumnRatio(Math.round(leftWidth));
    }
}

// Dodaj wywołanie funkcji przy ładowaniu strony
window.addEventListener('load', initializeColumnResizer);

function openSettings() {
    let settingsForm = document.getElementById('review-settings-form');
    let overlay = document.getElementById('settings-overlay');
    
    if (settingsForm) {
        settingsForm.remove();
        overlay.remove();
        return;
    }

    overlay = document.createElement('div');
    overlay.className = 'settings-overlay';
    overlay.id = 'settings-overlay';
    
    const bbcPlaylistEnabled = localStorage.getItem('bbcPlaylistEnabled') === 'true';
    const currentRatio = loadDefaultColumnRatio();
    
    settingsForm = document.createElement('div');
    settingsForm.id = 'review-settings-form';
    settingsForm.className = 'settings-form';
    settingsForm.innerHTML = `
        <div class="settings-header">
            <h3>Settings</h3>
            <button onclick="closeSettings()" class="close-button">×</button>
        </div>
        <div class="settings-group">
            <label class="checkbox-label">
                <input type="checkbox" id="bbcPlaylistCheckbox" ${bbcPlaylistEnabled ? 'checked' : ''}>
                BBC learning English playlists
            </label>
        </div>
        <div class="settings-group">
            <label>Column divider ratio:</label>
            <div class="ratio-control">
                <input type="range" id="columnRatioSlider" 
                    min="20" max="80" value="${currentRatio}" 
                    class="ratio-slider">
                <span id="ratioValue">${currentRatio}%</span>
            </div>
        </div>
    `;

    document.body.appendChild(overlay);
    document.body.appendChild(settingsForm);
    
    // Event listener dla checkboxa BBC
    const checkbox = settingsForm.querySelector('#bbcPlaylistCheckbox');
    checkbox.addEventListener('change', function() {
        localStorage.setItem('bbcPlaylistEnabled', this.checked);
        updatePlaylistVisibility();
    });
    
    // Event listener dla suwaka
    const slider = settingsForm.querySelector('#columnRatioSlider');
    const ratioValue = settingsForm.querySelector('#ratioValue');
    slider.addEventListener('input', function() {
        ratioValue.textContent = this.value + '%';
        saveDefaultColumnRatio(this.value);
    });
    
    overlay.addEventListener('click', closeSettings);
}

// Dodaj wywołanie przy inicjalizacji
window.addEventListener('load', function() {
    const ratio = loadDefaultColumnRatio();
    applyColumnRatio(ratio);
});

// Dodaj funkcję do zapisywania i wczytywania domyślnego podziału
function saveDefaultColumnRatio(ratio) {
    localStorage.setItem('defaultColumnRatio', ratio);
    applyColumnRatio(ratio);
}

function loadDefaultColumnRatio() {
    return localStorage.getItem('defaultColumnRatio') || 44;
}

function applyColumnRatio(ratio) {
    // Nie stosuj podziału dla małych ekranów
    if (window.innerWidth  <= 520) {
        return;
    }
    
    const leftColumn = document.querySelector('.left-column');
    const rightColumn = document.querySelector('.right-column');
    
    leftColumn.style.width = ratio + '%';
    rightColumn.style.width = (100 - ratio - 0.4) + '%';
    
    // Dostosuj szerokość iframe'a i jego kontenera
    const iframeContainer = document.querySelector('.iframe-container');
    const iframes = document.querySelectorAll('iframe');
    if (iframeContainer) {
        iframeContainer.style.width = '100%';
        iframes.forEach(iframe => {
            iframe.style.width = '100%';
        });
    }
    
    // Aktualizuj rozmiar playera YouTube
    autosizePlayer();
}

// Funkcja do aktualizacji widoczności playlist
function updatePlaylistVisibility() {
    const bbcPlaylistEnabled = localStorage.getItem('bbcPlaylistEnabled') === 'true';
    
    if (!bbcPlaylistEnabled) {
        // Jeśli BBC jest wyłączone, usuwamy TYLKO domyślne playlisty BBC, zachowując custom playlisty
        playlists = playlists.filter(playlist => 
            !defaultPlaylists.some(defaultPlaylist => defaultPlaylist.id === playlist.id)
        );
    } else {
        // Jeśli BBC jest włączone, dodajemy domyślne playlisty BBC
        defaultPlaylists.forEach(bbcPlaylist => {
            if (!playlists.some(p => p.id === bbcPlaylist.id)) {
                playlists.push(bbcPlaylist);
            }
        });
    }

    // Zapisz stan playlist w localStorage
    savePlaylistsToLocalStorage();
    
    // Aktualizuj przyciski playlist
    createPlaylistButtons();
    
    // Jeśli nie ma aktywnej playlisty lub aktywna playlista została usunięta,
    // załaduj pierwszą dostępną playlistę
    if (!playlists.some(p => p.id === currentPlaylistId)) {
        if (playlists.length > 0) {
            loadPlaylist(playlists[0].id);
        }
    }
}

// Dodaj wywołanie przy starcie aplikacji
window.addEventListener('load', function() {
    // Wczytaj stan z localStorage
    const bbcPlaylistEnabled = localStorage.getItem('bbcPlaylistEnabled');
    // Jeśli nie ma zapisanego stanu, ustaw domyślnie na true
    if (bbcPlaylistEnabled === null) {
        localStorage.setItem('bbcPlaylistEnabled', 'true');
    }
    updatePlaylistVisibility();
});

function closeSettings(){
    const settingsForm = document.getElementById('review-settings-form');
    const overlay = document.getElementById('settings-overlay');
    if (settingsForm) settingsForm.remove();
    if (overlay) overlay.remove();
}

function extractPlaylistId(link) {
    // Obsługa różnych formatów linków do playlist YouTube
    const patterns = [
        /[?&]list=([^&]+)/,  // Format: ?list= lub &list=
        /youtu.be\/.*[?&]list=([^&]+)/, // Format: youtu.be z list=
        /youtube.com\/playlist\?list=([^&]+)/ // Format: bezpośredni link do playlisty
    ];

    for (let pattern of patterns) {
        const match = link.match(pattern);
        if (match && match[1]) {
            return match[1];
        }
    }
    return null;
}

// Zmodyfikowana funkcja debounce
function debounce(func, wait) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            func.apply(this, args);
        }, wait);
    };
}

// Zmodyfikowana funkcja sprawdzająca orientację
function checkOrientation() {
    console.log('checkOrientation wywołane'); // Dodajemy log do debugowania
    
    if (isPortrait) {
        console.log('Orientacja pionowa');
        //document.body.classList.add('index-dark-mode');
    } else if (isLandscape) {
        console.log('Orientacja pozioma');
      //  document.body.classList.remove('index-dark-mode');
    }
}


// Tworzymy zdebounce'owaną wersję funkcji
const debouncedCheckOrientation = debounce(checkOrientation, 250);

// Dodajemy bezpośrednie nasłuchiwanie na zdarzenie resize
window.addEventListener('resize', function() {
    console.log('Zdarzenie resize wywołane'); // Dodajemy log do debugowania
    debouncedCheckOrientation();
});

// Sprawdzamy orientację przy załadowaniu strony
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOMContentLoaded wywołane'); // Dodajemy log do debugowania
    checkOrientation();
});

// Dodatkowe sprawdzenie po pełnym załadowaniu strony
window.addEventListener('load', function() {
    console.log('Load wywołane'); // Dodajemy log do debugowania
    checkOrientation();
});
/*
// Alternatywne podejście - użycie matchMedia
const mediaQuery = window.matchMedia("(orientation: portrait)");

function handleOrientationChange(e) {
    console.log('Zmiana orientacji wykryta');
    if (e.matches) {
        console.log('Orientacja pionowa');
        document.body.classList.add('index-dark-mode');
    } else {
        console.log('Orientacja pozioma');
        document.body.classList.remove('index-dark-mode');
    }
}

// Dodaj nasłuchiwanie na zmiany orientacji
mediaQuery.addListener(handleOrientationChange);

// Sprawdź orientację przy starcie
handleOrientationChange(mediaQuery);
*/
</script>
<script>// Funkcja do rysowania wykresu dla systemu Leitnera
function drawLeitnerBoxesChart() {
    const algorithm = localStorage.getItem('reviewAlgorithm') || 'standard';
    if (algorithm !== 'leitner') return;

    let canvas = document.getElementById('leitnerBoxesChart');
    if (!canvas) {
        const statsSection = document.getElementById('stats');
        canvas = document.createElement('canvas');
        canvas.id = 'leitnerBoxesChart';
        canvas.width = 600;  // Zwiększamy szerokość z 300 na 600
        canvas.height = 200;
        statsSection.appendChild(canvas);
    }

    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // Oblicz statystyki pudełek Leitnera
    const boxStats = {
        box1: 0, box2: 0, box3: 0, box4: 0, box5: 0
    };

    // Zliczanie fiszek w pudełkach
    flashcards.forEach(flashcard => {
        if (flashcard.leitnerBox) {
            boxStats[`box${flashcard.leitnerBox}`]++;
        } else {
            // Jeśli fiszka nie ma przypisanego pudełka, przypisz ją do pierwszego
            boxStats.box1++;
        }
    });

    // Kolory dla pudełek
    const boxColors = {
        box1: '#dc3545',  // czerwony
        box2: '#fd7e14',  // pomarańczowy
        box3: '#ffc107',  // żółty
        box4: '#28a745',  // zielony
        box5: '#17a2b8'   // niebieski
    };

    // Wyczyść canvas
    ctx.clearRect(0, 0, width, height);

    // Dodaj sprawdzenie trybu ciemnego przed ustawieniem koloru tekstu
    const isDarkMode = document.body.classList.contains('dark-mode');
    const textColor = isDarkMode ? '#e0e0e0' : '#333';
    const backgroundColor = isDarkMode ? '#2d2d2d' : '#f8f9fa';

    // Ustaw tło
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(0, 0, width, height);

    // Zmień kolor tekstu dla tytułu
    ctx.fillStyle = textColor;
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    const total = Object.values(boxStats).reduce((a, b) => a + b, 0);
    ctx.fillText(`${translations[currentLanguage].leitnerBoxesStats || 'Leitner Boxes Statistics'} (Total: ${total})`, width / 2, 30);

    const barWidth = width / 8;  // Zmniejszamy z 6 na 8 aby zwiększyć odstępy
    const intervals = [1, 3, 7, 14, 30];

    // Funkcja do rysowania słupka
    function drawBar(x, count, color, label, interval) {
        const total = Object.values(boxStats).reduce((a, b) => a + b, 0);
        const barHeight = total > 0 ? (count / total) * (height - 120) : 0;
        const y = height - barHeight - 40;

        // Rysuj słupek
        ctx.fillStyle = color;
        ctx.fillRect(x, y, barWidth - 20, barHeight);

        // Zmień efekt 3D na cień w kolorze tła
        ctx.fillStyle = isDarkMode ? 'rgba(45, 45, 45, 0.3)' : 'rgba(248, 249, 250, 0.3)';
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 10, y - 10);
        ctx.lineTo(x + barWidth - 10, y - 10);
        ctx.lineTo(x + barWidth - 20, y);
        ctx.closePath();
        ctx.fill();

        // Dodaj etykietę
        ctx.fillStyle = textColor; // Zmieniony kolor tekstu
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Box ${label}`, x + (barWidth - 20) / 2, height - 20);
        ctx.fillText(`${interval} days`, x + (barWidth - 20) / 2, height - 5);

        // Dodaj liczbę fiszek
        ctx.fillStyle = textColor; // Zmieniony kolor tekstu
        ctx.font = 'bold 16px Arial';
        ctx.fillText(count, x + (barWidth - 20) / 2, y - 25);
    }

    // Rysuj słupki dla każdego pudełka z większymi odstępami
    Object.entries(boxStats).forEach(([box, count], index) => {
        drawBar(
            width / 6 + index * (barWidth + 30),  // Dodajemy +30 dla większego odstępu
            count,
            boxColors[box],
            index + 1,
            intervals[index]
        );
    });
}

// Dodaj funkcję do rysowania wykresu dla SuperMemo
function drawSuperMemoChart() {
    const algorithm = localStorage.getItem('reviewAlgorithm') || 'standard';
    if (algorithm !== 'supermemo') return;

    let canvas = document.getElementById('superMemoChart');
    if (!canvas) {
        const statsSection = document.getElementById('stats');
        canvas = document.createElement('canvas');
        canvas.id = 'superMemoChart';
        canvas.width = 600;  // Zwiększamy szerokość z 300 na 600
        canvas.height = 200;
        statsSection.appendChild(canvas);
    }

    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // Przedziały EF
    const efRanges = {
        veryHard: { min: 1.3, max: 1.7, color: '#dc3545', count: 0 },  // czerwony
        hard: { min: 1.7, max: 2.1, color: '#fd7e14', count: 0 },      // pomarańczowy
        medium: { min: 2.1, max: 2.5, color: '#ffc107', count: 0 },    // żółty
        easy: { min: 2.5, max: 2.9, color: '#28a745', count: 0 },      // zielony
        veryEasy: { min: 2.9, max: 3.3, color: '#17a2b8', count: 0 }   // niebieski
    };

    // Zliczanie fiszek w przedziałach EF
    flashcards.forEach(flashcard => {
        if (flashcard.easinessFactor) {
            const ef = flashcard.easinessFactor;
            if (ef >= 1.3 && ef < 1.7) efRanges.veryHard.count++;
            else if (ef >= 1.7 && ef < 2.1) efRanges.hard.count++;
            else if (ef >= 2.1 && ef < 2.5) efRanges.medium.count++;
            else if (ef >= 2.5 && ef < 2.9) efRanges.easy.count++;
            else if (ef >= 2.9) efRanges.veryEasy.count++;
        }
    });

    // Wyczyść canvas
    ctx.clearRect(0, 0, width, height);

    // Dodaj sprawdzenie trybu ciemnego przed ustawieniem koloru tekstu
    const isDarkMode = document.body.classList.contains('dark-mode');
    const textColor = isDarkMode ? '#e0e0e0' : '#333';
    const backgroundColor = isDarkMode ? '#2d2d2d' : '#f8f9fa';

    // Ustaw tło
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(0, 0, width, height);

    // Oblicz całkowitą liczbę fiszek
    const total = Object.values(efRanges).reduce((sum, r) => sum + r.count, 0);

    // Zmień kolor tekstu dla tytułu
    ctx.fillStyle = textColor;
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`SuperMemo Easiness Factor Distribution (Total: ${total})`, width / 2, 30);

    const barWidth = width / 6;

    // Funkcja do rysowania słupka
    function drawBar(x, range, label) {
        const total = Object.values(efRanges).reduce((sum, r) => sum + r.count, 0);
        const barHeight = total > 0 ? (range.count / total) * (height - 120) : 0;
        const y = height - barHeight - 40;

        // Rysuj słupek
        ctx.fillStyle = range.color;
        ctx.fillRect(x, y, barWidth - 20, barHeight);

        // Zmień efekt 3D na cień w kolorze tła
        ctx.fillStyle = isDarkMode ? 'rgba(45, 45, 45, 0.3)' : 'rgba(248, 249, 250, 0.3)';
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 10, y - 10);
        ctx.lineTo(x + barWidth - 10, y - 10);
        ctx.lineTo(x + barWidth - 20, y);
        ctx.closePath();
        ctx.fill();

        // Dodaj etykietę
        ctx.fillStyle = textColor; // Zmieniony kolor tekstu
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(label, x + (barWidth - 20) / 2, height - 20);
        ctx.fillText(`EF: ${range.min}-${range.max}`, x + (barWidth - 20) / 2, height - 5);

        // Dodaj liczbę fiszek
        ctx.fillStyle = textColor; // Zmieniony kolor tekstu
        ctx.font = 'bold 16px Arial';
        ctx.fillText(range.count, x + (barWidth - 20) / 2, y - 25);
    }

    // Rysuj słupki dla każdego przedziału EF
    let x = width / 8;
    drawBar(x, efRanges.veryHard, 'Very Hard');
    x += barWidth;
    drawBar(x, efRanges.hard, 'Hard');
    x += barWidth;
    drawBar(x, efRanges.medium, 'Medium');
    x += barWidth;
    drawBar(x, efRanges.easy, 'Easy');
    x += barWidth;
    drawBar(x, efRanges.veryEasy, 'Very Easy');
}

// Dodaj nową funkcję do rysowania wykresu interwałów SuperMemo
function drawSuperMemoIntervalsChart() {
    const algorithm = localStorage.getItem('reviewAlgorithm') || 'standard';
    if (algorithm !== 'supermemo') return;

    let canvas = document.getElementById('superMemoIntervalsChart');
    if (!canvas) {
        const statsSection = document.getElementById('stats');
        canvas = document.createElement('canvas');
        canvas.id = 'superMemoIntervalsChart';
        canvas.width = 600;
        canvas.height = 200;
        statsSection.appendChild(canvas);
    }

    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // Przedziały interwałów (w dniach) - dodajemy nowy przedział dla 0 dni
    const intervalRanges = {
        newCards: { min: 0, max: 0, color: '#dc3545', count: 0, label: '0 days' },      // Nowy przedział
        shortTerm: { min: 1, max: 7, color: '#fd7e14', count: 0, label: '1-7 days' },   // Zmieniono kolor
        mediumTerm: { min: 8, max: 30, color: '#ffc107', count: 0, label: '8-30 days' },
        longTerm: { min: 31, max: 90, color: '#28a745', count: 0, label: '31-90 days' },
        veryLongTerm: { min: 91, max: 365, color: '#17a2b8', count: 0, label: '91-365 days' }
    };

    // Zliczanie fiszek według interwałów
    flashcards.forEach(flashcard => {
        if (flashcard.interval === 0 && flashcard.lastReviewed) {
            intervalRanges.newCards.count++;
        } else if (flashcard.interval) {
            const interval = flashcard.interval;
            if (interval <= 7) intervalRanges.shortTerm.count++;
            else if (interval <= 30) intervalRanges.mediumTerm.count++;
            else if (interval <= 90) intervalRanges.longTerm.count++;
            else intervalRanges.veryLongTerm.count++;
        }
    });

    // Wyczyść canvas
    ctx.clearRect(0, 0, width, height);

    // Dodaj sprawdzenie trybu ciemnego przed ustawieniem koloru tekstu
    const isDarkMode = document.body.classList.contains('dark-mode');
    const textColor = isDarkMode ? '#e0e0e0' : '#333';
    const backgroundColor = isDarkMode ? '#2d2d2d' : '#f8f9fa';

    // Ustaw tło
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(0, 0, width, height);

    // Oblicz całkowitą liczbę fiszek
    const total = Object.values(intervalRanges).reduce((sum, r) => sum + r.count, 0);

    // Zmień kolor tekstu dla tytułu
    ctx.fillStyle = textColor;
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`SuperMemo Review Intervals Distribution (Total: ${total})`, width / 2, 30);

    const barWidth = width / 6;

    // Funkcja do rysowania słupka
    function drawBar(x, range, label) {
        const barHeight = total > 0 ? (range.count / total) * (height - 120) : 0;
        const y = height - barHeight - 40;

        // Rysuj słupek
        ctx.fillStyle = range.color;
        ctx.fillRect(x, y, barWidth - 20, barHeight);

        // Zmień efekt 3D na cień w kolorze tła
        ctx.fillStyle = isDarkMode ? 'rgba(45, 45, 45, 0.3)' : 'rgba(248, 249, 250, 0.3)';
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 10, y - 10);
        ctx.lineTo(x + barWidth - 10, y - 10);
        ctx.lineTo(x + barWidth - 20, y);
        ctx.closePath();
        ctx.fill();

        // Dodaj etykietę
        ctx.fillStyle = textColor; // Zmieniony kolor tekstu
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(label, x + (barWidth - 20) / 2, height - 20);
        ctx.fillText(`${range.count} cards`, x + (barWidth - 20) / 2, height - 5);

        // Dodaj liczbę fiszek
        if (range.count > 0) {
            ctx.fillStyle = textColor; // Zmieniony kolor tekstu
            ctx.font = 'bold 16px Arial';
            ctx.fillText(range.count, x + (barWidth - 20) / 2, y - 25);
        }
    }

    // Rysuj słupki dla każdego przedziału interwałów
    let x = width / 7; // Zmniejszamy odstęp, bo mamy więcej słupków
    Object.entries(intervalRanges).forEach(([key, range]) => {
        drawBar(x, range, range.label);
        x += barWidth;
    });
}
// Sprawdź czy zmienne istnieją w globalnym zakresie
if (typeof flashcards === 'undefined') {
    console.error('flashcards is not defined. Make sure reps.js is loaded first.');
}

if (typeof translations === 'undefined') {
    console.error('translations is not defined. Make sure reps.js is loaded first.');
}

if (typeof currentLanguage === 'undefined') {
    console.error('currentLanguage is not defined. Make sure reps.js is loaded first.');
}

// Usuń duplikat translations, ponieważ jest już zdefiniowany w reps.js

// Modyfikacja funkcji updateStats nie jest potrzebna, ponieważ jest już zdefiniowana w reps.js
// Funkcja do aktualizacji statystyk
function updateStats() {
    const algorithm = localStorage.getItem('reviewAlgorithm') || 'standard';
    let totalFlashcards = flashcards.length;
    //let knownFlashcards = countKnownFlashcards();
    let masteredLast7Days = 0;
    //let masteredLast7Days = countMasteredLast7Days();
  
     // Oblicz stan znajomości w zależności od algorytmu
     let knownCards = 0;
     let totalReviewedCards = 0;
     const total = flashcards.length;
  
     switch (algorithm) {
         case 'supermemo':
             // Dla SuperMemo - karty z EF > 2 i co najmniej 5 powtórzeniami
             knownCards = flashcards.filter(f => 
                 f.easinessFactor > 2 && f.repetitions >= 5
             ).length;
             totalReviewedCards = flashcards.filter(f => f.lastReviewed).length;
             break;
             
         case 'leitner':
             // Dla Leitnera - karty w pudełku 5
             knownCards = flashcards.filter(f => 
                 f.leitnerBox && f.leitnerBox >= 5
             ).length;
             totalReviewedCards = flashcards.filter(f => f.lastReviewed).length;
             break;
             
         default:
             // Dla standardowego - karty ze streak >= 5 i difficulty 'easy'
             knownCards = flashcards.filter(f => 
                 f.streak >= 5 
             ).length;
             totalReviewedCards = flashcards.filter(f => f.lastReviewed).length;
     }
  
    
    const statsSection = document.getElementById('stats');
    statsSection.innerHTML = generateStatsHTML();
    
    document.getElementById('totalFlashcards').textContent = totalFlashcards;
    
    // Oblicz procent znanych fiszek
    let knownPercentage = totalFlashcards > 0 ? (knownCards / totalReviewedCards * 100).toFixed(1) : 0;
    document.getElementById('knownFlashcards').textContent = `${knownPercentage}%`;
  
        // Oblicz liczbę opanowanych w ostatnich 7 dniach
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        
        
        switch (algorithm) {
            case 'supermemo':
                masteredLast7Days = flashcards.filter(f => 
                    f.lastReviewed && 
                    new Date(f.lastReviewed) >= sevenDaysAgo && 
                    f.easinessFactor > 2 &&
                    f.repetitions >= 5
                ).length;
                break;
                
            case 'leitner':
                masteredLast7Days = flashcards.filter(f => 
                    f.lastReviewed && 
                    new Date(f.lastReviewed) >= sevenDaysAgo && 
                    f.leitnerBox >= 5
                ).length;
                break;
                
            default:
                masteredLast7Days = flashcards.filter(f => 
                    f.lastReviewed && 
                    new Date(f.lastReviewed) >= sevenDaysAgo && 
                    f.streak >= 5
                    
                ).length;
        }
    
    document.getElementById('masteredLast7Days').textContent = masteredLast7Days;
  
   
    if (algorithm === 'leitner') {
        drawLeitnerBoxesChart();
    } else if (algorithm === 'supermemo') {
        drawSuperMemoChart();
        drawSuperMemoIntervalsChart();  // Dodaj wywołanie nowego wykresu
    } else {
        drawLearningProgressChart();
    }
  
    changeLanguage(); // Dodajemy to wywołanie, aby przetłumaczyć nowo wygenerowaną zawartość
  }


function drawLearningProgressChart() {
    console.log('Rozpoczęcie rysowania wykresu');
    const canvas = ensureCanvasExists();
    if (!canvas) {
        console.error('Nie można utworzyć lub znaleźć elementu canvas');
        return;
    }

    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const algorithm = localStorage.getItem('reviewAlgorithm') || 'standard';

    // Oblicz statystyki w zależności od algorytmu
    const newCards = flashcards.filter(f => !f.lastReviewed).length;
    
    let learningCards = 0;
    switch (algorithm) {
        case 'supermemo':
            // Dla SuperMemo - karty z 1-4 powtórzeniami
            learningCards = flashcards.filter(f => 
                f.lastReviewed && f.repetitions >= 0 && f.repetitions < 5
            ).length;
            break;
        case 'leitner':
            // Dla Leitnera - karty w pudełkach 1-4
            learningCards = flashcards.filter(f => 
                f.lastReviewed && f.leitnerBox >= 1 && f.leitnerBox <= 4
            ).length;
            break;
        default:
            // Dla standardowego - karty ze streak 1-4
            learningCards = flashcards.filter(f => 
                f.lastReviewed && f.streak >= 0 && f.streak < 5
            ).length;
    }

    // Opanowane fiszki też zależą od algorytmu
    let masteredCards = 0;
    switch (algorithm) {
        case 'supermemo':
            masteredCards = flashcards.filter( f => f.repetitions >= 5 && f.easinessFactor > 2 ).length;
            break;
        case 'leitner':
            masteredCards = flashcards.filter(f => f.leitnerBox >= 5).length;
            break;
        default:
            masteredCards = flashcards.filter(f => f.streak >= 5 ).length;
    }

    const total = flashcards.length;
    const barWidth = width / 4;

    console.log(`Statystyki: Nowe: ${newCards}, Uczone: ${learningCards}, Opanowane: ${masteredCards}`);

    // Wyczyść canvas
    ctx.clearRect(0, 0, width, height);

    // Dodaj sprawdzenie trybu ciemnego przed ustawieniem koloru tekstu
    const isDarkMode = document.body.classList.contains('dark-mode');
    const textColor = isDarkMode ? '#e0e0e0' : '#333';
    const backgroundColor = isDarkMode ? '#2d2d2d' : '#f8f9fa';
    
    // Ustaw tło
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(0, 0, width, height);
    
    // Dodaj tytuł wykresu
    ctx.fillStyle = textColor;
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(translations[currentLanguage].flashcardStatistics || 'Statystyki fiszek', width / 2, 30);

    // Funkcja do rysowania słupka
    function drawBar(x, count, color, label) {
        const barHeight = total > 0 ? (count / total) * (height - 120) : 0;
        const y = height - barHeight - 40;

        // Rysuj słupek
        ctx.fillStyle = color;
        ctx.fillRect(x, y, barWidth - 20, barHeight);

        // Zmień efekt 3D na cień w kolorze tła
        ctx.fillStyle = isDarkMode ? 'rgba(45, 45, 45, 0.3)' : 'rgba(248, 249, 250, 0.3)';
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 10, y - 10);
        ctx.lineTo(x + barWidth - 10, y - 10);
        ctx.lineTo(x + barWidth - 20, y);
        ctx.closePath();
        ctx.fill();

        // Dodaj etykietę
        ctx.fillStyle = textColor;
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(label, x + (barWidth - 20) / 2, height - 20);

        // Dodaj liczbę
        ctx.fillStyle = textColor;
        ctx.font = 'bold 16px Arial';
        ctx.fillText(count, x + (barWidth - 20) / 2, y - 25);
    }

    // Rysuj słupki
    if (total > 0) {
        drawBar(width / 8, newCards, '#4CAF50', translations[currentLanguage].newFlashcards || 'Nowe');
        drawBar(width * 3 / 8, learningCards, '#36A2EB', translations[currentLanguage].learningFlashcards || 'Uczone');
        drawBar(width * 5 / 8, masteredCards, '#4BC0C0', translations[currentLanguage].masteredFlashcards || 'Opanowane');
    } else {
        ctx.fillStyle = textColor;
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Brak danych do wyświetlenia', width / 2, height / 2);
    }

    console.log('Zakończono rysowanie wykresu');
}

</script>
<script>// Definicje tłumaczeń
const translations = {
    en: {
        review: "Review",
        browseFlashcards: "Browse Flashcards",
        addFlashcard: "Add Flashcard",
        statistics: "Statistics",
        exportToFile: "Export to File",
        importFromFile: "Import from File",
        repetitions: "Repetitions",
        myPlaylists: "My Playlists",
        addNewFlashcard: "Add New Flashcard",
        wordPhrase: "Word / Phrase",
        contextExample: "Context / Example",
        translation: "Translation",
        imageLink: "Image link (http)",
        audioLink: "Audio link (http)",
        addFlashcardButton: "Add Flashcard",
        yourFlashcards: "Your Flashcards",
        no: "No.",
        known: "Mastered",
        media: "Media",
        audio: "Audio",
        actions: "Actions",
        info: "Info",
        howDoReviewsWork: "How do reviews work?",
        reviewExplanation: "Our system uses a spaced repetition method to help you effectively memorize words:",
        firstRecall: "After 1st correct recall: next review in 2 days",
        secondRecall: "After 2nd correct recall: next review in 4 days",
        thirdRecall: "After 3rd correct recall: next review in 8 days",
        fourthRecall: "After 4th correct recall: next review in 16 days",
        andSoOn: "and so on...",
        reviewTip: "If you don't remember a word, it will return to the beginning of the cycle. Regular reviews are the key to success!",
        close: "Close",
        totalFlashcards: "Total number of flashcards:",
        numberOfReviews: "Number of reviews:",
        currentKnowledgeState: "Current knowledge state of all flashcards",
        masteredLast7Days: "Number mastered in the last 7 days:",
        masteredTooltip: "This is the number of flashcards that:\n1. Have been reviewed correctly at least 5 times (considered mastered).\n2. Their last review was within the last 7 days.",
        showTranslation: "Show translation",
        iKnow: "I know",
        iDontKnow: "I don't know",
        endOfReview: "End of review!",
        checkNewFlashcards: "Check new flashcards",
        repeatUnknown: "Repeat unknown only",
        repeatAll: "Repeat all",
        flashcardAdded: "Flashcard has been added!",
        edit: "Edit",
        delete: "Delete",
        save: "Save",
        cancel: "Cancel",
        noFlashcardsToReview: "No flashcards to review today!",
        noNewFlashcardsToReview: "No new flashcards, add some!",
        nextReviewAvailable: "Next review will be available:",
        flashcardCategories: "Flashcard categories:",
        newFlashcards: "New",
        newFlashcardsDescription: "(green): Flashcards that haven't been reviewed yet or weren't remembered.",
        learningFlashcards: "Learning",
        learningFlashcardsDescription: "(blue): Flashcards that were correctly reviewed 1 to 4 times.",
        masteredFlashcards: "Mastered",
        masteredFlashcardsDescription: "(turquoise): Flashcards that were correctly reviewed 5 or more times.",
        currentKnowledgeStateTooltip: "Number of mastered flashcards to the number of flashcards in learning mode",
        masteredLast7DaysTooltip: "This is the number of flashcards that:\n1. Have been reviewed correctly at least 5 times (considered mastered).\n2. Their last review was within the last 7 days.",
        flashcardStatistics: "Flashcard Statistics",
        deleteAll: "Delete All",
        confirmDeleteAll: "Delete All Flashcards",
        confirmDeleteAllMessage: "Are you sure you want to delete all flashcards? This action cannot be undone.",
        goBack: "Go back to previous flashcard",
        yes: "Yes",
        no2: "No",
        dictionary: "Dictionary",
        settings: "Settings",
        openSettings: "Open settings",
        reviewSettings: "Review Settings",
        ok: "OK",
        difficulty: "Difficulty",
        easy: "Easy",
        medium: "Medium",
        hard: "Hard",
        veryHard: "Very Hard",
        reviewMode: "Review Mode",
        allFlashcards: "All Flashcards",
        dueToday: "Due Today",
        newFlashcardsOnly: "Add 5 New Cards",
        hardFlashcardsOnly: "Hard Cards Only",
        randomFlashcards: "Random Selection",
        selectMode: "Select review mode",
        startReview: "Start Review",
        numberOfCards: "Number of cards",
        allCards: "All cards",
        customNumber: "Custom number",
        redirecting: "Returning to review mode selection...",
        completelyForgot: "Completely forgot",
        wrong: "Wrong",
        good: "Good",
        perfect: "Perfect",
        algorithmSettings: "Algorithm Settings",
        currentAlgorithm: "Current Algorithm",
        standardAlgorithm: "Standard Algorithm",
        superMemoAlgorithm: "SuperMemo Algorithm",
        algorithmDescription: "Algorithm Description",
        standardDescription: "Uses difficulty levels (easy, medium, hard, very hard) and streak-based intervals. The interval between reviews increases with each correct answer (2, 4, 8, 16 days) and resets when a mistake is made. Streak is the number of consecutive correct answers - it determines the next interval.",
        superMemoDescription: "Uses SM-2 algorithm (Anki version) with dynamic difficulty adjustment. Intervals are calculated based on your performance (e.g., 1, 6, 14, 30 days).",
        saveSettings: "Save Settings",
        leitnerAlgorithm: "Leitner System",
        leitnerDescription: "Uses 5 boxes with fixed intervals. Cards move between boxes based on your answers (Box 1: every day, Box 2: 3 days, Box 3: 7 days, Box 4: 14 days, Box 5: 30 days).",
        leitnerBox: "Box",
        leitnerNextReview: "Next review",
        leitnerDays: "days",
        leitnerBoxDescription: "Current box: ",
        leitnerProgress: "Progress in Leitner system",
        newTodayOnly: "New Cards From Today Only",
        noNewTodayFlashcards: 'No new cards reviewed today, add some!',
        startOverTooltip: "Completely forgot",
        algorithmNote: "The exact number of days is determined by the selected algorithm in settings (three dots)",
        dueTodayDescription: "Due Today - Scheduled reviews according to the selected learning algorithm.",
        newFlashcardsDescription2: "Add 5 New Cards - Add 5 new flashcards to your learning pool. Choose your own learning pace, you can select a different amount via 'Number of cards' (on average, a person can learn 8/day).",
        newTodayDescription: "New Today Only - Repeatedly review only flashcards added today.",
        hardFlashcardsDescription2: "Hard Cards Only - Review only difficult flashcards that have already been reviewed, starting from the beginning of the deck.",
        randomFlashcardsDescription: "Random Selection - Review all flashcards that have already been reviewed, starting from the beginning of the deck.",
        reviewModes: "Review modes:",
        numberOfCardsDescription: "Number of cards - Number of cards to display in one review session. For 'Show 5 New Cards' changes the default amount from 5 to selected (10, 20, custom).",
        moreInfo: "More information",
        gradeButtonsOption: "Grade buttons",
        fourButtons: "4 buttons",
        sixButtons: "6 buttons",
        sync: "Sync",
        syncInProgress: "Syncing...",
        syncSuccess: "Sync completed",
        syncError: "Sync failed",
        pushbulletSetup: "Pushbullet Setup",
        enterApiKey: "Enter your Pushbullet API key:",
        connect: "Connect",
        cancel: "Cancel",
        syncEnabled: "Sync enabled",
        syncDisabled: "Sync disabled",
        apiKeyLimit: "(Free account: Limited to 500 pushes per month, which should be sufficient for daily synchronization of 100 reviewed flashcards)",
        inactivityTimeout: "Stop sync after inactivity (minutes):",
        syncDescription: "Synchronization allows you to review flashcards on two devices.",
        confirmDelete: "Delete Flashcard",
        confirmDeleteMessage: "Are you sure you want to delete this flashcard?",
        syncDeleteWarning: "Note: If you are using Synchronization, to save the current flashcard table (after deletion) on the server, you must also delete all notes on the server. Settings -> Delete all Notes. Then, press the Sync button to save the current flashcards from the table to the server.",
        enableSyncCheck: "Enable Sync check on start",
        newSyncAvailable: "New data available, starting sync...",
        syncButtonTooltip: "Click to get updated flashcards from the server or after learning to save changes to the server",
        removeKey: "Remove API key",
        confirmRemoveKey: "Are you sure you want to remove the API key? This will disable synchronization.",
        apiKeyRemoved: "API key has been removed",
        exportToServer: "Enable Save button (useful if free 500 pushes is not enough)",
        exportToServerTooltip: "If free 500 pushes limit is not sufficient, don't use Sync, use Save instead, then every time Import file manually",
        saveTooltip: "Save your flashcards to server",
        savingInProgress: "Saving...",
        saveSuccess: "Flashcards saved successfully",
        saveError: "Error saving flashcards",
        downloadSave: "Download save file",
        enableAutoSave: "Enable Save file during Sync (auto export to server)",
        enableAutoSync: "Enable automatic synchronization in time",
        enableSyncAfterReview: "Enable Sync after Review",
        numberOfNewCards: "Number of new cards:",
        reviewModesVisibility: "Show review modes:",
        showExamples: "Show examples",
    },
    pl: {
        review: "Powtórki",
        browseFlashcards: "Przeglądaj fiszki",
        addFlashcard: "Dodaj fiszkę",
        statistics: "Statystyki",
        exportToFile: "Eksportuj do pliku",
        importFromFile: "Importuj z pliku",
        repetitions: "Powtórki",
        myPlaylists: "Moje playlisty",
        addNewFlashcard: "Dodaj nową fiszkę",
        wordPhrase: "Słowo / Fraza",
        contextExample: "Kontekst / Przykład",
        translation: "Tłumaczenie",
        imageLink: "Link do obrazu (http)",
        audioLink: "Link do audio (http)",
        addFlashcardButton: "Dodaj fiszkę",
        yourFlashcards: "Twoje fiszki",
        no: "Lp.",
        known: "Opanowane",
        media: "Media",
        audio: "Audio",
        actions: "Akcje",
        info: "Info",
        howDoReviewsWork: "Jak działają powtórki?",
        reviewExplanation: "Nasz system wykorzystuje metodę powtórek rozłożonych w czasie, aby pomóc Ci efektywnie zapamiętać słówka:",
        firstRecall: "Po 1. poprawnym zapamiętaniu: następna powtórka za 2 dni",
        secondRecall: "Po 2. poprawnym zapamiętaniu: następna powtórka za 4 dni",
        thirdRecall: "Po 3. poprawnym zapamiętaniu: następna powtórka za 8 dni",
        fourthRecall: "Po 4. poprawnym zapamiętaniu: następna powtrka za 16 dni",
        andSoOn: "itd.",
        reviewTip: "Jeśli nie zapamiętasz słówka, wróci ono do początku cyklu. Regularne powtórki to klucz do sukcesu!",
        close: "Zamknij",
        totalFlashcards: "Całkowita liczba fiszek:",
        numberOfReviews: "Liczba powtórek:",
        currentKnowledgeState: "Obecny stan znajomości wszystkich fiszek",
        masteredLast7Days: "Liczba opanowanych przez ostatnie 7 dni:",
        masteredTooltip: "To liczba fiszek, które:\n1. Zostały powtórzone co najmniej 5 razy (uznawane za opanowane).\n2. Ich ostatnie powtórzenie miało miejsce w ciągu ostatnich 7 dni.",
        showTranslation: "Pokaż tłumaczenie",
        iKnow: "Znam",
        iDontKnow: "Nie znam",
        endOfReview: "Koniec powtórki!",
        checkNewFlashcards: "Sprawdź nowe fiszki",
        repeatUnknown: "Powtórz tylko nieznane",
        repeatAll: "Powtórz wszystkie",
        flashcardAdded: "Fiszka została dodana!",
        edit: "Edytuj",
        delete: "Usuń",
        save: "Zapisz",
        cancel: "Anuluj",
        noFlashcardsToReview: "Brak fiszek do powtórki na dziś!",
        noNewFlashcardsToReview: "Brak nowych fiszek, dodaj jakieś!",
        nextReviewAvailable: "Następna powtrka będzie dostępna:",
        flashcardCategories: "Kategorie fiszek:",
        newFlashcards: "Nowe",
        newFlashcardsDescription: "(zielony): Fiszki, które nie były jeszcze powtarzane lub nie zostały zapamiętane.",
        learningFlashcards: "Uczone",
        learningFlashcardsDescription: "(niebieski): Fiszki, które były poprawnie powtórzone od 1 do 4 razy.",
        masteredFlashcards: "Opanowane",
        masteredFlashcardsDescription: "(turkusowy): Fiszki, które były poprawnie powtórzone 5 lub więcej razy.",
        currentKnowledgeStateTooltip: "Liczba fiszek opanowanych, do liczby fiszek w trybie nauki",
        masteredLast7DaysTooltip: "To liczba fiszek, które:\n1. Zostały powtórzone co najmniej 5 razy (uznawane za opanowane).\n2. Ich ostatnie powtórzenie miało miejsce w ciągu ostatnich 7 dni.",
        flashcardStatistics: "Statystyki fiszek",
        deleteAll: "Usuń wszystkie",
        confirmDeleteAll: "Usuń wszystkie fiszki",
        confirmDeleteAllMessage: "Czy na pewno chcesz usunąć wszystkie fiszki? Tej operacji nie można cofnąć.",
        goBack: "Wróć do poprzedniej fiszki",
        yes: "Tak",
        no2: "Nie",
        dictionary: "Słownik",
        settings: "Ustawienia",
        openSettings: "Otwórz ustawienia",
        reviewSettings: "Ustawienia powtórek",
        ok: "OK",
        difficulty: "Trudność",
        easy: "Łatwe",
        medium: "Średnie",
        hard: "Trudne",
        veryHard: "Bardzo trudne",
        reviewMode: "Tryb powtórki",
        allFlashcards: "Wszystkie fiszki",
        dueToday: "Na dziś",
        newFlashcardsOnly: "Dodaj 5 nowych fiszek",
        hardFlashcardsOnly: "Tylko trudne",
        randomFlashcards: "Losowy wybór",
        selectMode: "Wybierz tryb powtórki",
        startReview: "Rozpocznij powtórkę",
        numberOfCards: "Liczba fiszek",
        allCards: "Wszystkie fiszki",
        customNumber: "Własna liczba",
        redirecting: "Powrót do wyboru trybu powtórki...",
        completelyForgot: "Całkowicie zapomniałem",
        wrong: "Źle",
        good: "Dobrze",
        perfect: "Perfekcyjnie",
        algorithmSettings: "Ustawienia algorytmu",
        currentAlgorithm: "Obecny algorytm",
        standardAlgorithm: "Standardowy algorytm",
        superMemoAlgorithm: "Algorytm SuperMemo",
        algorithmDescription: "Opis algorytmu",
        standardDescription: "Używa poziomów trudności (łatwe, średnie, trudne, bardzo trudne) i interwałów opartych na serii. Odstęp między powtórkami zwiększa się z każdą poprawną odpowiedzią (2, 4, 8, 16 dni) i resetuje się przy pomyłce. Seria to liczba poprawnych odpowiedzi pod rząd - określa następny interwał.",
        superMemoDescription: "Używa algorytmu SM-2 (wersja z Anki) z dynamiczną regulacją trudności. Interwały są obliczane na podstawie twoich wyników (np. 1, 6, 14, 30 dni).",
        saveSettings: "Zapisz ustawienia",
        leitnerAlgorithm: "System Leitnera",
        leitnerDescription: "Używa 5 pudełek ze stałymi interwałami. Karty przemieszczają się między pudełkami w zależności od twoich odpowiedzi (Pudełko 1: co dzień, Pudełko 2: 3 dni, Pudełko 3: 7 dni, Pudełko 4: 14 dni, Pudełko 5: 30 dni).",
        leitnerBox: "Pudełko",
        leitnerNextReview: "Następna powtórka",
        leitnerDays: "dni",
        leitnerBoxDescription: "Aktualne pudełko: ",
        leitnerProgress: "Postęp w systemie Leitnera",
        newTodayOnly: 'Tylko nowe z dzisiaj',
        noNewTodayFlashcards: 'Brak nowych fiszek do powtórki z dziś, dodaj kilka!',
        startOverTooltip: "Całkowicie zapomniałem",
        algorithmNote: "Dokładna ilość dni jest ustalana przez wybrany algorytm w ustawieniach (trzy kropki) " ,
        dueTodayDescription: "Na dziś - Planowane powtórki według wybranego algorytmu nauki.",
        newFlashcardsDescription2: "Dodaj 5 nowych fiszek - Dodaj 5 nowych fiszek do puli nauki. Wybierz własne tempo nauki, możesz wybrać inną ilość poprzez 'Liczba fiszek' (średnio człowiek może przyswoić 8/dzień).",
        newTodayDescription: "Tylko nowe z dzisiaj - powtarzaj wielokrotnie tylko fiszki dodane danego dnia.",
        hardFlashcardsDescription2: "Tylko trudne - powtarzaj tylko trudne fiszki które były już przeglądnięte, od początku talii.",
        randomFlashcardsDescription: "Losowy wybór - powtarzaj wszystkie fiszki które były już przeglądnięte, od początku talii.",
        reviewModes: "Tryby powtórek:",
        numberOfCardsDescription: "Liczba fiszek - Ilość fiszek do wyświetlenia w jednej powtórce. Dla 'Dodaj 5 nowych fiszek' zmienia domyślną ilość z 5 na wybraną (10, 20, własna).",
        moreInfo: "Więcej informacji",
        gradeButtonsOption: "Przyciski oceny",
        fourButtons: "4 przyciski",
        sixButtons: "6 przycisków",
        sync: "Synchronizuj",
        syncInProgress: "Synchronizacja...",
        syncSuccess: "Synchronizacja zakończona",
        syncError: "Błąd synchronizacji",
        pushbulletSetup: "Konfiguracja Pushbullet",
        enterApiKey: "Wprowadź klucz API Pushbullet:",
        connect: "Połącz",
        cancel: "Anuluj",
        syncEnabled: "Synchronizacja włączona",
        syncDisabled: "Synchronizacja wyłączona",
        apiKeyLimit: "(Darmowe konto: Limit 500 synchronizacji miesięcznie, co powinno wystarczyć na codzienną synchronizację 100 powtarzanych fiszek)",
        inactivityTimeout: "Zatrzymaj synchronizację po braku aktywności (minuty):",
        syncDescription: "Synchronizacja pozwala na powtarzanie fiszek na dwóch urządzeniach.",
        confirmDelete: "Usuń fiszkę",
        confirmDeleteMessage: "Czy na pewno chcesz usunąć tę fiszkę?",
        syncDeleteWarning: "Uwaga: Jeśli używasz Synchronizacji, to aby aktualna tabela fiszek (po usunięciu) została zapisana na serwerze, musisz także usunąć wszystkie fiszki na serwerze. Ustawienia -> Delete all Notes. Wtedy, naciśnij przycisk Sync aby zapisać aktualne fiszki z tabeli na serwerze.",
        enableSyncCheck: "Włącz sprawdzanie synchronizacji przy starcie",
        newSyncAvailable: "Dostępne nowe dane, rozpoczynam synchronizację...",
        syncButtonTooltip: "Kliknij aby pobrać aktualne fiszki z serwera lub po nauce zapisać zmiany na serwerze",
        removeKey: "Usuń klucz API",
        confirmRemoveKey: "Czy na pewno chcesz usunąć klucz API? Spowoduje to wyłączenie synchronizacji.",
        apiKeyRemoved: "Klucz API został usunięty",
        exportToServer: "Włącz przycisk Save (przydatne, gdy limit 500 pushów do serwera jest niewystarczający)",
        exportToServerTooltip: "Jeśli limit 500 darmowych pushów jest niewystarczający, nie używaj Sync, używaj Save, a następnie za każdym razem importuj plik ręcznie",
        saveTooltip: "Zapisz fiszki na serwerze",
        savingInProgress: "Zapisywanie...",
        saveSuccess: "Fiszki zostały zapisane",
        saveError: "Błąd podczas zapisywania fiszek",
        downloadSave: "Pobierz plik zapisu",
        enableAutoSave: "Włącz zapis pliku podczas synchronizacji (auto eksport na serwer)",
        enableAutoSync: "Włącz automatyczną synchronizację w czasie",
        enableSyncAfterReview: "Włącz synchronizację po zakończeniu powtórki",
        numberOfNewCards: "Liczba nowych fiszek:",
        reviewModesVisibility: "Pokazuj tryby powtórek:",
        showExamples: "Pokaż przykłady",
    }
};
</script>
<script>// Funkcje dla systemu Leitnera
function calculateLeitnerInterval(box) {
    const intervals = {
        1: 0,    // każdy dzień
        2: 3,    // co 3 dni
        3: 7,    // co 7 dni
        4: 14,   // co 14 dni
        5: 30   // co 30 dni
    };
    return intervals[box];
}

function initializeLeitnerFlashcard(flashcard) {
    if (!flashcard.leitnerBox && !flashcard.repetitions) {
        flashcard.leitnerBox = 1;
        flashcard.lastReviewed = null;
        flashcard.nextReview = null;
    }
    else if (flashcard.repetitions >=5) {
        flashcard.leitnerBox = 5;
    }
    else {
        flashcard.leitnerBox = flashcard.repetitions;
    }
    return flashcard;
}

function updateLeitnerBox(flashcard, wasCorrect) {
    if (wasCorrect) {
        // Przejście do następnego pudełka (max 5)
        flashcard.leitnerBox = Math.min(5, (flashcard.leitnerBox || 1) + 1);
        flashcard.repetitions++; // potentially to remove
    } else {
        // Powrót do pierwszego pudełka
        flashcard.leitnerBox = 1;
        flashcard.repetitions = 0; // potentially to remove
    }
    
    const interval = calculateLeitnerInterval(flashcard.leitnerBox);
    const now = new Date();
    flashcard.lastReviewed = now.toISOString();
    flashcard.nextReview = new Date(now.getTime() + interval * 24 * 60 * 60 * 1000).toISOString();
    
    return flashcard;
}

// Funkcje dla standardowego algorytmu
function calculateNextInterval(flashcard, wasCorrect) {
    const difficultyFactors = {
        easy: 2.5,
        medium: 2.0,
        hard: 1.5,
        veryHard: 1.2 // for 4 butons grade this will not be used
    };

    if (!wasCorrect) {
        flashcard.streak = 0;
        flashcard.repetitions = 0; // potentially to remove
        return 0; // 0 dzień dla błędnej odpowiedzi
    }

    const factor = difficultyFactors[flashcard.difficulty] || 2.0; // domyślnie medium
    const interval = Math.ceil(Math.pow(factor, flashcard.streak));
    
    return Math.min(interval, 365); // maksymalnie rok
}

// Funkcje dla algorytmu SuperMemo
function calculateSuperMemoInterval(flashcard, grade) {
    if (!flashcard.easinessFactor) {
        flashcard.easinessFactor = 2.5;
    }
    if (!flashcard.repetitions) {
        flashcard.repetitions = 0;
    }
    if (!flashcard.interval ) {
        flashcard.interval = 0;
    }

    let interval;
    let repetitions = flashcard.repetitions;
    let easinessFactor = flashcard.easinessFactor;

    if (grade >= 3) {
        if (repetitions === 0) {
            interval = 1;
        } else if (repetitions === 1) {
            interval = 6;
        } else {
            interval = Math.round(flashcard.interval * easinessFactor);
        }
        repetitions++;
    } else {
        repetitions = 0;
        interval = 0;
    }

    // Oblicz nowy współczynnik łatwości (EF)  SuperMemo 2 changed to ANKI algo with 4 grade scale
    if (localStorage.getItem('gradeButtonMode') === 'four' && grade === 0)
       { 
        grade = 1; // in 4 scale, because button with grade 1 is hidden, so button with grade 0 changes to grade 1
       }
    grade = grade + 2 ; // 2-7 (4 buttons EF adj: -0.18, -0.02, 0.1, 0.18) or (for 6 buttons EF adj: -0.38,-0.18(unhidden), -0.02, 0.1, 0.18, 0.22(unhidden) )
    easinessFactor = easinessFactor + 0.1 - (5 - grade) * (0.1 + (5 - grade) * 0.02);
    easinessFactor = Math.max(1.3, easinessFactor); // EF nie może być mniejszy niż 1.3

    return {
        interval: Math.min(interval, 365), // Maksymalnie rok
        easinessFactor,
        repetitions
    };
}

// Funkcja do filtrowania fiszek do powtórki
function getFlashcardsForReview() {
    const now = new Date();
    return flashcards.filter(flashcard => {
        if (!flashcard.nextReview) return true;
        return new Date(flashcard.nextReview) <= now;
    });
}

// Funkcja do sprawdzania, czy fiszka powinna być powtórzona
function shouldReview(flashcard) {
    const algorithm = localStorage.getItem('reviewAlgorithm') || 'standard';
    const now = new Date();

    if (!flashcard.nextReview) return true;

    switch (algorithm) {
        case 'leitner':
            // Dla systemu Leitnera sprawdzamy nextReview
            return new Date(flashcard.nextReview) <= now;

        case 'supermemo':
            // Dla SuperMemo sprawdzamy nextReview i interval
            if (!flashcard.interval) return true;
            return new Date(flashcard.nextReview) <= now;

        case 'standard':
        default:
            // Dla standardowego algorytmu sprawdzamy nextReview i difficulty
            if (!flashcard.difficulty) {
                flashcard.difficulty = 'medium';
                return true;
            }
            return new Date(flashcard.nextReview) <= now;
    }
}

// Funkcja do filtrowania fiszek do powtórki
function getFlashcardsForReview() {
    const algorithm = localStorage.getItem('reviewAlgorithm') || 'standard';
    
    return flashcards.filter(flashcard => {
        // Inicjalizacja fiszki dla odpowiedniego algorytmu jeśli potrzebne
        if (algorithm === 'leitner' && !flashcard.leitnerBox) {
            initializeLeitnerFlashcard(flashcard);
        } else if (algorithm === 'supermemo' && !flashcard.easinessFactor) {
            flashcard.easinessFactor = 2.5;
            flashcard.interval = 0;
            flashcard.repetitions = 0;
        } else if (algorithm === 'standard' && !flashcard.difficulty) {
            flashcard.difficulty = 'medium';
            flashcard.streak = 0;
        }

        return shouldReview(flashcard);
    });
}
</script>
<script>// Stałe konfiguracyjne
const PUSHBULLET_API_URL = 'https://api.pushbullet.com/v2';
const NOTE_SIZE_LIMIT = 10000;
const SYNC_INTERVAL = 5 * 60 * 1000; // 5 minut
let syncInterval = null;

// Zmiana stałej na początku pliku
const INACTIVITY_TIMEOUT = 10 * 60 * 1000; // 10 minut w milisekundach (zmienione z 30)
let lastActivityTime = Date.now();
let inactivityTimeout = null;

// Dodaj na początku pliku
const SYNC_CHECK_INTERVAL = 60000; // Sprawdzaj co minutę

// Funkcja pomocnicza do sprawdzania dostępności flashcards
function getFlashcards() {
    return new Promise((resolve, reject) => {
        const maxAttempts = 10;
        let attempts = 0;

        function checkFlashcards() {
            if (typeof window.flashcards !== 'undefined' && window.flashcards) {
                resolve(window.flashcards);
            } else if (attempts >= maxAttempts) {
                reject(new Error('Flashcards not initialized'));
            } else {
                attempts++;
                setTimeout(checkFlashcards, 500);
            }
        }

        checkFlashcards();
    });
}

// Funkcja pomocnicza do bezpiecznego zapisywania fiszek
function safeSaveFlashcards() {
    if (typeof window.saveFlashcards === 'function') {
        window.saveFlashcards();
    } else {
        console.error('saveFlashcards function not available');
    }
}

// Funkcja inicjalizująca połączenie z Pushbullet
async function initPushbullet(apiKey) {
    try {
        const response = await fetch(`${PUSHBULLET_API_URL}/users/me`, {
            headers: {
                'Access-Token': apiKey,
                'Content-Type': 'application/json'
            }
        });

        if (response.ok) {
            localStorage.setItem('pushbullet_api_key', apiKey);
            return true;
        }
        return false;
    } catch (error) {
        console.error('Pushbullet initialization failed:', error);
        return false;
    }
}

// Funkcja do wysyłania notatki przez Pushbullet
async function pushNote(title, body) {
    const apiKey = localStorage.getItem('pushbullet_api_key');
    if (!apiKey) return null;

    try {
        const response = await fetch(`${PUSHBULLET_API_URL}/pushes`, {
            method: 'POST',
            headers: {
                'Access-Token': apiKey,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                type: 'note',
                title: title,
                body: body
            })
        });

        if (!response.ok) throw new Error('Push failed');
        return await response.json();
    } catch (error) {
        console.error('Push failed:', error);
        throw error;
    }
}

// Funkcja do pobierania notatek z Pushbullet
async function fetchNotes() {
    const apiKey = localStorage.getItem('pushbullet_api_key');
    if (!apiKey) {
        console.log('No API key found');
        return [];
    }

    try {
        console.log('Fetching notes from Pushbullet API...');
        let allNotes = [];
        let cursor = null;
        let hasMore = true;
        
        // Ustaw datę początkową na 5 lat temu
       // const fiveYearsAgo = new Date();
      //  fiveYearsAgo.setFullYear(fiveYearsAgo.getFullYear() - 5);
     //   const modifiedAfter = Math.floor(fiveYearsAgo.getTime() / 1000);

        // Używamy czasu ostatniej synchronizacji
        const lastSyncTime = localStorage.getItem('last_sync_time') || '0';
        // Konwertujemy na sekundy dla API Pushbullet
       const modifiedAfter = Math.floor(parseInt(lastSyncTime) / 1000);

        while (hasMore) {
            const url = new URL(`${PUSHBULLET_API_URL}/pushes`);
            url.searchParams.append('limit', '500');
            url.searchParams.append('active', 'true');
            url.searchParams.append('modified_after', modifiedAfter);
            if (cursor) {
                url.searchParams.append('cursor', cursor);
            }

            const response = await fetch(url, {
                headers: {
                    'Access-Token': apiKey,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            if (data.pushes && data.pushes.length > 0) {
                // Filtruj notatki już podczas pobierania
                const syncNotes = data.pushes.filter(note => 
                    note.type === 'note' && 
                    (note.title?.startsWith('sync_') || note.title?.startsWith('flashcards_sync_'))
                );
                allNotes = allNotes.concat(syncNotes);
                console.log(`Fetched ${data.pushes.length} notes, found ${syncNotes.length} sync notes, total sync notes: ${allNotes.length}`);
                
                if (data.cursor) {
                    cursor = data.cursor;
                    await new Promise(resolve => setTimeout(resolve, 250));
                } else {
                    hasMore = false;
                }
            } else {
                hasMore = false;
            }
        }

        console.log('Total sync notes fetched:', allNotes.length);
        return allNotes;
    } catch (error) {
        console.error('Fetch failed:', error);
        throw error;
    }
}

// Funkcja pomocnicza do obsługi czasu na początku pliku
function toUTCTimestamp(date) {
    if (!date) return null;
    return Math.floor(new Date(date).getTime() / 1000);
}

function fromUTCTimestamp(timestamp) {
    if (!timestamp) return null;
    return new Date(timestamp * 1000).toISOString();
}

function getCurrentUTCTimestamp() {
    return Math.floor(Date.now() / 1000);
}

// Funkcja do przygotowania danych do synchronizacji
async function prepareDataForSync() {
    try {
        const flashcards = await getFlashcards();
        if (!flashcards.length) {
            console.log('No flashcards available for sync');
            return [];
        }

        const lastSync = localStorage.getItem('last_sync_time');// +3000 ?
        const lastSyncTimestamp = lastSync ? toUTCTimestamp(lastSync) : 0;

        const modifiedFlashcards = flashcards.filter(card => {
            const cardLastSync = toUTCTimestamp(card.lastSync) || 0;
            const cardLastReviewed = toUTCTimestamp(card.lastReviewed) || 0;
            const cardLastModified = toUTCTimestamp(card.lastModified) || 0;

            return !lastSync || 
                   !card.lastSync ||
                   cardLastReviewed > cardLastSync ||
                   cardLastModified > cardLastSync ||
                   (card.repeats > 0 && !card.lastSync); //potencjalnie do usuniecia, karta ma powtorzenia ale niema synca
        });

        const currentTimestamp = getCurrentUTCTimestamp();
        return modifiedFlashcards.map(card => ({
            id: card.id,
            lastReviewed: card.lastReviewed,
            lastSync: fromUTCTimestamp(currentTimestamp),
            lastModified: card.lastModified,
            data: {...card, lastSync: fromUTCTimestamp(currentTimestamp)}
        }));
    } catch (error) {
        console.error('Error preparing data for sync:', error);
        return [];
    }
}

// Funkcja do podziału danych na części mieszczące się w limicie
function splitDataIntoChunks(data) {
    const maxChunkSize = Math.floor(NOTE_SIZE_LIMIT * 0.8); // Używamy 80% limitu
    const chunks = [];
    let currentChunk = [];
    let currentSize = 0;

    for (const item of data) {
        const itemString = JSON.stringify(item);
        const itemSize = itemString.length;

        // Jeśli pojedynczy element jest większy niż limit
        if (itemSize > maxChunkSize) {
            console.warn('Item too large, will be split:', item.id);
            continue;
        }

        if (currentSize + itemSize > maxChunkSize) {
            chunks.push(currentChunk);
            currentChunk = [item];
            currentSize = itemSize;
        } else {
            currentChunk.push(item);
            currentSize += itemSize;
        }
    }

    if (currentChunk.length > 0) {
        chunks.push(currentChunk);
    }

    return chunks;
}

// Funkcja do synchronizacji danych
async function syncWithPushbullet() {
    const modifiedData = await prepareDataForSync();
    if (modifiedData.length === 0) {
        console.log('No data to sync');
        return;
    }

    console.log('Preparing to sync', modifiedData.length, 'flashcards');
    const chunks = splitDataIntoChunks(modifiedData);
    const deviceId = localStorage.getItem('device_id') || 
                    Math.random().toString(36).substring(7);

    console.log('Sending chunks:', chunks.length);
    const timestamp = Date.now();

    for (let i = 0; i < chunks.length; i++) {
        const chunkData = chunks[i];
        const title = `sync_${deviceId}_${i + 1}_${chunks.length}`;
        const syncData = {
            command: 'sync_data',
            device_id: deviceId,
            chunk_number: i + 1,
            total_chunks: chunks.length,
            data: chunkData,
            timestamp: timestamp
        };

        try {
            console.log(`Sending chunk ${i + 1}/${chunks.length} with ${chunkData.length} items`);
            const result = await pushNote(title, JSON.stringify(syncData));
            console.log('Push result:', result);
            await new Promise(resolve => setTimeout(resolve, 250)); // Dodaj opóźnienie między wysyłaniem
        } catch (error) {
            console.error('Error sending chunk:', error);
            throw error;
        }
    }

    console.log('All chunks sent successfully');
    localStorage.setItem('last_sync_time', new Date().toISOString());
    localStorage.setItem('device_id', deviceId);

    // Po udanej synchronizacji zaktualizuj czas
    updateLastSyncTime();
    
    return true;
}

// Funkcja do pobierania i przetwarzania zsynchronizowanych danych
async function fetchFromPushbullet() {
    console.log('Fetching notes from Pushbullet...');
    const notes = await fetchNotes();
    const lastSync = localStorage.getItem('last_sync_time');
    const deviceId = localStorage.getItem('device_id');

    console.log('Found notes:', notes.length);
    console.log('Last sync:', lastSync);
    console.log('Device ID:', deviceId);

    // Grupuj notatki według zestawów (timestamp i device_id)
    const noteSets = new Map(); // Map<setKey, Map<chunkNumber, note>>
    
    const lastSyncTime = parseInt(localStorage.getItem('last_sync_time') || '0');

    // Najpierw pogrupuj wszystkie notatki
    for (const note of notes) {
        try {
            if (!note.title?.startsWith('sync_')) continue;
            
            const syncData = JSON.parse(note.body);
            if (syncData.device_id === deviceId && lastSyncTime > 0 ) continue; // Pomiń własne notatki
            
            const setKey = `${syncData.device_id}_${syncData.timestamp}`;
            if (!noteSets.has(setKey)) {
                noteSets.set(setKey, new Map());
            }

            // Obsługa zarówno głównych chunków jak i sub-chunków
            if (syncData.sub_chunk) {
                const mainChunkKey = syncData.chunk_number;
                if (!noteSets.get(setKey).has(mainChunkKey)) {
                    noteSets.get(setKey).set(mainChunkKey, {
                        subChunks: new Map(),
                        total_sub_chunks: syncData.total_sub_chunks
                    });
                }
                noteSets.get(setKey).get(mainChunkKey).subChunks.set(syncData.sub_chunk, syncData);
            } else {
                noteSets.get(setKey).set(syncData.chunk_number, syncData);
            }

            console.log(`Added ${syncData.sub_chunk ? 'sub-chunk' : 'chunk'} to set ${setKey}`);
        } catch (error) {
            console.error('Error processing note:', error);
            continue;
        }
    }

    // Przetwórz każdy kompletny zestaw
    for (const [setKey, chunks] of noteSets) {
        try {
            let allData = [];
            let isComplete = true;

            // Sprawdź kompletność i zbierz dane
            for (const [chunkNumber, chunkData] of chunks) {
                if (chunkData.subChunks) {
                    // Sprawdź kompletność sub-chunków
                    if (chunkData.subChunks.size !== chunkData.total_sub_chunks) {
                        console.log(`Incomplete sub-chunks for chunk ${chunkNumber} in set ${setKey}`);
                        isComplete = false;
                        break;
                    }
                    // Połącz dane z sub-chunków
                    const orderedSubChunks = Array.from({ length: chunkData.total_sub_chunks }, 
                        (_, i) => chunkData.subChunks.get(i + 1)?.data || []).flat();
                    allData.push(...orderedSubChunks);
                } else {
                    allData.push(...(chunkData.data || []));
                }
            }

            if (isComplete) {
                console.log(`Processing complete set ${setKey} with ${allData.length} items`);
                await processChunks([{ data: allData }]);
            } else {
                console.log(`Incomplete set ${setKey}`);
            }
        } catch (error) {
            console.error('Error processing set:', setKey, error);
        }
    }

    // Aktualizuj czas ostatniej synchronizacji
    if (noteSets.size > 0) {
        const latestSync = Math.max(...Array.from(noteSets.values())
            .flatMap(chunks => Array.from(chunks.values()))
            .map(chunk => chunk.created || 0)); // Używamy timestamp z body zamiast created
        localStorage.setItem('last_sync_time', new Date(latestSync).toISOString());
    }
}
// Funkcja do przetwarzania otrzymanych chunków danych
async function processChunks(chunks) {
    console.log('Processing chunks:', chunks.length);
    const receivedData = chunks
        .flatMap(chunk => chunk.data)
        .filter(item => item && item.data);

    console.log('Received data items:', receivedData.length);
    let hasChanges = false;
    const flashcards = await getFlashcards();

    for (const item of receivedData) {
        try {
            const existingIndex = flashcards.findIndex(card => card.id === item.data.id);
            const duplicateIndex = flashcards.findIndex(card => 
                card.word === item.data.word &&
                card.context === item.data.context &&
                card.translation === item.data.translation
            );

            if (existingIndex === -1 && duplicateIndex === -1) {
                console.log('Adding new flashcard:', item.data.word);
                flashcards.push(item.data);
                hasChanges = true;
            } else if (existingIndex !== -1) {
                const existingCard = flashcards[existingIndex];
                const contentChanged = 
                    existingCard.word !== item.data.word ||
                    existingCard.context !== item.data.context ||
                    existingCard.translation !== item.data.translation;
                    


                const itemLastModified = toUTCTimestamp(item.data.lastModified) || 0;
                const existingLastModified = toUTCTimestamp(existingCard.lastModified) || 0;
                const itemLastSync = toUTCTimestamp(item.data.lastSync) || 0;
                const existingLastSync = toUTCTimestamp(existingCard.lastSync) || 0;
                const itemLastReviewed = toUTCTimestamp(item.data.lastReviewed) || 0;
                const existingLastReviewed = toUTCTimestamp(existingCard.lastReviewed) || 0;
                // To pozwalal na przegladanie fiszek podczas synchroznijacji. Fiszki które zostana powtorzone, ich stan nie bedzie aktualizowane synchronizacja z serwera
                if ((itemLastModified > existingLastModified)|| itemLastReviewed > existingLastReviewed || itemLastSync > existingLastSync ) {
                    console.log('Updating existing flashcard:', { //(itemLastSync > existingLastSync 
                        old: {  
                            word: existingCard.word,
                            lastSync: fromUTCTimestamp(existingLastSync),
                            lastReviewed: fromUTCTimestamp(existingLastReviewed)
                        },
                        new: {
                            word: item.data.word,
                            lastSync: fromUTCTimestamp(itemLastSync),
                            lastReviewed: fromUTCTimestamp(itemLastReviewed)
                        }
                    });
                    flashcards[existingIndex] = item.data;
                    hasChanges = true;
                }
            }
        } catch (error) {
            console.error('Error processing item:', error);
        }
    }

    if (hasChanges) {
        console.log('Saving updated flashcards');
        window.flashcards = flashcards;
        safeSaveFlashcards();
        console.log('Flashcards updated after sync');
    } else {
        console.log('No changes to save');
    }
}

// Funkcja do ustawienia automatycznej synchronizacji
function setupAutomaticSync(customInterval = null) {
    if (window.syncInterval) {
        clearInterval(window.syncInterval);
        window.syncInterval = null;
    }

    const autoSync = localStorage.getItem('auto_sync') === 'true';
    if (!autoSync) {
        console.log('Automatic sync is disabled');
        return;
    }

    const interval = customInterval || parseInt(localStorage.getItem('sync_interval') || '5') * 60 * 1000;
    console.log(`Setting up automatic sync with interval: ${interval}ms`);

    window.syncInterval = setInterval(async () => {
        try {
            if (isUserActive() && !isSyncing) {
                await handleSync();
            } else if (!isUserActive()) {
                console.log('Skipping sync due to user inactivity');
            }
        } catch (error) {
            console.error('Auto sync failed:', error);
        }
    }, interval);

    const events = ['mousedown', 'keydown', 'mousemove', 'wheel', 'touchstart', 'scroll'];
    events.forEach(event => {
        document.addEventListener(event, resetActivityTimer, { passive: true });
    });

    resetActivityTimer();

    console.log('Automatic sync has been set up with inactivity monitoring');
}

// Funkcja do resetowania timera aktywności
function resetActivityTimer() {
    lastActivityTime = Date.now();
    
    if (inactivityTimeout) {
        clearTimeout(inactivityTimeout);
    }
    
    inactivityTimeout = setTimeout(handleInactivity, INACTIVITY_TIMEOUT);
}

// Funkcja obsługująca brak aktywności
function handleInactivity() {
    console.log('User inactive for 30 minutes, pausing sync');
    if (window.syncInterval) {
        clearInterval(window.syncInterval);
        window.syncInterval = null;
    }
}

// Funkcja do sprawdzania czy użytkownik jest aktywny
function isUserActive() {
    return (Date.now() - lastActivityTime) < INACTIVITY_TIMEOUT;
}

// Funkcja do usuwania notatek (logika biznesowa)
async function deleteAllPushbulletNotes(progressCallback) {
    const apiKey = localStorage.getItem('pushbullet_api_key');
    if (!apiKey) {
        throw new Error('No API key found');
    }

    try {
        // Najpierw spróbuj usunąć wszystkie notatki za jednym razem
        const response = await fetch(`${PUSHBULLET_API_URL}/pushes`, {
            method: 'DELETE',
            headers: {
                'Access-Token': apiKey,
                'Content-Type': 'application/json'
            }
        });

        if (response.ok) {
            localStorage.removeItem('last_sync_time');
            return { 
                deletedCount: 1, 
                skippedCount: 0, 
                errorCount: 0, 
                totalNotes: 1,
                message: 'All notes deleted successfully' 
            };
        }

        // Jeśli zbiorcze usuwanie nie zadziała, wróć do usuwania pojedynczo
        console.log('Bulk delete failed, falling back to individual deletion');
        const notes = await fetchNotes();
        const totalNotes = notes.length;

        if (totalNotes === 0) {
            return { deletedCount: 0, skippedCount: 0, errorCount: 0, totalNotes: 0 };
        }

        let deletedCount = 0;
        let errorCount = 0;
        let skippedCount = 0;

        for (const note of notes) {
            try {
                const response = await fetch(`${PUSHBULLET_API_URL}/pushes/${note.iden}`, {
                    method: 'DELETE',
                    headers: {
                        'Access-Token': apiKey,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.status === 404) {
                    skippedCount++;
                } else if (response.ok) {
                    deletedCount++;
                } else {
                    throw new Error(`Unexpected status: ${response.status}`);
                }

                // Wywołaj callback z postępem
                if (progressCallback) {
                    progressCallback(deletedCount, skippedCount, totalNotes);
                }

                await new Promise(resolve => setTimeout(resolve, 250));
            } catch (error) {
                console.error(`Error deleting note ${note.title}:`, error);
                errorCount++;
            }
        }

        localStorage.removeItem('last_sync_time');
        return { deletedCount, skippedCount, errorCount, totalNotes };
    } catch (error) {
        console.error('Delete operation failed:', error);
        throw error;
    }
}

// Dodaj inicjalizację przycisku usuwania notatek
function initializeDeleteNotesButton() {
    const deleteButton = document.getElementById('delete-notes-button');
    if (deleteButton) {
        deleteButton.addEventListener('click', async function(e) {
            e.preventDefault();
            const confirmMessage = translations[currentLanguage].confirmDeleteNotes || 
                                 'Are you sure you want to delete all sync notes? This action cannot be undone.';
            
            if (confirm(confirmMessage)) {
                try {
                    deleteButton.disabled = true;
                    deleteButton.classList.add('deleting');
                    await deleteAllPushbulletNotes();
                } finally {
                    deleteButton.disabled = false;
                    deleteButton.classList.remove('deleting');
                }
            }
        });
    }
}

// Funkcja do czyszczenia automatycznej synchronizacji
function clearAutomaticSync() {
    if (window.syncInterval) {
        clearInterval(window.syncInterval);
        window.syncInterval = null;
    }
    
    if (inactivityTimeout) {
        clearTimeout(inactivityTimeout);
        inactivityTimeout = null;
    }
    
    // Usuń nasłuchiwanie zdarzeń
    const events = ['mousedown', 'keydown', 'mousemove', 'wheel', 'touchstart', 'scroll'];
    events.forEach(event => {
        document.removeEventListener(event, resetActivityTimer);
    });

    console.log('Automatic sync has been cleared');
}

// Eksportuj funkcje do globalnego obiektu window
window.initPushbullet = initPushbullet;
window.syncWithPushbullet = syncWithPushbullet;
window.fetchFromPushbullet = fetchFromPushbullet;
window.setupAutomaticSync = setupAutomaticSync;
window.clearAutomaticSync = clearAutomaticSync;
window.deleteAllPushbulletNotes = deleteAllPushbulletNotes;

// Funkcja sprawdzająca nowe synchronizacje
async function checkNewSyncs() {
    const apiKey = localStorage.getItem('pushbullet_api_key');
    if (!apiKey) return;

    try {
        const lastSyncTime = localStorage.getItem('last_sync_time') || '0';
        console.log('Checking syncs with last sync time:', new Date(parseInt(lastSyncTime)).toLocaleString());

        const response = await fetch(`${PUSHBULLET_API_URL}/pushes?limit=1`, {
            headers: {
                'Access-Token': apiKey,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) return;

        const data = await response.json();
        if (data.pushes && data.pushes.length > 0) {
            const latestPush = data.pushes[0];
            
            // Debugowanie zawartości pusha
            console.log('Latest push data:', latestPush);
            
            const latestTimestamp = latestPush.created * 1000;
            const lastSyncTimeMs = parseInt(lastSyncTime);

            // Wyświetl daty w konsoli
            console.log('Last sync time:', new Date(lastSyncTimeMs + 3000).toLocaleString());
            console.log('Latest push created:', new Date(latestTimestamp).toLocaleString());
            console.log('New sync available:', latestTimestamp > (lastSyncTimeMs + 3000));

            const syncButton = document.getElementById('sync-button');
            if (syncButton) {
                if (latestTimestamp >  (lastSyncTimeMs + 3000)) // add 3 seconds 
                {
                    // Jest nowa synchronizacja
                    syncButton.classList.add('new-sync');
                    console.log('Sync button changed to red: New data available on server');
                    
                    // Automatycznie uruchom synchronizację
                    console.log('Starting automatic sync due to new data...');
                    showNotification(translations[currentLanguage].newSyncAvailable || 'New data available, starting sync...', 'info');
                    
                    // Krótkie opóźnienie przed rozpoczęciem synchronizacji
                    setTimeout(async () => {
                        try {
                            await handleSync();
                        } catch (error) {
                            console.error('Auto sync failed:', error);
                        }
                    }, 1000); // 1 sekunda opóźnienia
                } else {
                    syncButton.classList.remove('new-sync');
                }
            }
        }
    } catch (error) {
        console.error('Error checking new syncs:', error);
    }
}

// Funkcja inicjalizująca sprawdzanie
function initSyncCheck() {
    // Sprawdź od razu po uruchomieniu
    checkNewSyncs();
    
    // Ustaw interwał sprawdzania
   // setInterval(checkNewSyncs, SYNC_CHECK_INTERVAL); // nie potrzebuje narazie
}

// Dodaj funkcję do aktualizacji czasu synchronizacji
function updateLastSyncTime() {
    const currentTime = Date.now();
    localStorage.setItem('last_sync_time', currentTime.toString());
    console.log('Sync time updated:', new Date(currentTime).toLocaleString());
       
    // Zaktualizuj timestamp dla wszystkich fiszek
        flashcards.forEach(flashcard => {
            flashcard.lastSync = currentTime;
        });
        saveFlashcards();
}
// Dodaj do window
window.updateLastSyncTime = updateLastSyncTime;
window.checkNewSyncs = checkNewSyncs;
window.initSyncCheck = initSyncCheck;

// Funkcja do wysyłania pliku CSV przez Pushbullet
async function sendCsvToPushbullet(csvContent) {
    const apiKey = localStorage.getItem('pushbullet_api_key');
    if (!apiKey) {
        throw new Error('No API key found');
    }

    try {
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        
        const now = new Date();
        const dateStr = now.getFullYear() + '_' +
            String(now.getMonth() + 1).padStart(2, '0') + '_' +
            String(now.getDate()).padStart(2, '0') + '_' +
            String(now.getHours()).padStart(2, '0') + '_' +
            String(now.getMinutes()).padStart(2, '0') + '_' +
            String(now.getSeconds()).padStart(2, '0');
            
        const fileName = `flashcards_save_${dateStr}.csv`;

        const uploadRequestData = {
            file_name: fileName,
            file_type: 'text/csv'
        };

        const uploadResponse = await fetch(`${PUSHBULLET_API_URL}/upload-request`, {
            method: 'POST',
            headers: {
                'Access-Token': apiKey,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(uploadRequestData)
        });

        if (!uploadResponse.ok) {
            throw new Error('Failed to get upload URL');
        }

        const uploadData = await uploadResponse.json();
        console.log('Upload data received:', uploadData);

        const formData = new FormData();
        for (const [key, value] of Object.entries(uploadData.data)) {
            formData.append(key, value);
        }
        formData.append('file', blob, fileName);

        const fileUploadResponse = await fetch(uploadData.upload_url, {
            method: 'POST',
            body: formData
        });

        if (!fileUploadResponse.ok) {
            console.error('Upload response:', fileUploadResponse);
            throw new Error('Failed to upload file');
        }

        const pushResponse = await fetch(`${PUSHBULLET_API_URL}/pushes`, {
            method: 'POST',
            headers: {
                'Access-Token': apiKey,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                type: 'file',
                file_name: fileName,
                file_type: 'text/csv',
                file_url: uploadData.file_url,
                title: 'Flashcards Save'
            })
        });

        if (!pushResponse.ok) {
            throw new Error('Failed to create push');
        }

        console.log('CSV file successfully sent to Pushbullet');
        return uploadData; // Zwracamy cały obiekt uploadData, który zawiera file_url
    } catch (error) {
        console.error('Error sending CSV to Pushbullet:', error);
        throw error;
    }
}

// Eksportuj funkcję do globalnego obiektu window
window.sendCsvToPushbullet = sendCsvToPushbullet;

// Funkcja do sprawdzania plików save na serwerze
async function checkSaveFiles() {
    const apiKey = localStorage.getItem('pushbullet_api_key');
    const exportToServer = localStorage.getItem('export_to_server') === 'true';
    if (!apiKey ) return; //|| !exportToServer

    try {
        const response = await fetch(`${PUSHBULLET_API_URL}/pushes?limit=500&active=true`, {
            headers: {
                'Access-Token': apiKey,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) return;

        const data = await response.json();
        if (data.pushes && data.pushes.length > 0) {
            const saveFile = data.pushes
                .find(push => push.file_name && 
                            push.file_name.startsWith('flashcards_save_') && 
                            push.file_url);

            if (saveFile) {
                const saveLinkContainer = document.getElementById('save-link');
                if (saveLinkContainer) {
                    saveLinkContainer.innerHTML = `
                        <a href="${saveFile.file_url}" target="_blank">
                            Download ${saveFile.file_name}
                        </a>
                    `;
                    saveLinkContainer.style.display = 'block';
                }
            }
        }
    } catch (error) {
        console.error('Error checking save files:', error);
    }
}

// Eksportuj funkcję
window.checkSaveFiles = checkSaveFiles;

</script>
<script>// Dodaj tę linię na początku pliku, zaraz po deklaracji translations
let currentLanguage = 'en'; // Domyślnie ustawiamy język angielski
lastScrollPosition = 0;

// Dodaj te zmienne globalne na początku pliku
let flashcardsToReview = [];
let currentFlashcardIndex = 0;
let currentReviewMode = null;
let isSyncing = false; // Dodajemy zmienną isSyncing na początku


// Globalna zmienna do przechowywania fiszek
let flashcards = [];

// Funkcja do ładowania fiszek z localStorage
function loadFlashcards() {
  const savedFlashcards = localStorage.getItem('flashcards');
  const savedFiszki = localStorage.getItem('fiszki');
  
  if (savedFlashcards) {
    flashcards = JSON.parse(savedFlashcards);
  } else if (savedFiszki) {
    const fiszki = JSON.parse(savedFiszki);
    flashcards = fiszki.map(fiszka => ({
      id: Date.now() + Math.random(),
      word: fiszka.word,
      context: fiszka.context,
      translation: fiszka.translation,
      mediaUrl: '',
      audioUrl: '',
      repeats: 0,
      lastReviewed: null
    }));
  } else {
    flashcards = [];
  }
  
  console.log('Załadowano fiszki:', flashcards);
  saveFlashcards();
}

// Funkcja do zapisywania fiszek w localStorage
function saveFlashcards() {
  localStorage.setItem('fiszki', JSON.stringify(flashcards));
  console.log('Zapisano fiszki:', flashcards);
}

// Funkcja do dodawania nowej fiszki
function addFlashcard(word, context, translation, mediaUrl = '', audioUrl = '') {
  const newFlashcard = {
    id: Date.now(),
    word,
    context,
    translation,
    mediaUrl,
    audioUrl,
    streak: 0,
    lastReviewed: null,
    firstReviewDate: null, // dodajemy nowe pole
    createdAt: new Date().toISOString(),
    difficulty: 'medium', // domyślna trudność
    nextReview: null,
    easinessFactor: 2.5,
    interval: 0,
    repetitions: 0,
    leitnerBox: 1
  };
  flashcards.push(newFlashcard);
  saveFlashcards();
  updateFlashcardTable();
  updateStats();
  drawLearningProgressChart();
  showSection('view');
  const message = translations[currentLanguage].flashcardAdded || 'Flashcard has been added!';
  alert(message);
}

// Funkcja do aktualizacji tabeli fiszek
function updateFlashcardTable() {
    const tableBody = document.querySelector('#flashcardTable tbody');
    if (!tableBody) return;
    tableBody.innerHTML = '';
    
    const algorithm = localStorage.getItem('reviewAlgorithm') || 'standard';

    flashcards.forEach((flashcard, index) => {
        const row = document.createElement('tr');
        row.setAttribute('data-id', flashcard.id);
        
        // Określamy, czy fiszka jest opanowana w zależności od algorytmu
        let isMastered = false;
        switch(algorithm) {
            case 'supermemo':
                // Dla SuperMemo - fiszka jest opanowana, gdy EF > 2.0 i repetitions >= 5
                isMastered = (flashcard.easinessFactor > 2.0 && flashcard.repetitions >= 5);
                break;
            case 'leitner':
                // Dla systemu Leitnera - fiszka jest opanowana, gdy jest w pudełku 4 lub 5
                isMastered = (flashcard.leitnerBox >= 5);// or 5 repetitions
                break;
            default:
                // Dla standardowego algorytmu - fiszka jest opanowana po 5 poprawnych odpowiedziach
                isMastered = (flashcard.streak >= 5); // or 5 repetitions
        }

        row.innerHTML = `
            <td>${index + 1}</td>
            <td>${flashcard.word}</td>
            <td>${flashcard.context || ''}</td>
            <td>${flashcard.translation}</td>
            <td>${isMastered ? translations[currentLanguage].yes : translations[currentLanguage].no2}</td>
            <td>${flashcard.mediaUrl ? '<img src="' + flashcard.mediaUrl + '" alt="media" width="50">' : ''}</td>
            <td>${flashcard.audioUrl ? '<audio controls><source src="' + flashcard.audioUrl + '" type="audio/mpeg"></audio>' : ''}</td>
            <td>
                <button onclick="editFlashcard(${flashcard.id})" data-translate="edit">Edit</button>
                <button onclick="deleteFlashcard(${flashcard.id})" data-translate="delete">Delete</button>
            </td>
        `;
        
        // Dodaj obsługę pojedynczego kliknięcia na wiersz
        row.addEventListener('click', function(event) {
            // Sprawdź, czy kliknięcie nie było na przyciskach
            if (!event.target.closest('button')) {
                toggleRowSelection(this);
            }
        });

        // Dodaj obsługę podwójnego kliknięcia na wiersz
        row.addEventListener('dblclick', function(event) {
            // Sprawdź, czy kliknięcie nie było na przyciskach
            if (!event.target.closest('button')) {
                editFlashcard(flashcard.id);
            }
        });
        
        tableBody.appendChild(row);
    });

    // Dodaj nowy wiersz z przyciskiem "Usuń wszystkie"
    const deleteAllRow = document.createElement('tr');
    deleteAllRow.innerHTML = `
        <td colspan="7"></td>
        <td>
            <button onclick="deleteAllFlashcards()" class="delete-all-button" data-translate="deleteAll">Delete All</button>
        </td>
    `;
    tableBody.appendChild(deleteAllRow);
    
    changeLanguage();
}

// Funkcja do wyświetlania sekcji
function showSection(sectionId) {
    console.log(`Próba wyświetlenia sekcji: ${sectionId}`);
    document.querySelectorAll('.section').forEach(section => {
        section.style.display = 'none';
        console.log(`Ukryto sekcję: ${section.id}`);
    });
    const selectedSection = document.getElementById(sectionId);
    if (selectedSection) {
        selectedSection.style.display = 'block';
        console.log(`Wyświetlono sekcję: ${sectionId}`);
        if (sectionId === 'add') {
            setupAutoResizingTextareas();
        }
        if (sectionId === 'review') {
            initializeReviewSection();
        }
    } else {
        console.error(`Nie znaleziono sekcji o id: ${sectionId}`);
    }
    
    // Aktualizuj aktywny przycisk w menu nawigacyjnym
    document.querySelectorAll('.nav-button').forEach(button => {
        button.classList.remove('active');
    });
    
    // Znajdź odpowiedni przycisk i dodaj klasę 'active'
    let activeButton;
    if (sectionId === 'review') {
        activeButton = document.querySelector('.nav-button[onclick*="showSection(\'review\')"]');
    } else {
        activeButton = document.querySelector(`.nav-button[onclick="showSection('${sectionId}')"]`);
    }
    
    if (activeButton) {
        activeButton.classList.add('active');
    } else {
        console.error(`Nie znaleziono przycisku dla sekcji: ${sectionId}`);
    }
}



// Funkcja do rozpoczęcia powtórki
function startReview() {
    console.log('Rozpoczęcie powtórki');
    showReviewModeSelection();
}

function showReviewModeSelection() {
    const reviewSection = document.getElementById('reviewCard');
    const showNewToday = localStorage.getItem('show_new_today') !== 'false';
    const showHardCards = localStorage.getItem('show_hard_cards') !== 'false';
    const showRandom = localStorage.getItem('show_random') !== 'false';
    const showCardsNumber = localStorage.getItem('show_cards_number') === 'true';

    let reviewModesHTML = `
        <div class="review-mode-card" onclick="selectReviewMode('dueToday')">
            <h4 data-translate="dueToday">Due Today</h4>
            <p class="card-count" id="dueTodayCount">0</p>
        </div>
        <div class="review-mode-card" onclick="selectReviewMode('new')">
            <h4 data-translate="newFlashcardsOnly">Add 5 New Cards</h4>
            <p class="card-count" id="newCount">0</p>
        </div>`;

    if (showNewToday) {
        reviewModesHTML += `
            <div class="review-mode-card" onclick="selectReviewMode('newToday')">
                <h4 data-translate="newTodayOnly">New Cards From Today Only</h4>
                <p class="card-count" id="newTodayCount">0</p>
            </div>`;
    }
    if (showHardCards) {
        reviewModesHTML += `
            <div class="review-mode-card" onclick="selectReviewMode('hard')">
                <h4 data-translate="hardFlashcardsOnly">Hard Cards Only</h4>
                <p class="card-count" id="hardCount">0</p>
            </div>`;
    }
    if (showRandom) {
        reviewModesHTML += `
            <div class="review-mode-card" onclick="selectReviewMode('random')">
                <h4 data-translate="randomFlashcards">Random Selection</h4>
                <p class="card-count" id="totalCount">0</p>
            </div>`;
    }

    reviewSection.innerHTML = `
        <div class="review-mode-selection">
            <h3 data-translate="selectMode">Select review mode</h3>
            <div class="review-modes">
                ${reviewModesHTML}
            </div>
            <div class="review-options">
                <div class="cards-number-options" style="${!showCardsNumber ? 'display: none;' : ''}">
                    <label data-translate="numberOfCards">Number of cards:</label>
                    <div class="checkbox-group">
                        <label class="checkbox-option">
                            <input type="radio" name="cardsNumber" value="all" checked 
                                   onchange="toggleCustomNumberInput()">
                            <span data-translate="allCards">All cards</span>
                        </label>
                        <label class="checkbox-option">
                            <input type="radio" name="cardsNumber" value="10" 
                                   onchange="toggleCustomNumberInput()">
                            <span>10</span>
                        </label>
                        <label class="checkbox-option">
                            <input type="radio" name="cardsNumber" value="20" 
                                   onchange="toggleCustomNumberInput()">
                            <span>20</span>
                        </label>
                        <label class="checkbox-option">
                            <input type="radio" name="cardsNumber" value="custom" 
                                   onchange="toggleCustomNumberInput()">
                            <span data-translate="customNumber">Custom number</span>
                            <input type="number" id="customNumberInput" class="hidden" 
                                   min="1" value="30" onclick="event.stopPropagation()">
                        </label>
                    </div>
                </div>
                <button onclick="startSelectedReview()" class="start-review-button" 
                        data-translate="startReview">Start Review</button>
            </div>
        </div>
    `;
    
    updateCardCounts();
    changeLanguage();
}

// Zmodyfikuj funkcję toggleCustomNumberInput
function toggleCustomNumberInput() {
    const customInput = document.getElementById('customNumberInput');
    const selectedValue = document.querySelector('input[name="cardsNumber"]:checked').value;
    customInput.classList.toggle('hidden', selectedValue !== 'custom');
}

// Zmodyfikuj funkcję startSelectedReview
function startSelectedReview() {
    if (!currentReviewMode) {
        currentReviewMode = 'dueToday';
    }

    const selectedValue = document.querySelector('input[name="cardsNumber"]:checked').value;
    const customInput = document.getElementById('customNumberInput');
    let maxCards = null;

    if (selectedValue === 'custom') {
        maxCards = parseInt(customInput.value);
    } else if (selectedValue !== 'all') {
        maxCards = parseInt(selectedValue);
    }

    const algorithm = localStorage.getItem('reviewAlgorithm') || 'standard';
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    // Ustaw dueToday jako domyślny tryb
    if (!currentReviewMode) currentReviewMode = 'dueToday';
    switch (currentReviewMode) {
       case 'newToday':
        flashcardsToReview = flashcards.filter(f => {
            if (!f.firstReviewDate) return false;
            const reviewDate = new Date(f.firstReviewDate);
            return reviewDate.getFullYear() === today.getFullYear() &&
                   reviewDate.getMonth() === today.getMonth() &&
                   reviewDate.getDate() === today.getDate();
        });
        break;
        case 'dueToday':
            switch (algorithm) {
                case 'supermemo':
                    // Dla SuperMemo - fiszki z lastReviewed i nextReview <= now
                    flashcardsToReview = flashcards.filter(f => 
                        f.lastReviewed && // musi być już przeglądana
                        (!f.nextReview || new Date(f.nextReview) <= now)
                    );
                    break;
                case 'leitner':
                    // Dla Leitnera - fiszki z lastReviewed i nextReview <= now
                    flashcardsToReview = flashcards.filter(f => 
                        f.lastReviewed && // musi być już przeglądana
                        (!f.nextReview || new Date(f.nextReview) <= now)
                    );
                    break;
                default:
                    // Dla standardowego algorytmu - fiszki z lastReviewed i nextReview <= now
                    flashcardsToReview = flashcards.filter(f => 
                        f.lastReviewed && // musi być już przeglądana
                        (!f.nextReview || new Date(f.nextReview) <= now)
                    );
            }
            break;
        case 'new':
            switch (algorithm) {
                case 'supermemo':
                case 'leitner':
                default:
                    flashcardsToReview = flashcards.filter(f => !f.lastReviewed);
            }
            break;
        case 'hard':
            switch (algorithm) {
                case 'supermemo':
                    flashcardsToReview = flashcards.filter(f => 
                      f.lastReviewed && f.easinessFactor && f.easinessFactor < 2.1
                    );
                    break;
                case 'leitner':
                    // Dla Leitnera, trudne fiszki to te w pudełkach 1
                    flashcardsToReview = flashcards.filter(f => 
                      f.lastReviewed &&  f.leitnerBox && f.leitnerBox < 2
                    );
                    break;
                default:
                    flashcardsToReview = flashcards.filter(f => 
                      f.lastReviewed &&  f.difficulty === 'hard' || f.difficulty === 'veryHard'
                    );
            }
            break;
        case 'random':
            flashcardsToReview = [...flashcards.filter(f => 
              f.lastReviewed )].sort(() => Math.random() - 0.5);
            break;

    }
    if (currentReviewMode === 'new' && !maxCards ) // dla wybranej ilosci fisek
       maxCards = 5; //nowe fiszki , dobierz tylko 5 lub tyle ile w polu maxCards

    if (maxCards && maxCards > 0) {
        flashcardsToReview = flashcardsToReview.slice(0, maxCards);
    }

    currentFlashcardIndex = 0;
    if (flashcardsToReview.length > 0) {
        showNextFlashcard();
    } 
    else if (currentReviewMode === 'new' || currentReviewMode === 'newToday') {

        showNoNewFlashcardsMessage();
    }
    else {
        showNoFlashcardsMessage();
    }
}

// Funkcja do pokazywania tłumaczenia
function showTranslation(index) {
    const translationDiv = document.getElementById(`translation-${index}`);
    const qualityButtons = document.querySelector('.quality-buttons');
    const showTranslationButton = document.querySelector('.show-translation');
    
    if (translationDiv) {
        translationDiv.classList.remove('hidden');
    }
    
    if (qualityButtons) {
        qualityButtons.classList.remove('hidden');
    }
    
    if (showTranslationButton) {
        showTranslationButton.classList.add('hidden');
    }
}

// Modyfikacja funkcji gradeAnswer
function gradeAnswer(grade) {
    const algorithm = localStorage.getItem('reviewAlgorithm') || 'standard';
    const flashcard = flashcardsToReview[currentFlashcardIndex];
    const now = new Date();
    const wasCorrect = grade >= 3;

    // Ustaw firstReviewDate jeśli to pierwsza powtórka
    if (!flashcard.lastReviewed)  flashcard.firstReviewDate = now.toISOString();
    
    switch (algorithm) {
        case 'supermemo':
            // Użyj algorytmu SuperMemo
            const result = calculateSuperMemoInterval(flashcard, grade);
            flashcard.easinessFactor = result.easinessFactor;
            flashcard.interval = result.interval;
            flashcard.repetitions = result.repetitions;
            flashcard.lastReviewed = now.toISOString();
            flashcard.nextReview = new Date(now.getTime() + result.interval * 24 * 60 * 60 * 1000).toISOString();
            break;

        case 'leitner':
            // Użyj systemu Leitnera
            updateLeitnerBox(flashcard, wasCorrect);
            break;

        default:
            // Standardowy algorytm
            // Aktualizuj trudność na podstawie oceny
            if (grade <= 1) {
                flashcard.difficulty = 'veryHard'; // will not be used for 4 buttons grade
            } else if (grade === 2) {
                flashcard.difficulty = 'hard';
            } else if (grade === 3) {
                flashcard.difficulty = 'medium';
            } else {
                flashcard.difficulty = 'easy';
            }

            // Aktualizuj streak i oblicz następny interwał
            if (wasCorrect) {
               flashcard.streak = flashcard.repetitions; // to have simialr results between standard and SuperMemo
               flashcard.streak = (flashcard.streak || 0) + 1;
               flashcard.repetitions++; // potentially to remove
            } else {
                flashcard.streak = 0;
                flashcard.repetitions = 0; // potentially to remove
            }

            const interval = calculateNextInterval(flashcard, wasCorrect);
            flashcard.lastReviewed = now.toISOString();
            flashcard.nextReview = new Date(now.getTime() + interval * 24 * 60 * 60 * 1000).toISOString();
            break;
    }

    saveFlashcards();
    currentFlashcardIndex++;
    showNextFlashcard();
    updateStats();
}

// Funkcja do restartu powtórki
function restartReview() {
  flashcardsToReview = [...flashcards];
  currentFlashcardIndex = 0;
  showNextFlashcard();
  updateFlashcardTable();
}

// Funkcja do edycji fiszki
function editFlashcard(id) {
    lastScrollPosition = window.scrollY;
    const flashcard = flashcards.find(f => f.id === id);
    if (flashcard) {
        // Znajdź i odznacz wszystkie wcześniej zaznaczone wiersze
        document.querySelectorAll('#flashcardTable tbody tr.selected-row').forEach(row => {
            row.classList.remove('selected-row');
        });

        // Znajdź i zaznacz wiersz odpowiadający edytowanej fiszce
        const row = document.querySelector(`#flashcardTable tbody tr[data-id="${id}"]`);
        if (row) {
            row.classList.add('selected-row');
        }

        const editForm = document.createElement('div');
        editForm.className = 'section edit-form';
        editForm.id = 'edit';
        editForm.innerHTML = `
        <h2 data-translate="editFlashcard">Edit Flashcard</h2>
        <form id="editFlashcardForm" style="display: flex; flex-direction: column; gap: 10px;">
            <div class="word-container" style="display: flex; align-items: flex-start; gap: 0px; width: 100%;">
                <textarea id="editWord" data-placeholder="wordPhrase" required style="flex: 1;">${flashcard.word}</textarea>
                <button type="button" class="speaker-button" onclick="speakWord('editWord')" style="background: none; border: none; cursor: pointer; padding: 8px 0 0 0; margin-right: -12px;">
                    <svg width="23" height="23" viewBox="0 0 24 24" fill="#333333">
                        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                    </svg>
                </button>
            </div>
            <div class="context-container" style="display: flex; align-items: flex-start; gap: 0px; width: 100%;">
                <textarea id="editContext" data-placeholder="contextExample" style="flex: 1;">${flashcard.context || ''}</textarea>
                <button type="button" class="speaker-button" onclick="speakWord('editContext')" style="background: none; border: none; cursor: pointer; padding: 8px 0 0 0; margin-right: -12px;">
                    <svg width="23" height="23" viewBox="0 0 24 24" fill="#333333">
                        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                    </svg>
                </button>
            </div>
            <div class="examples-button-container">
                <button type="button" class="show-examples-button" onclick="showExamples('${flashcard.word}')">
                    <small data-translate="showExamples">Show examples</small>
                </button>
            </div>
            <div class="context-container2" style="display: flex; align-items: flex-start; gap: 0px;  margin-right: 15px;">
            <textarea id="editTranslation" data-placeholder="translation" required>${flashcard.translation}</textarea>
            </div>
            <div class="url-inputs" style="display: flex; flex-direction: column; gap: 0px;margin-right: 35px;">
                <input type="text" id="editMediaUrl" data-placeholder="imageLink" value="${flashcard.mediaUrl || ''}" style="width: 100%;">
                <input type="text" id="editAudioUrl" data-placeholder="audioLink" value="${flashcard.audioUrl || ''}" style="width: 100%;">
            </div>
               <div class="button-group">
                   <button type="submit" class="submit-button" data-translate="save">Save</button>
                    <button type="button" class="cancel-button" onclick="cancelEdit()" data-translate="cancel">Cancel</button>
                </div>
            </form>
        `;

    // Funkcja do odtwarzania tekstu
    window.speakWord = function(textareaId) {
        const TtsLang = localStorage.getItem('ttsLanguage') || 'en';
        const text = document.getElementById(textareaId).value;
        const encodedText = encodeURIComponent(text);
        const url = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodedText}&tl=${TtsLang}&client=tw-ob`;
        
        const audio = new Audio(url);
        audio.play().catch(error => {
            console.error('Error playing audio:', error);
        });
    };  
        
        editForm.querySelector('form').addEventListener('submit', (e) => {
            e.preventDefault();
            updateFlashcard(id, {
                word: document.getElementById('editWord').value,
                context: document.getElementById('editContext').value,
                translation: document.getElementById('editTranslation').value,
                mediaUrl: document.getElementById('editMediaUrl').value,
                audioUrl: document.getElementById('editAudioUrl').value
            });
        });
        
        const container = document.querySelector('.container');
        const existingEditForm = document.getElementById('edit');
        if (existingEditForm) {
            container.removeChild(existingEditForm);
        }
        container.appendChild(editForm);
        showSection('edit');
        
        // Dostosuj wysokość pól tekstowych
        adjustTextareaHeight('editWord', flashcard.word);
        adjustTextareaHeight('editContext', flashcard.context);
        adjustTextareaHeight('editTranslation', flashcard.translation);
        
        changeLanguage(); // Przetłumacz nowo dodane elementy
    }
}

// Funkcja do aktualizacji fiszki
function updateFlashcard(id, updatedData) {
    const index = flashcards.findIndex(f => f.id === id);
    if (index !== -1) {
        // Dodaj znacznik czasu modyfikacji
        updatedData.lastModified = new Date().toISOString();

        flashcards[index] = { ...flashcards[index], ...updatedData };
        saveFlashcards();
        showSection('view');
        updateFlashcardTable();
        changeLanguage(); // Zaktualizuj tłumaczenie
        window.scrollTo(0, lastScrollPosition);

        // Znajdź i zaznacz wiersz odpowiadający zaktualizowanej fiszce
        setTimeout(() => {
            const updatedRow = document.querySelector(`#flashcardTable tbody tr[data-id="${id}"]`);
            if (updatedRow) {
                updatedRow.classList.add('selected-row');
                updatedRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }, 100); // Małe opóźnienie, aby dać czas na renderowanie tabeli
    }
}

// Funkcja do anulowania edycji
function cancelEdit() {
    showSection('view');
    changeLanguage(); // Przywróć tłumaczenia
    window.scrollTo(0, lastScrollPosition);  // Dodaj tę linię
}

// Zmodyfikowana funkcja exportFlashcards
function createExportBlob() {
  // Przygotuj dane w formacie CSV
  let csvContent = "front;back;context;MediaUrl;AudioUrl;Algorithm;FirstReviewDate;LastReviewed;NextReview;Difficulty;Streak;EasinessFactor;Interval;Repetitions;LeitnerBox\n";
  
  const currentAlgorithm = localStorage.getItem('reviewAlgorithm') || 'standard';
  flashcards.forEach(card => {
      const row = [
          // Podstawowe pola (zachowane oryginalne nazwy)
          card.word.replace(/;/g, ','),          // front
          card.translation.replace(/;/g, ','),   // back
          card.context ? card.context.replace(/;/g, ',') : '', // context
          
          // Pozostałe pola
          card.mediaUrl || '',
          card.audioUrl || '',
          currentAlgorithm,
          card.firstReviewDate || '',
          card.lastReviewed || '',
          card.nextReview || '',
          
          // Pola dla standardowego algorytmu
          card.difficulty || '',
          card.streak || 0,
          
          // Pola dla SuperMemo
          card.easinessFactor || 2.5,
          card.interval || 0,
          card.repetitions || 0,
          
          // Pola dla systemu Leitnera
          card.leitnerBox || 1
      ].join(';');
      
      csvContent += row + '\n';
  });

  // Utwórz i zwróć blob
  return new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
}

// Oryginalna funkcja exportFlashcards (bez zmian)
function exportFlashcards() {
  const blob = createExportBlob();
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  
  link.setAttribute('href', url);
  link.setAttribute('download', 'flashcards_export.csv');
  link.style.visibility = 'hidden';
  
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

// Nowa funkcja do wysyłania eksportu przez Pushbullet
async function sendExportToPushbullet() {
    try {
        const blob = createExportBlob();
        const result = await window.sendCsvToPushbullet(blob);
        console.log('Export result:', result);
        return result;
    } catch (error) {
        console.error('Error sending export to Pushbullet:', error);
        throw error;
    }
}

// Eksportuj nową funkcję
window.sendExportToPushbullet = sendExportToPushbullet;

function escapeCSV(str) {
  if (str == null) return '';
  return '"' + str.replace(/"/g, '""').replace(/\n/g, ' ') + '"';
}

// Funkcja do importu fiszek
function importFlashcards() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.onchange = function(event) {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            const lines = content.split('\n');
            let importedCount = 0;
            let duplicateCount = 0;
            let updatedCount = 0;

            // Pomijamy pierwszy wiersz (nagłówki)
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line) {
                    const [
                        front, 
                        back, 
                        context, 
                        mediaUrl, 
                        audioUrl,
                        algorithm,
                        firstReviewDate,
                        lastReviewed,
                        nextReview,
                        difficulty,
                        streak,
                        easinessFactor,
                        interval,
                        repetitions,
                        leitnerBox
                    ] = line.split(';').map(item => item.replace(/^"|"$/g, '').trim());

                    if (front && back) {
                        // Sprawdź czy fiszka już istnieje
                        const existingFlashcard = flashcards.find(f => 
                            f.word === front && 
                            f.translation === back && 
                            f.context === (context || '')
                        );

                        if (existingFlashcard) {
                            // Aktualizuj istniejącą fiszkę, jeśli nowa ma nowsze dane
                            const existingLastReviewed = existingFlashcard.lastReviewed ? new Date(existingFlashcard.lastReviewed) : null;
                            const newLastReviewed = lastReviewed ? new Date(lastReviewed) : null;

                            if (newLastReviewed && (!existingLastReviewed || newLastReviewed > existingLastReviewed)) {
                                // Aktualizuj tylko pola związane z postępem nauki
                                existingFlashcard.firstReviewDate = firstReviewDate || existingFlashcard.firstReviewDate;
                                existingFlashcard.lastReviewed = lastReviewed || existingFlashcard.lastReviewed;
                                existingFlashcard.nextReview = nextReview || existingFlashcard.nextReview;
                                existingFlashcard.difficulty = difficulty || existingFlashcard.difficulty;
                                existingFlashcard.streak = parseInt(streak) || existingFlashcard.streak;
                                existingFlashcard.easinessFactor = parseFloat(easinessFactor) || existingFlashcard.easinessFactor;
                                existingFlashcard.interval = parseInt(interval) || existingFlashcard.interval;
                                existingFlashcard.repetitions = parseInt(repetitions) || existingFlashcard.repetitions;
                                existingFlashcard.leitnerBox = parseInt(leitnerBox) || existingFlashcard.leitnerBox;
                                updatedCount++;
                            } else {
                                duplicateCount++;
                            }
                        } else {
                            // Dodaj nową fiszkę
                            const newFlashcard = {
                                id: Date.now() + Math.random(),
                                word: front,
                                translation: back,
                                context: context || '',
                                mediaUrl: mediaUrl || '',
                                audioUrl: audioUrl || '',
                                firstReviewDate: firstReviewDate || null,
                                lastReviewed: lastReviewed || null,
                                nextReview: nextReview || null,
                                difficulty: difficulty || 'medium',
                                streak: parseInt(streak) || 0,
                                easinessFactor: parseFloat(easinessFactor) || 2.5,
                                interval: parseInt(interval) || 0,
                                repetitions: parseInt(repetitions) || 0,
                                leitnerBox: parseInt(leitnerBox) || 1,
                                createdAt: new Date().toISOString()
                            };
                            
                            flashcards.push(newFlashcard);
                            importedCount++;
                        }
                    }
                }
            }

            saveFlashcards();
            updateFlashcardTable();
            updateStats();
            
            const message = `Zaimportowano ${importedCount} nowych fiszek, zaktualizowano ${updatedCount}, pominięto ${duplicateCount} duplikatów.`;
            showNotification(message, 'success');
        };
        reader.readAsText(file);
    };
    input.click();
}

// Funkcja do przełączania informacji o powtórkach
function toggleReviewInfo() {
  console.log('Funkcja toggleReviewInfo została wywołana');
  const infoBox = document.getElementById('review-info');
  if (infoBox) {
    if (infoBox.style.display === 'none' || infoBox.style.display === '') {
      infoBox.style.display = 'block';
			infoBox.innerHTML = `
				<h3 data-translate="howDoReviewsWork">How do reviews work?</h3>
				<p data-translate="reviewExplanation">Our system uses a spaced repetition method to help you effectively memorize words:</p>
				<ul>
					<li data-translate="firstRecall">After 1st correct recall: next review in 2 days</li>
					<li data-translate="secondRecall">After 2nd correct recall: next review in 4 days</li>
					<li data-translate="thirdRecall">After 3rd correct recall: next review in 8 days</li>
					<li data-translate="fourthRecall">After 4th correct recall: next review in 16 days</li>
					<li data-translate="andSoOn">and so on...</li>
					<li data-translate="algorithmNote">The exact number of days is determined by the selected algorithm in settings (three dots)</li>
				</ul>
				<p data-translate="reviewTip">If you don't remember a word, it will return to the beginning of the cycle. Regular reviews are the key to success!</p>
				<h4 data-translate="reviewModes">Review modes:</h4>
				<ul>
					<li data-translate="dueTodayDescription">Due Today - Scheduled reviews according to the selected learning algorithm.</li>
					<li data-translate="newFlashcardsDescription2">Show 5 New Cards - Add 5 new flashcards to your learning pool. Choose your own learning pace, you can select a different amount via 'Number of cards' (on average, a person can learn 8/day).</li>
					<li data-translate="newTodayDescription">New Today Only - Repeatedly review only flashcards added today.</li>
					<li data-translate="hardFlashcardsDescription2">Hard Cards Only - Review only difficult flashcards that have already been reviewed, starting from the beginning of the deck.</li>
					<li data-translate="randomFlashcardsDescription">Random Selection - Review all flashcards that have already been reviewed, starting from the beginning of the deck.</li>
					<li data-translate="numberOfCardsDescription">Number of cards - Number of cards to display in one review session. For 'Show 5 New Cards' changes the default amount from 5 to selected (10, 20, custom).</li>
				</ul>
				<button onclick="toggleReviewInfo()" class="close-button" data-translate="close">Close</button>
			`;
      changeLanguage();
      console.log('Info box w powtórkach został wyświetlony');
    } else {
      infoBox.style.display = 'none';
      console.log('Info box w powtórkach został ukryty');
    }
  } else {
    console.error('Nie znaleziono elementu review-info');
  }
}
// Funkcja inicjalizująca aplikację
function initializeApp() {
    console.log('Inicjalizacja aplikacji...');
    loadSavedLanguage();
    debugLocalStorage();
    
    // Ustawienie domyślnych wartości przy pierwszym uruchomieniu
    if (!localStorage.getItem('reviewAlgorithm')) {
        localStorage.setItem('reviewAlgorithm', 'supermemo');
    }
    if (!localStorage.getItem('gradeButtonMode')) {
        localStorage.setItem('gradeButtonMode', 'four');
    }
    if (!localStorage.getItem('exampleButtonPrompt')) {
        localStorage.setItem('exampleButtonPrompt', 'You are an English teacher. Give me 6 sentences with the word {word}. 3 sentences and 3 questions. Use 3 different tenses. Do not inform me about tenses. Use real-world examples. \n\n After that, give me an example of a very short story, maximum 6 sentences, easy to understand. Later explain this word in the story with different words.');
    }

    // Najpierw próbujemy załadować fiszki z localStorage
    const savedFlashcards = localStorage.getItem('fiszki');
    if (savedFlashcards) {
      flashcards = JSON.parse(savedFlashcards);
      console.log('Załadowano fiszki z localStorage:', flashcards);
    } else {
      flashcards = [];
    }

  // Pobieramy dane z watchedVideos
  const watchedVideos = JSON.parse(localStorage.getItem('watchedVideos')) || {};
  const wordList = [];
  
  Object.values(watchedVideos).forEach(playlist => {
    playlist.forEach(video => {
      if (video.notes) {
        video.notes.forEach(note => {
          wordList.push({
            word: note.word,
            context: note.context,
            translation: note.translation
          });
        });
      }
    });
  });
  
  console.log('Pobrana lista słów z watchedVideos:', wordList);
  
  // Aktualizujemy istniejące i dodajemy nowe fiszki
  flashcards = updateExistingAndAddNewFlashcards(wordList);
  window.flashcards = flashcards;

  console.log('Liczba fiszek po inicjalizacji:', flashcards.length);
  saveFlashcards();
  updateFlashcardTable();
  //updateStats();
  ensureCanvasExists();
  initializeStatsSection();
  initializeReviewSection(); // Dodajemy tę linię
  showSection('view');  // Zmienione z 'add' na 'view'

  // Dodaj to na końcu funkcji
  console.log('Sprawdzanie obecności elementu canvas po inicjalizacji');
  const canvas = document.getElementById('learningProgressChart');
  console.log('Element canvas:', canvas ? 'znaleziony' : 'nie znaleziony');

  initializeAddSection();
  initializeViewSection();
  initializeStatsSection();
  initializeReviewSection();
  updateStats();
  showSection('view');  // Zmienione z 'add' na 'view'
  loadSavedLanguage();
  setupAutoResizingTextareas(); // Dodaj tę linię
   // Dodaj window.saveFlashcards i window.handleSync do globalnego obiektu
   window.saveFlashcards = saveFlashcards;
   window.handleSync = window.handleSync || handleSync; // Użyj istniejcej funkcji z synchronization.js

   // Sprawdź czy mamy zapisany klucz API i ustaw automatyczną synchronizację
   const apiKey = localStorage.getItem('pushbullet_api_key');
   if (apiKey) {
       console.log('Found API key, setting up automatic sync');
       setupAutomaticSync();
   }
      initializeSyncButton();
      initializeDeleteNotesButton();

    // Dodaj inicjalizację sprawdzania synchronizacji
   // if (typeof window.initSyncCheck === 'function') {
   //     window.initSyncCheck();
  //  }

    if (!localStorage.getItem('auto_sync')) {
        localStorage.setItem('auto_sync', 'false');
    }
    if (!localStorage.getItem('sync_interval')) {
        localStorage.setItem('sync_interval', '5');
    }
    // Zmiana: sprawdzamy czy wartość już istnieje
    if (localStorage.getItem('enable_sync_check') === null) {
        localStorage.setItem('enable_sync_check', 'true'); // Domyślnie włączone tylko przy pierwszym uruchomieniu
    }

    // Sprawdź czy sprawdzanie synchronizacji jest włączone
    if (localStorage.getItem('enable_sync_check') === 'true') {
        initSyncCheck();
    }

    // Dodaj inicjalizację ustawienia export_to_server jeśli nie istnieje (save button)
    if (localStorage.getItem('export_to_server') === null) {
        localStorage.setItem('export_to_server', 'false'); // Domyślnie wyłączone
    }

    // Dodaj inicjalizację ustawienia enable_auto_save jeśli nie istnieje (auto save during sync)
    if (localStorage.getItem('enable_auto_save') === null) {
        localStorage.setItem('enable_auto_save', 'false'); // Domyślnie wyłączone
    }

    
    // Dodaj inicjalizację ustawienia enable_sync_after_review jeśli nie istnieje (auto sync after review)
    if (localStorage.getItem('enable_sync_after_review') === null) {
        localStorage.setItem('enable_sync_after_review', 'true'); // Domyślnie wyłączone
    }
    
    // Dodaj wywołanie funkcji aktualizującej widoczność przycisku Save
    updateSaveButtonVisibility();

    // Dodaj obsługę przycisku Save
    const saveButton = document.getElementById('save-button');
    if (saveButton) {
        saveButton.addEventListener('click', handleSave);
    }

    // Sprawdź pliki save na serwerze
    if (typeof window.checkSaveFiles === 'function') {
        window.checkSaveFiles();
    }

    // Inicjalizacja trybu ciemnego
    //isDarkMode = localStorage.getItem('darkMode') === 'true';
    if (isDarkMode) {
        document.body.classList.add('dark-mode');
    }
    
    // Ustaw prawidłową ikonę przy starcie
    const darkModeIcon = document.querySelector('.dark-mode-icon');
    if (darkModeIcon) {
        darkModeIcon.textContent = isDarkMode ? '☼' : '☽';
    }
    
    // Dodaj nasłuchiwanie na przycisk trybu ciemnego
    const darkModeToggle = document.getElementById('dark-mode-toggle');
    if (darkModeToggle) {
        darkModeToggle.addEventListener('click', toggleDarkMode);
    }
    const testDate = new Date('2024-12-21'); // ustaw dowolną datę
    // Dodaj tę linię na początku funkcji
    addNewCardsForToday();

    // Dodaj obsługę słownika
    const toggleDictionaryBtn = document.getElementById('toggle-dictionary');
    const dictionaryFrame = document.getElementById('dictionary-frame');
    
    if (toggleDictionaryBtn && dictionaryFrame) {
        toggleDictionaryBtn.addEventListener('click', () => {
            const isMobileScreen = window.matchMedia('(max-width: 768px)').matches;
            
            // Najpierw usuń istniejący kontener lub iframe jeśli istnieje
            const existingContainer = document.getElementById('dictionary-container');
            if (existingContainer) {
                existingContainer.remove();
            }
            
            // Dla obu wersji (mobile i desktop) tworzymy nowy kontener
            const dictionaryContainer = document.createElement('div');
            dictionaryContainer.className = 'reps-dictionary-container'; // Usuwamy starą klasę 'dictionary-container'
            dictionaryContainer.id = 'dictionary-container';
            
            // Pobierz aktualny domyślny słownik i niestandardowe słowniki
            const defaultDictionary = localStorage.getItem('defaultDictionary');
            const customDictionaries = JSON.parse(localStorage.getItem('customDictionaries') || '[]');
            
            // Przygotuj opcje dla selecta, włączając niestandardowe słowniki
            const dictionaryOptions = [
                { url: 'https://www.onelook.com/', name: 'onelook.com' },
                { url: 'https://you.com/search?q=' + encodeURIComponent('You are an English teacher. Give me the meaning of the word in the next prompt. Just ask about the word. Explain in different words and provide me 3 example sentences with this word.') + '&tbm=youchat&chatMode=default', name: 'you.com (ai)' },
                { url: 'https://www.diki.pl/', name: 'diki.pl' },
                { url: 'https://dict.com/angielsko-polski', name: 'dict.com' },
                { url: 'https://ling.pl/', name: 'ling.pl' },
                ...customDictionaries
            ].map(dict => `
                <option value="${dict.url}" ${defaultDictionary === dict.url ? 'selected' : ''}>
                    ${dict.name}
                </option>
            `).join('');

            dictionaryContainer.innerHTML = `
                <div class="reps-dictionary-header">
                    <span class="reps-back-arrow" onclick="hideDictionary()">&#8594;</span>
                    <div class="reps-dictionary-select-container">
                        <select id="reps-dictionary-select" class="reps-dictionary-select" onchange="repsChangeDictionary()">
                            ${dictionaryOptions}
                            <option value="add_new">Add new</option>
                            <option value="remove_dictionary">Remove dictionary</option>
                        </select>
                    </div>
                </div>
                
                <div class="reps-default-checkbox-container">
                    <input type="checkbox" id="reps-dictionary-default-checkbox" 
                           ${defaultDictionary ? 'checked' : ''} 
                           onchange="setDefaultDictionary()">
                    <label for="reps-dictionary-default-checkbox" title="Set as default dictionary">
                        Set as Default
                        <span class="reps-default-indicator">${defaultDictionary ? '' : ''}</span>
                    </label>
                </div>
                
                <div class="reps-iframe-container">
                    <iframe class="reps-dictionary-frame-mobile" src="${defaultDictionary || 'https://www.onelook.com/'}"></iframe>
                </div>`;
            
            // Wstawiamy nowy kontener w miejsce iframe'a
            dictionaryFrame.parentNode.insertBefore(dictionaryContainer, dictionaryFrame);
            dictionaryContainer.classList.add('show');
            
            // Ukrywamy oryginalny iframe
            dictionaryFrame.style.display = 'none';
        });
    }
}

// Dodaj tę funkcję do sprawdzania i dodawania nowych kart na początku dnia
function addNewCardsForToday(testDate = null) {
    const now = testDate || new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const lastAddDate = localStorage.getItem('last_new_cards_add_date');
    
    // Sprawdź czy już dodano karty dzisiaj - porównaj pełne daty
    if (lastAddDate) {
        const lastDate = new Date(lastAddDate);
        if (lastDate.getFullYear() === today.getFullYear() &&
            lastDate.getMonth() === today.getMonth() &&
            lastDate.getDate() === today.getDate()) {
            return; // Już dodano karty dzisiaj
        }
    }

    // Pobierz liczbę nowych kart do dodania
    const newCardsPerDay = parseInt(localStorage.getItem('new_cards_per_day')) || 0; // Zmieniono z 5 na 0
    if (newCardsPerDay <= 0) return; // Jeśli ustawiono 0, nie dodawaj kart

    // Znajdź wszystkie karty, które nigdy nie były przeglądane
    const newCards = flashcards.filter(f => !f.lastReviewed);
    
    // Wybierz określoną liczbę kart
    const cardsToAdd = newCards.slice(0, newCardsPerDay);
    
    // Oznacz wybrane karty jako dodane dzisiaj i due today
    cardsToAdd.forEach(card => {
        card.firstReviewDate = today.toISOString();
        card.nextReview = today.toISOString();
        card.lastReviewed = today.toISOString(); // Zmienione z null na today.toISOString()
    });

    // Zapisz datę dodania kart
    localStorage.setItem('last_new_cards_add_date', today.toISOString());
    
    // Zapisz zaktualizowane fiszki
    saveFlashcards();
}

// Dodaj tę funkcję, aby upewnić się, że przycisk Info jest prawidłowo dodany
function ensureStatsInfoButtonExists() {
  const statsSection = document.getElementById('stats');
  if (statsSection) {
    let infoButton = statsSection.querySelector('.info-button');
    if (!infoButton) {
      const statsHeader = statsSection.querySelector('.stats-header');
      if (statsHeader) {
        infoButton = document.createElement('button');
        infoButton.className = 'info-button';
        infoButton.textContent = 'Info';
        infoButton.onclick = toggleStatsInfo;
        statsHeader.appendChild(infoButton);
        console.log('Przycisk Info został dodany do sekcji statystyk');
      } else {
        console.error('Nie znaleziono nagłówka statystyk');
        // Jeśli nie ma nagłówka, utwórz go
        const header = document.createElement('div');
        header.className = 'stats-header';
        header.innerHTML = `
          <h2>Statystyki</h2>
          <button onclick="toggleStatsInfo()" class="info-button">Info</button>
        `;
        statsSection.insertBefore(header, statsSection.firstChild);
        console.log('Utworzono nagłówek statystyk z przyciskiem Info');
      }
    } else {
      console.log('Przycisk Info już istnieje w sekcji statystyk');
    }
  } else {
    console.error('Nie znaleziono sekcji statystyk');
  }
}

// Funkcja do aktualizacji istniejących i dodawania nowych fiszek
function updateExistingAndAddNewFlashcards(wordList) {
  const updatedFlashcards = [...flashcards];
  
  wordList.forEach(word => {
    const existingFlashcard = updatedFlashcards.find(f => 
      f.word === word.word && f.translation === word.translation
    );
    
    if (existingFlashcard) {
      existingFlashcard.context = word.context;
      //existingFlashcard.lastModified = new Date().toISOString();
    } else {
      const now = new Date().toISOString();
      const nowMs = Date.now();
      updatedFlashcards.push({
        id: nowMs + Math.random(),
        word: word.word,
        context: word.context,
        translation: word.translation,
        mediaUrl: '',
        audioUrl: '',
        repeats: 0,
        lastReviewed: null,
        firstReviewDate: null,
        createdAt: now,
        lastModified: null,
        difficulty: 'medium',
        nextReview: null,
        easinessFactor: 2.5,
        interval: 0,
        repetitions: 0,
        leitnerBox: 1,
        lastSync: null,
        streak: 0
      });
    }
  });
  
  return updatedFlashcards;
}

function debugLocalStorage() {
  console.log('Zawartość localStorage:');
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    console.log(`${key}: ${localStorage.getItem(key)}`);
  }
}

function isLocalStorageAvailable() {
  try {
    localStorage.setItem('test', 'test');
    localStorage.removeItem('test');
    return true;
  } catch(e) {
    console.error('localStorage nie jest dostępny:', e);
    return false;
  }
}

// Modyfikujemy istniejce nasłuchiwanie na załadowanie strony
window.addEventListener('load', function() {
  if (isLocalStorageAvailable()) {
    initializeApp();
    changeLanguage();
  } else {
    alert('Twoja przeglądarka nie obsługuje localStorage. Aplikacja może nie działać poprawnie.');
  }
});

// Nasłuchiwanie na załadowanie strony
window.addEventListener('load', initializeApp);

// Nasłuchiwanie na submit formularza dodawania fiszki
document.getElementById('addForm').addEventListener('submit', function(e) {
  e.preventDefault();
  let word = document.getElementById('word').value.trim();
  let context = document.getElementById('context').value.trim();
  let translation = document.getElementById('translation').value.trim();
  let mediaUrl = document.getElementById('mediaUrl').value.trim();
  let audioUrl = document.getElementById('audioUrl').value.trim();
  if (word && translation) {
    addFlashcard(word, context, translation, mediaUrl, audioUrl);
    this.reset();
  }
});

// Funkcja do restartu powtórki nieznanych fiszek
function restartUnknownReview() {
  flashcardsToReview = flashcards.filter(flashcard => flashcard.repeats === 0);
  currentFlashcardIndex = 0;
  showNextFlashcard();
  updateFlashcardTable();
}

function getNextReviewDate(flashcards) {
  let now = new Date();
  let nextReview = new Date(now.getTime() + (365 * 24 * 60 * 60 * 1000)); // Ustaw na rok w przyszość jako wartość domyślną
  flashcards.forEach(flashcard => {
    if (flashcard.lastReviewed) {
      let lastReviewed = new Date(flashcard.lastReviewed);
      let interval = Math.pow(2, flashcard.repeats) * 24 * 60 * 60 * 1000;
      let nextReviewForCard = new Date(lastReviewed.getTime() + interval);
      if (nextReviewForCard < nextReview) {
        nextReview = nextReviewForCard;
      }
    }
  });
  return nextReview;
}

function formatDate(date) {
  return date.toLocaleString('pl-PL', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric', 
    hour: '2-digit', 
    minute: '2-digit' 
  });
}

function restoreOriginalContent() {
  const container = document.querySelector('.container');
  container.innerHTML = `
    <section id="add" class="section hidden">
      <div class="section-header">
        <h2>Dodaj nową fiszkę</h2>
      </div>
      <form id="addForm">
        <textarea id="word" placeholder="Słowo / Fraza" required></textarea>
        <textarea id="context" placeholder="Kontekst / Przykład"></textarea>
        <textarea id="translation" placeholder="Tłumaczenie" required></textarea>
        <input type="text" id="mediaUrl" placeholder="Link do obrazu (http)">
        <input type="text" id="audioUrl" placeholder="Link do audio (http)">
        <button type="submit" class="submit-button">Dodaj fiszkę</button>
      </form>
    </section>
    <section id="view" class="section hidden">
      <div class="section-header">
        <h2>Twoje fiszki</h2>
      </div>
      <table id="flashcardTable">
        <thead>
          <tr>
            <th>Lp.</th>
            <th>Słowo / Fraza</th>
            <th>Kontekst / Przykład</th>
            <th>Tłumaczenie</th>
            <th>Znam</th>
            <th>Media</th>
            <th>Audio</th>
            <th>Akcje</th>
          </tr>
        </thead>
        <tbody>
          <!-- Wiersze tabeli będą generowane dynamicznie -->
        </tbody>
      </table>
    </section>
    <section id="review" class="section hidden">
      <div class="section-header">
        <h2>Powtórki</h2>
        <button onclick="toggleReviewInfo()" class="info-button">Info</button>
      </div>
      <div id="reviewCard"></div>
      <div id="review-info" class="info-box" style="display: none;">
        <!-- Zawartość info-box -->
      </div>
    </section>
    <section id="stats" class="section hidden">
      <div class="section-header">
        <h2>Statystyki</h2>
        <button onclick="toggleStatsInfo()" class="info-button">Info</button>
      </div>
      <div class="stats">
        <p>Całkowita liczba fiszek: <span id="totalFlashcards">0</span></p>
        <p>Obecny stan znajomości fiszek: <span id="knownFlashcards">0%</span></p>
        <p class="info-tooltip" data-tooltip="To liczba fiszek, które:&#10;1. Zostały powtórzone co najmniej 5 razy (uznawane za opanowane).&#10;2. Ich ostatnie powtórzenie miało miejsce w ciągu ostatnich 7 dni.">
          Liczba opanowanych przez ostatnie 7 dni: <span id="masteredLast7Days">0</span>
        </p>
      </div>
      <canvas id="learningProgressChart" width="300" height="200"></canvas>
      <canvas id="learningProgressLineChart" width="300" height="275"></canvas>
      <div id="stats-info" class="info-box" style="display: none;">
        <!-- Zawartość info-box dla statystyk -->
      </div>
    </section>
  `;
  
  // Ponowne dodanie nasuchiwania na formularz
  document.getElementById('addForm').addEventListener('submit', function(e) {
    e.preventDefault();
    let word = document.getElementById('word').value.trim();
    let context = document.getElementById('context').value.trim();
    let translation = document.getElementById('translation').value.trim();
    let mediaUrl = document.getElementById('mediaUrl').value.trim();
    let audioUrl = document.getElementById('audioUrl').value.trim();
    if (word && translation) {
      addFlashcard(word, context, translation, mediaUrl, audioUrl);
      this.reset();
    }
  });

  // Dodajemy wywołanie setupAutoResizingTextareas
  setupAutoResizingTextareas();

  // Aktualizujemy statystyki i wykresy
  updateStats();
}

// Funkcja do usuwania fiszki
function deleteFlashcard(id) {
    const index = flashcards.findIndex(f => f.id === id);
    if (index !== -1) {
        const confirmDialog = document.createElement('div');
        confirmDialog.className = 'confirm-dialog';
        confirmDialog.innerHTML = `
            <div class="confirm-content">
                <h3 data-translate="confirmDelete">Delete Flashcard</h3>
                <p data-translate="confirmDeleteMessage">Are you sure you want to delete this flashcard?</p>
                <p class="sync-warning" data-translate="syncDeleteWarning">Note: If you are using Synchronization, to prevent the deleted flashcard from reappearing in the table, you must also delete all notes on the server. Settings -> Delete all Notes. Then press the Sync button to update the flashcards on the server.</p>
                <div class="confirm-buttons">
                    <button class="confirm-yes" data-translate="yes">Yes</button>
                    <button class="confirm-no" data-translate="no2">No</button>
                </div>
            </div>
        `;

        document.body.appendChild(confirmDialog);
        changeLanguage();

        return new Promise((resolve) => {
            const yesButton = confirmDialog.querySelector('.confirm-yes');
            const noButton = confirmDialog.querySelector('.confirm-no');

            yesButton.addEventListener('click', () => {
                flashcards.splice(index, 1);
                saveFlashcards();
                updateFlashcardTable();
                updateStats();
                confirmDialog.remove();
                resolve(true);
            });

            noButton.addEventListener('click', () => {
                confirmDialog.remove();
                resolve(false);
            });

            confirmDialog.addEventListener('click', (e) => {
                if (e.target === confirmDialog) {
                    confirmDialog.remove();
                    resolve(false);
                }
            });
        });
    }
}

function setupAutoResizingTextareas() {
    const textareas = document.querySelectorAll('textarea');
    textareas.forEach(textarea => {
        textarea.setAttribute('rows', 1);
        textarea.style.height = 'auto';
        textarea.style.height = (textarea.scrollHeight) + 'px';
        textarea.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });
    });
}

// Dodaj tę nową funkcję do dostosowywania wysokości pól tekstowych
function adjustTextareaHeight(id, content) {
  const textarea = document.getElementById(id);
  if (textarea) {
    // Ustawiamy minimalną wysokość
    textarea.style.height = '18px';
    
    // Ustawiamy zawartość textarea
    textarea.value = content;
    
    // Obliczamy liczbę wierszy
    const lineHeight = 18; // Zakładamy, że wysokość jednej linii to 18px
    const lines = content.split('\n').length;
    
    // Ustawiamy wysokość na podstawie liczby wierszy, ale nie mniej niż 18px
    const newHeight = Math.max(18, lines * lineHeight);
    textarea.style.height = newHeight + 'px';
    
    // Dodajemy nasłuchiwanie na zdarzenie input
    textarea.addEventListener('input', function() {
      this.style.height = '18px';
      const newHeight = Math.max(18, this.scrollHeight);
      this.style.height = newHeight + 'px';
    });
  }
}

// Dodajemy na końcu pliku .vscode/quiz.js

function ensureCanvasExists() {
  const statsSection = document.getElementById('stats');
  if (statsSection) {
    let canvas = document.getElementById('learningProgressChart');
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.id = 'learningProgressChart';
      canvas.width = 300;
      canvas.height = 200;
      statsSection.appendChild(canvas);
      console.log('Canvas został utworzony i dodany do sekcji statystyk');
    } else {
      console.log('Canvas już istnieje');
    }
    return canvas;
  }
  console.error('Nie znaleziono sekcji statystyk');
  return null;
}



// Dodajemy funkcję testową dla canvas
function testCanvas() {
  const canvas = document.getElementById('learningProgressChart');
  if (canvas && canvas.getContext) {
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'green';
    ctx.fillRect(10, 10, 100, 100);
    console.log('Canvas działa poprawnie');
  } else {
    console.error('Canvas nie jest obsługiwany w tej przeglądarce lub nie został znaleziony');
  }
}

// Wywołujemy funkcję testową po załadowaniu DOM
document.addEventListener('DOMContentLoaded', testCanvas);

function toggleStatsInfo() {
  console.log('Funkcja toggleStatsInfo została wywołana');
  const infoBox = document.getElementById('stats-info');
  if (infoBox) {
    if (infoBox.style.display === 'none' || infoBox.style.display === '') {
      infoBox.style.display = 'block';
      infoBox.innerHTML = `
        <h3 data-translate="flashcardCategories">Flashcard categories:</h3>
        <ol>
          <li><strong data-translate="newFlashcards">New</strong> <span data-translate="newFlashcardsDescription">(green): Flashcards that haven't been reviewed yet or weren't remembered.</span></li>
          <li><strong data-translate="learningFlashcards">Learning</strong> <span data-translate="learningFlashcardsDescription">(blue): Flashcards that were correctly reviewed 1 to 4 times.</span></li>
          <li><strong data-translate="masteredFlashcards">Mastered</strong> <span data-translate="masteredFlashcardsDescription">(turquoise): Flashcards that were correctly reviewed 5 or more times.</span></li>
        </ol>
        <button onclick="toggleStatsInfo()" class="close-button" data-translate="close">Close</button>
      `;
      changeLanguage(); // Dodajemy to wywołanie, aby przetłumaczyć nowo wygenerowaną zawartość
      console.log('Info box w statystykach został wyświetlony');
    } else {
      infoBox.style.display = 'none';
      console.log('Info box w statystykach został ukryty');
    }
  } else {
    console.error('Nie znaleziono elementu stats-info');
  }
}

// Dodaj tę funkcję na końcu pliku
function initializeStatsSection() {
  const statsSection = document.getElementById('stats');
  if (statsSection) {
    // Usuń wszystkie istniejące nagłówki i dodatkowe napisy "Statystyki"
    statsSection.querySelectorAll('.section-header, .stats-header, h2').forEach(el => el.remove());

    // Dodaj nowy nagłówek
    const header = document.createElement('div');
    header.className = 'section-header';
    header.innerHTML = `
      <h2>Statystyki</h2>
      <button onclick="toggleStatsInfo()" class="info-button">Info</button>
    `;
    statsSection.insertBefore(header, statsSection.firstChild);

    // Upewnij się, że istnieje kontener na informacje
    if (!statsSection.querySelector('#stats-info')) {
      const infoBox = document.createElement('div');
      infoBox.id = 'stats-info';
      infoBox.className = 'info-box';
      infoBox.style.display = 'none';
      statsSection.appendChild(infoBox);
    }

    ensureCanvasExists();
  }
}

// Dodajemy na końcu pliku .vscode/quiz.js

function initializeReviewSection() {
  const reviewSection = document.getElementById('review');
  if (reviewSection) {
    // Usuń wszystkie istniejące nagłówki i przyciski Info
    reviewSection.querySelectorAll('.section-header, .review-header, h2, .info-button').forEach(el => el.remove());

    // Dodaj nowy nagłówek z ikoną strzałki powrotu, ikoną trzech kropek i przyciskiem Info
    const header = document.createElement('div');
    header.className = 'section-header';
    header.innerHTML = `
      <div class="review-header-left">
        <h2 data-translate="review">${translations[currentLanguage].review}</h2>
      </div>
      <div class="review-header-right">
        <button onclick="goBackFlashcard()" class="go-back-button" data-tooltip="${translations[currentLanguage].goBack}">←</button>
        <button onclick="openReviewSettings()" class="more-options-button" data-tooltip="${translations[currentLanguage].settings}">⋮</button>
        <button onclick="toggleReviewInfo()" class="info-button" data-translate="info">${translations[currentLanguage].info}</button>
      </div>
    `;
    reviewSection.insertBefore(header, reviewSection.firstChild);

    // Upewnij się, że istnieje kontener na informacje
    if (!reviewSection.querySelector('#review-info')) {
      const infoBox = document.createElement('div');
      infoBox.id = 'review-info';
      infoBox.className = 'info-box';
      infoBox.style.display = 'none';
      reviewSection.appendChild(infoBox);
    }

    // Upewnij się, że istnieje kontener na kartę do powtórki
    if (!reviewSection.querySelector('#reviewCard')) {
      const reviewCard = document.createElement('div');
      reviewCard.id = 'reviewCard';
      reviewSection.appendChild(reviewCard);
    }
  }
}

// Dodaj nową funkcję do obsługi kliknięcia przycisku ustawień
function openReviewSettings() {
    let settingsForm = document.getElementById('review-settings-form');
    if (settingsForm) {
        settingsForm.remove();
    }

    // Zmiana domyślnych wartości
    const currentAlgorithm = localStorage.getItem('reviewAlgorithm') || 'supermemo';
    const currentButtonMode = localStorage.getItem('gradeButtonMode') || 'four';
    const currentNewCardsPerDay = localStorage.getItem('new_cards_per_day') || '5';
    
    const overlay = document.createElement('div');
    overlay.className = 'settings-overlay';
    overlay.id = 'settings-overlay';
    
    settingsForm = document.createElement('div');
    settingsForm.id = 'review-settings-form';
    settingsForm.className = 'settings-form';
    settingsForm.innerHTML = `
        <h3 data-translate="reviewSettings">Review Settings</h3>
        <div class="settings-group">
            <!-- Zmieniony tekst labela -->
            <div class="new-cards-settings">
                <label data-translate="automaticNewCards">Add automatically number of new cards every day:</label>
                <div class="radio-group horizontal">  <!-- Dodano klasę horizontal -->
                    <label class="radio-option">
                        <input type="radio" name="newCardsPerDay" value="0" 
                            ${currentNewCardsPerDay === '0' ? 'checked' : ''}>
                        <span class="radio-label">0</span>  <!-- Dodano klasę radio-label -->
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="newCardsPerDay" value="5" 
                            ${currentNewCardsPerDay === '5' ? 'checked' : ''}>
                        <span class="radio-label">5</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="newCardsPerDay" value="10" 
                            ${currentNewCardsPerDay === '10' ? 'checked' : ''}>
                        <span class="radio-label">10</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="newCardsPerDay" value="custom" 
                            ${!['0', '5', '10'].includes(currentNewCardsPerDay) ? 'checked' : ''}>
                        <span class="radio-label" data-translate="custom">Custom</span>
                        <input type="number" id="customNewCards" 
                            value="${!['0', '5', '10'].includes(currentNewCardsPerDay) ? currentNewCardsPerDay : '15'}"
                            min="1" max="100" 
                            class="${!['0', '5', '10'].includes(currentNewCardsPerDay) ? '' : 'hidden'}"
                            onclick="event.stopPropagation()">
                    </label>
                </div>
            </div>
        </div>

        <div class="settings-group review-modes-options">
            <label data-translate="reviewModesVisibility">Show review modes:</label>
            <div class="checkbox-option">
                <label class="checkbox-label">
                    <input type="checkbox" id="show-new-today" ${localStorage.getItem('show_new_today') !== 'false' ? 'checked' : ''}>
                    <span data-translate="newTodayOnly">New Cards From Today Only</span>
                </label>
            </div>
            <div class="checkbox-option">
                <label class="checkbox-label">
                    <input type="checkbox" id="show-hard-cards" ${localStorage.getItem('show_hard_cards') !== 'false' ? 'checked' : ''}>
                    <span data-translate="hardFlashcardsOnly">Hard Cards Only</span>
                </label>
            </div>
            <div class="checkbox-option">
                <label class="checkbox-label">
                    <input type="checkbox" id="show-random" ${localStorage.getItem('show_random') !== 'false' ? 'checked' : ''}>
                    <span data-translate="randomFlashcards">Random Selection</span>
                </label>
            </div>
            <!-- Dodaj nową opcję -->
            <div class="checkbox-option">
                <label class="checkbox-label">
                    <input type="checkbox" id="show-cards-number" ${localStorage.getItem('show_cards_number') === 'true' ? 'checked' : ''}>
                    <span data-translate="showCardsNumber">Show Number of cards limit</span>
                </label>
            </div>
        </div>

        <h3 data-translate="algorithmSettings">Algorithm Settings</h3>
        <div class="settings-group">
            <label data-translate="currentAlgorithm">Current Algorithm:</label>
            <select id="algorithmSelect">
                <option value="standard" ${currentAlgorithm === 'standard' ? 'selected' : ''} 
                        data-translate="standardAlgorithm">Standard Algorithm</option>
                <option value="supermemo" ${currentAlgorithm === 'supermemo' ? 'selected' : ''} 
                        data-translate="superMemoAlgorithm">SuperMemo Algorithm</option>
                <option value="leitner" ${currentAlgorithm === 'leitner' ? 'selected' : ''} 
                        data-translate="leitnerAlgorithm">Leitner System</option>
            </select>
        </div>
        <div class="settings-group">
            <label data-translate="gradeButtonsOption">Grade buttons:</label>
            <select id="buttonModeSelect">
                <option value="four" ${currentButtonMode === 'four' ? 'selected' : ''} 
                        data-translate="fourButtons">4 buttons</option>
                <option value="six" ${currentButtonMode === 'six' ? 'selected' : ''} 
                        data-translate="sixButtons">6 buttons</option>
            </select>
        </div>
        <div class="algorithm-description">
            <p data-translate="algorithmDescription">Algorithm Description:</p>
            <p id="algorithmInfo" class="description-text">
                ${getAlgorithmDescription(currentAlgorithm)}
            </p>
        </div>
        <div class="more-info">
            <p><span data-translate="moreInfo">More information</span>: <a href="https://github.com/theaidran/YoutubeReps" target="_blank">https://github.com/theaidran/YoutubeReps</a></p>
        </div>
        <div class="button-group">
            <button type="button" onclick="saveAlgorithmSettings()" 
                    class="submit-button" data-translate="saveSettings">Save Settings</button>
            <button type="button" onclick="closeReviewSettings()" 
                    class="cancel-button" data-translate="cancel">Cancel</button>
        </div>
    `;

    const reviewSection = document.getElementById('review');
    reviewSection.appendChild(overlay);
    reviewSection.appendChild(settingsForm);
    
    document.getElementById('algorithmSelect').addEventListener('change', function(e) {
        document.getElementById('algorithmInfo').textContent = getAlgorithmDescription(e.target.value);
    });

    // Zmiana obsługi kliknięcia na overlay
    overlay.addEventListener('click', () => {
        saveAlgorithmSettings();
    });

    // Dodaj obsługę radio buttonów dla nowych kart
    settingsForm.querySelectorAll('input[name="newCardsPerDay"]').forEach(radio => {
        radio.addEventListener('change', function() {
            const customInput = document.getElementById('customNewCards');
            customInput.classList.toggle('hidden', this.value !== 'custom');
        });
    });

    changeLanguage();
}

// Dodaj funkcję pomocniczą do pobierania opisu algorytmu
function getAlgorithmDescription(algorithm) {
    switch(algorithm) {
        case 'standard':
            return translations[currentLanguage].standardDescription;
        case 'supermemo':
            return translations[currentLanguage].superMemoDescription;
        case 'leitner':
            return translations[currentLanguage].leitnerDescription;
        default:
            return translations[currentLanguage].standardDescription;
    }
}
/*
// Dodaj podstawową strukturę dla systemu Leitnera
function initializeLeitnerSystem(flashcard) {
    if (!flashcard.leitnerBox) {
        flashcard.leitnerBox = 1;  // Wszystkie nowe fiszki zaczynają w pudełku 1
    }
} */

function closeReviewSettings() {
    const settingsForm = document.getElementById('review-settings-form');
    const overlay = document.getElementById('settings-overlay');
    if (settingsForm) {
        settingsForm.remove();
    }
    if (overlay) {
        overlay.remove();
    }
}

function saveAlgorithmSettings() {
    const algorithm = document.getElementById('algorithmSelect').value;
    const buttonMode = document.getElementById('buttonModeSelect').value;
    const showNewToday = document.getElementById('show-new-today').checked;
    const showHardCards = document.getElementById('show-hard-cards').checked;
    const showRandom = document.getElementById('show-random').checked;
    const showCardsNumber = document.getElementById('show-cards-number').checked;
    
    // Dodaj zapisywanie liczby nowych kart
    const selectedNewCards = document.querySelector('input[name="newCardsPerDay"]:checked');
    let newCardsPerDay = selectedNewCards.value;
    if (newCardsPerDay === 'custom') {
        newCardsPerDay = document.getElementById('customNewCards').value;
    }
    
    localStorage.setItem('reviewAlgorithm', algorithm);
    localStorage.setItem('gradeButtonMode', buttonMode);
    localStorage.setItem('show_new_today', showNewToday);
    localStorage.setItem('show_hard_cards', showHardCards);
    localStorage.setItem('show_random', showRandom);
    localStorage.setItem('new_cards_per_day', newCardsPerDay); // Dodaj tę linię
    localStorage.setItem('show_cards_number', showCardsNumber);
    
    updateStats();
    drawLearningProgressChart();
    closeReviewSettings();
    showReviewModeSelection();
}

function initializeAddSection() {
  const addSection = document.getElementById('add');
  if (addSection) {
    // Usuń wszystkie istniejące nagłwki
    addSection.querySelectorAll('.section-header, h2').forEach(el => el.remove());

    // Dodaj nowy nagłówek
    const newHeader = document.createElement('div');
    newHeader.className = 'section-header';
    newHeader.innerHTML = `<h2 data-translate="addNewFlashcard">Add New Flashcard</h2>`;
    addSection.insertBefore(newHeader, addSection.firstChild);

    // Ustaw automatyczne rozszerzanie się pól tekstowych
    setupAutoResizingTextareas();
  }
}

function initializeViewSection() {
  const viewSection = document.getElementById('view');
  if (viewSection) {
    // Usuń wszystkie istniejące nagłówki
    viewSection.querySelectorAll('.section-header, h2').forEach(el => el.remove());

    // Dodaj nowy nagłówek bez przycisku "Usuń wszystkie"
    const newHeader = document.createElement('div');
    newHeader.className = 'section-header';
    newHeader.innerHTML = `
      <h2 data-translate="yourFlashcards">Your Flashcards</h2>
    `;
    viewSection.insertBefore(newHeader, viewSection.firstChild);
  }
}

// Dodaj tę funkcję gdzieś w pliku quiz.js
function countMasteredLast7Days() {
    const now = new Date();
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    
    return flashcards.filter(flashcard => 
        flashcard.repeats >= 5 && 
        flashcard.lastReviewed && 
        new Date(flashcard.lastReviewed) >= sevenDaysAgo
    ).length;
}

// Dodaj tę nową funkcję
function generateStatsHTML() {
  return `
    <div class="section-header">
      <h2 data-translate="statistics">Statistics</h2>
      <button onclick="toggleStatsInfo()" class="info-button" data-translate="info">Info</button>
    </div>
    <div class="stats">
      <p><span data-translate="totalFlashcards">Total number of flashcards:</span> <span id="totalFlashcards">0</span></p>
      <p class="info-tooltip" data-tooltip="currentKnowledgeStateTooltip">
        <span data-translate="currentKnowledgeState">Current knowledge state of all flashcards:</span> <span id="knownFlashcards">0%</span>
      </p>
      <p class="info-tooltip" data-tooltip="masteredLast7DaysTooltip">
        <span data-translate="masteredLast7Days">Number mastered in the last 7 days:</span> <span id="masteredLast7Days">0</span>
      </p>
    </div>
    <canvas id="learningProgressChart" width="300" height="200"></canvas>
    <div id="stats-info" class="info-box" style="display: none;">
      <!-- Zawartość info-box dla statystyk -->
    </div>
  `;
}

// Dodaj tę funkcję do obliczania liczby znanych fiszek
function countKnownFlashcards() {
    return flashcards.filter(f => f.repeats > 0).length;
}

function changeLanguage() {
    currentLanguage = document.getElementById('language-select').value;
    console.log('Zmieniono język na:', currentLanguage);
    
    // Aktualizuj teksty na stronie
    document.querySelectorAll('[data-translate]').forEach(element => {
        const key = element.getAttribute('data-translate');
        if (translations[currentLanguage] && translations[currentLanguage][key]) {
            element.textContent = translations[currentLanguage][key];
        }
    });
    
    // Aktualizuj placeholdery
    document.querySelectorAll('[data-placeholder]').forEach(element => {
        const key = element.getAttribute('data-placeholder');
        if (translations[currentLanguage] && translations[currentLanguage][key]) {
            element.placeholder = translations[currentLanguage][key];
        }
    });
    
    // Aktualizuj tooltipy
    document.querySelectorAll('[data-tooltip]').forEach(element => {
        if (element.classList.contains('grade-0')) {
            // Specjalne traktowanie dla przycisku grade-0
            element.setAttribute('data-tooltip', translations[currentLanguage].startOverTooltip);
        } else {
            const key = element.getAttribute('data-tooltip');
            if (translations[currentLanguage] && translations[currentLanguage][key]) {
                element.setAttribute('data-tooltip', translations[currentLanguage][key]);
            }
        }
    });
    // Aktualizuj tooltips w sekcji statystyk
    const statsTooltips = {
      'currentKnowledgeState': 'currentKnowledgeStateTooltip',
      'masteredLast7Days': 'masteredLast7DaysTooltip'
  };

  Object.entries(statsTooltips).forEach(([selector, tooltipKey]) => {
      const element = document.querySelector(`p:has(span[data-translate="${selector}"])`);
      if (element) {
          element.setAttribute('data-tooltip', translations[currentLanguage][tooltipKey]);
      }
  });
    
    // Aktualizuj przycisk Dictionary
    const dictionaryButton = document.getElementById('toggle-dictionary');
    if (dictionaryButton) {
        dictionaryButton.textContent = translations[currentLanguage].dictionary;
    }
    
    // Aktualizuj wykres
    drawLearningProgressChart();
    
    // Inicjalizuj sekcję powtórek, aby zaktualizować tekst dymka
    initializeReviewSection();
    
    // Zapisz wybrany język w localStorage
    localStorage.setItem('selectedLanguage', currentLanguage);
    
    // Dodaj to wywołanie na końcu funkcji
    //updateFlashcardTable();
}

// Dodaj tę funkcję, aby załadować zapisany język przy starcie
function loadSavedLanguage() {
    const savedLang = localStorage.getItem('selectedLanguage');
    if (savedLang) {
        currentLanguage = savedLang;
        document.getElementById('language-select').value = currentLanguage;
        changeLanguage();
    }
}

function deleteAllFlashcards() {
    const confirmDialog = document.createElement('div');
    confirmDialog.className = 'confirm-dialog';
    confirmDialog.innerHTML = `
        <div class="confirm-content">
            <h3 data-translate="confirmDeleteAll">Delete All Flashcards</h3>
            <p data-translate="confirmDeleteAllMessage">Are you sure you want to delete all flashcards? This action cannot be undone.</p>
            <p class="sync-warning" data-translate="syncDeleteWarning">Note: If you are using Synchronization, to prevent the deleted flashcards from reappearing in the table, you must also delete all notes on the server. Settings -> Delete all Notes. Then press the Sync button to update the flashcards on the server.</p>
            <div class="confirm-buttons">
                <button class="confirm-yes" data-translate="yes">Yes</button>
                <button class="confirm-no" data-translate="no2">No</button>
            </div>
        </div>
    `;

    document.body.appendChild(confirmDialog);
    changeLanguage();

    return new Promise((resolve) => {
        const yesButton = confirmDialog.querySelector('.confirm-yes');
        const noButton = confirmDialog.querySelector('.confirm-no');

        yesButton.addEventListener('click', () => {
            flashcards = [];
            saveFlashcards();
            updateFlashcardTable();
            updateStats();
            drawLearningProgressChart();
            // Resetujemy czas ostatniej synchronizacji
            localStorage.setItem('last_sync_time', '0');
            confirmDialog.remove();
            resolve(true);
        });

        noButton.addEventListener('click', () => {
            confirmDialog.remove();
            resolve(false);
        });

        confirmDialog.addEventListener('click', (e) => {
            if (e.target === confirmDialog) {
                confirmDialog.remove();
                resolve(false);
            }
        });
    });
}

function goBackFlashcard() {
  if (currentFlashcardIndex > 0) {
    currentFlashcardIndex--;
    showNextFlashcard();
  } else {
    alert(translations[currentLanguage].noMoreFlashcardsToGoBack || "No more flashcards to go back to.");
  }
}

// Dodaj tę funkcję do obsługi zaznaczania wierszy
function toggleRowSelection(row) {
  row.classList.toggle('selected-row');
}

// Dodaj tę funkcję, aby umożliwić zaznaczanie wielu wierszy
function toggleMultipleRowSelection(event) {
  if (event.shiftKey) {
    const rows = document.querySelectorAll('#flashcardTable tbody tr');
    let startIndex = -1;
    let endIndex = -1;

    rows.forEach((row, index) => {
      if (row.classList.contains('selected-row')) {
        if (startIndex === -1) startIndex = index;
        endIndex = index;
      }
    });

    if (startIndex !== -1 && endIndex !== -1) {
      for (let i = Math.min(startIndex, endIndex); i <= Math.max(startIndex, endIndex); i++) {
        rows[i].classList.add('selected-row');
      }
    }
  }
}

// Dodaj nasłuchiwanie na kliknięcia z wciśniętym Shiftem
document.addEventListener('click', toggleMultipleRowSelection);


function updateCardCounts() {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const algorithm = localStorage.getItem('reviewAlgorithm') || 'standard';
    
    // Fiszki na dziś
    const dueTodayCount = flashcards.filter(f => f.lastReviewed && f.nextReview && new Date(f.nextReview) <= now).length;   
    // Nowe fiszki - te, które nigdy nie były pokazywane
    const newCount = flashcards.filter(f => !f.lastReviewed).length;
    
    // Nowe fiszki z dzisiaj - pierwsza powtórka była dzisiaj
    const newTodayCount = flashcards.filter(f => {
      if (!f.firstReviewDate) return false;
      const reviewDate = new Date(f.firstReviewDate);
      return reviewDate.getFullYear() === today.getFullYear() &&
             reviewDate.getMonth() === today.getMonth() &&
             reviewDate.getDate() === today.getDate();
  }).length;


    // Trudne fiszki - zależnie od algorytmu
    let hardCount = 0;
    switch (algorithm) {
      case 'supermemo':
        hardCount = flashcards.filter(f => 
            f.lastReviewed && f.easinessFactor && f.easinessFactor < 2.1
        ).length;
        break;
    case 'leitner':
        hardCount = flashcards.filter(f => 
            f.lastReviewed && f.leitnerBox && f.leitnerBox < 2
        ).length;
        break;
    default:
        hardCount = flashcards.filter(f => 
            f.lastReviewed && (f.difficulty === 'hard' || f.difficulty === 'veryHard')
        ).length;
   }
    
    const totalCount = flashcards.filter(f => // fiszki dla funkcji random 
      f.lastReviewed ).length;

    document.getElementById('dueTodayCount').textContent = dueTodayCount; // na dziś
    document.getElementById('newCount').textContent = newCount;// wszytkie nowe fiszki
    document.getElementById('newTodayCount').textContent = newTodayCount;
    document.getElementById('hardCount').textContent = hardCount;
    document.getElementById('totalCount').textContent = totalCount; //funkcja random
}

function updateCustomNumberInput() {
    const select = document.getElementById('cardNumberSelect');
    const customInput = document.getElementById('customNumberInput');
    customInput.classList.toggle('hidden', select.value !== 'custom');
}

// Zmodyfikuj funkcję selectReviewMode
function selectReviewMode(mode) {
    document.querySelectorAll('.review-mode-card').forEach(card => {
        card.classList.remove('selected');
    });
    const selectedCard = document.querySelector(`.review-mode-card[onclick*="${mode}"]`);
    if (selectedCard) {
        selectedCard.classList.add('selected');
    }
    currentReviewMode = mode;
}

function showNoFlashcardsMessage() {
    document.getElementById('reviewCard').innerHTML = `
        <p data-translate="noFlashcardsToReview">No flashcards to review!</p>
        <button onclick="startReview()" class="review-button" data-translate="backToModes">
            Back to review modes
        </button>
    `;
    changeLanguage();
}

function showNoNewFlashcardsMessage() {
  document.getElementById('reviewCard').innerHTML = `
      <p data-translate="noNewFlashcardsToReview">No new flashcards to review, add some!</p>
      <button onclick="startReview()" class="review-button" data-translate="backToModes">
          Back to review modes
      </button>
  `;
  changeLanguage();
}

// Dodaj funkcje do wyświetlania postępu w systemie Leitnera
function updateLeitnerProgress() {
  const algorithm = localStorage.getItem('reviewAlgorithm') || 'standard';
  if (algorithm === 'leitner') {
      const flashcard = flashcardsToReview[currentFlashcardIndex];
      if (flashcard) {
          const progressInfo = document.createElement('div');
          progressInfo.className = 'leitner-progress';
          progressInfo.innerHTML = `
              <div class="progress-header" data-translate="leitnerProgress">
                  Progress in Leitner system
              </div>
              <div class="box-progress">
                  <div class="current-box">
                      <span data-translate="leitnerBoxDescription">Current box: </span>
                      <strong>${flashcard.leitnerBox || 1}/5</strong>
                  </div>
                  <div class="next-box">
                      <span data-translate="leitnerNextReview">Next review: </span>
                      <strong>${calculateLeitnerInterval(flashcard.leitnerBox)|| 1} 
                      <span data-translate="leitnerDays">days</span></strong>
                  </div>
              </div>
          `;
          
          const cardContent = document.querySelector('.card-content');
          if (cardContent) {
              const existingProgress = cardContent.querySelector('.leitner-progress');
              if (existingProgress) {
                  existingProgress.replaceWith(progressInfo);
              } else {
                  cardContent.insertBefore(progressInfo, cardContent.firstChild);
              }
          }
      }
  }
}

// Dodaj style dla systemu Leitnera
const leitnerStyles = {
  box1: { color: '#dc3545', label: '1 day' },      // czerwony
  box2: { color: '#fd7e14', label: '3 days' },     // pomarańczowy
  box3: { color: '#ffc107', label: '7 days' },     // żółty
  box4: { color: '#28a745', label: '14 days' },    // zielony
  box5: { color: '#17a2b8', label: '30 days' }     // niebieski
};



// Modyfikacja funkcji showNextFlashcard
function showNextFlashcard() {
    if (currentFlashcardIndex < flashcardsToReview.length) {
        const flashcard = flashcardsToReview[currentFlashcardIndex];
        const algorithm = localStorage.getItem('reviewAlgorithm') || 'standard';
        const buttonMode = localStorage.getItem('gradeButtonMode') || 'six';
        
        let leitnerInfo = '';
        if (algorithm === 'leitner') {
            const box = flashcard.leitnerBox || 1;
            const style = leitnerStyles[`box${box}`];
            leitnerInfo = `
                <div class="leitner-info" style="border-left: 4px solid ${style.color}">
                    <div class="box-info">
                        <span data-translate="leitnerBox">Box</span>: ${box}/5 
                        (${style.label})
                    </div>
                    <div class="next-review">
                        <span data-translate="leitnerNextReview">Next review</span>: 
                        ${flashcard.nextReview ? new Date(flashcard.nextReview).toLocaleDateString() : 'Today'}
                    </div>
                </div>
            `;
        }

        // Przygotuj przyciski oceny w zależności od wybranego trybu
        const qualityButtons = buttonMode === 'four' ? `
            <button onclick="gradeAnswer(0)" class="grade-button grade-0" data-tooltip="${translations[currentLanguage].startOverTooltip}" data-translate="completelyForgot">Completely forgot</button>
            <button onclick="gradeAnswer(2)" class="grade-button grade-2" data-translate="hard">Hard</button>
            <button onclick="gradeAnswer(3)" class="grade-button grade-3" data-translate="good">Good</button>
            <button onclick="gradeAnswer(4)" class="grade-button grade-4" data-translate="easy">Easy</button>
        ` : `
            <button onclick="gradeAnswer(0)" class="grade-button grade-0" data-tooltip="${translations[currentLanguage].startOverTooltip}" data-translate="completelyForgot">Completely forgot</button>
            <button onclick="gradeAnswer(1)" class="grade-button grade-1" data-translate="wrong">Wrong</button>
            <button onclick="gradeAnswer(2)" class="grade-button grade-2" data-translate="hard">Hard</button>
            <button onclick="gradeAnswer(3)" class="grade-button grade-3" data-translate="good">Good</button>
            <button onclick="gradeAnswer(4)" class="grade-button grade-4" data-translate="easy">Easy</button>
            <button onclick="gradeAnswer(5)" class="grade-button grade-5" data-translate="perfect">Perfect</button>
        `;

        document.getElementById('reviewCard').innerHTML = `
            <div class="card-content">
                <button class="review-edit-button" onclick="editFlashcardDuringReview(${flashcard.id})" data-translate="edit">Edit</button>
                ${algorithm === 'leitner' ? leitnerInfo : ''}
                <p><strong data-translate="wordPhrase">Word / Phrase:</strong></p>
                <pre>${flashcard.word}</pre>
                <p><strong data-translate="contextExample">Context / Example:</strong></p>
                <pre>${flashcard.context || 'No context provided'}</pre>
                ${flashcard.mediaUrl ? `<img src="${flashcard.mediaUrl}" alt="media" width="200">` : ''}
                ${flashcard.audioUrl ? `<audio controls><source src="${flashcard.audioUrl}" type="audio/mpeg"></audio>` : ''}
                <div class="button-row">
                    <button onclick="showTranslation(${currentFlashcardIndex})" class="show-translation" data-translate="showTranslation">Show translation</button>
                    <div class="quality-buttons hidden">
                        ${qualityButtons}
                    </div>
                </div>
                <div id="translation-${currentFlashcardIndex}" class="translation hidden">
                    <p><strong data-translate="translation">Translation:</strong></p>
                    <pre>${flashcard.translation}</pre>
                </div>
            </div>
        `;
        
        updateLeitnerProgress();
        changeLanguage();
    } else {
        document.getElementById('reviewCard').innerHTML = `
            <div class="review-complete">
                <h3 data-translate="endOfReview">End of review!</h3>
                <p data-translate="redirecting">Returning to review mode selection...</p>
            </div>
        `;
        
        updateFlashcardTable();
        updateStats();
        
        // Dodaj automatyczną synchronizację po zakończeniu powtórki
        const enableSyncAfterReview = localStorage.getItem('enable_sync_after_review') === 'true';
        if (enableSyncAfterReview) {
            setTimeout(async () => {
                try {
                    // Usuń wyświetlanie okna dialogowego - po prostu wykonaj synchronizację
                    const apiKey = localStorage.getItem('pushbullet_api_key');
                    if (apiKey) {
                        await handleSync();
                    }
                } catch (error) {
                    console.error('Auto sync after review failed:', error);
                }
            }, 1);
        }
        
        setTimeout(() => {
            showReviewModeSelection();
        }, 2000);
    }
}



// Obsługa synchronizacji
async function handleSync() {
    console.log('handleSync called');
    const syncButton = document.getElementById('sync-button');
    if (!syncButton) {
        console.error('Sync button not found in handleSync');
        return;
    }
    
    if (isSyncing) {
        console.log('Sync already in progress');
        return;
    }
    
    const apiKey = localStorage.getItem('pushbullet_api_key');
    if (!apiKey) {
        console.log('No API key found, showing Pushbullet dialog');
        showPushbulletDialog();
        return;
    }

    try {
        console.log('Starting sync process');
        isSyncing = true;
        syncButton.classList.add('syncing');
        syncButton.querySelector('[data-translate="sync"]').textContent = 
            translations[currentLanguage].syncInProgress;



        await waitForFlashcards();
        await fetchFromPushbullet();
        await syncWithPushbullet();
        //updateLastSyncTime();


        // Po udanej synchronizacji usuń klasę new-sync
        syncButton.classList.remove('new-sync');

        console.log('Sync completed successfully');
        updateFlashcardTable();
        updateStats();
        showNotification(translations[currentLanguage].syncSuccess, 'success');
    } catch (error) {
        console.error('Sync failed:', error);
        showNotification(translations[currentLanguage].syncError + ': ' + error.message, 'error');
    } finally {
        console.log('Sync process finished');
        isSyncing = false;
        syncButton.classList.remove('syncing');
        syncButton.querySelector('[data-translate="sync"]').textContent = 
            translations[currentLanguage].sync;
    }

                    // Dodajemy wywołanie funkcji Save po synchronizacji
                    const enable_auto_save = localStorage.getItem('enable_auto_save') === 'true';
                     if (enable_auto_save) { //zawsze wysyłaj plik 
                         try {
                             await sendExportToPushbullet();
                             // Odświeżamy link do pobrania
                             if (typeof window.checkSaveFiles === 'function') {
                                 await window.checkSaveFiles();
                             }
                         } catch (error) {
                             console.error('Save during sync failed:', error);
                             // Kontynuujemy synchronizację nawet jeśli save się nie powiedzie
                         }
                     }
    
}

// Dodaj funkcję pomocniczą do czekania na inicjalizację fiszek
function waitForFlashcards() {
  return new Promise((resolve, reject) => {
      const maxAttempts = 10;
      let attempts = 0;

      function checkFlashcards() {
          if (typeof window.flashcards !== 'undefined' && window.flashcards) {
              resolve();
          } else if (attempts >= maxAttempts) {
              reject(new Error('Flashcards initialization timeout'));
          } else {
              attempts++;
              setTimeout(checkFlashcards, 500);
          }
      }

      checkFlashcards();
  });
}

function showPushbulletDialog() {
    const dialog = document.createElement('div');
    dialog.className = 'pushbullet-dialog';
    dialog.innerHTML = `
        <h3 data-translate="pushbulletSetup">Pushbullet Setup</h3>
        <p class="settings-description" data-translate="syncDescription">Synchronization allows you to review flashcards on two devices.</p>
        <div class="api-key-input">
            <input type="password" id="pushbullet-api-key" placeholder="${translations[currentLanguage].enterApiKey}"/>
            <button type="button" class="toggle-password" onclick="togglePasswordVisibility(this)">
                👁
            </button>
        </div>
        <div class="api-key-info">
            <a href="https://www.pushbullet.com/#settings/account" 
               target="_blank" 
               data-translate="getApiKey">Get your API key</a>
            <span style="margin-left: 5px;" data-translate="apiKeyLimit">(Free account: Limited to 500 pushes per month, which should be sufficient for daily synchronization of 100 reviewed flashcards)</span>
        </div>
        <div class="dialog-buttons">
            <button onclick="connectPushbullet()" class="submit-button" data-translate="connect">Connect</button>
            <button onclick="closePushbulletDialog()" class="cancel-button" data-translate="cancel">Cancel</button>
        </div>
    `;

    const overlay = document.createElement('div');
    overlay.className = 'dialog-overlay';
    overlay.onclick = closePushbulletDialog;

    document.body.appendChild(overlay);
    document.body.appendChild(dialog);
    
    changeLanguage();
}

async function connectPushbullet() {
  const apiKey = document.getElementById('pushbullet-api-key').value;
  if (!apiKey) {
      showNotification(translations[currentLanguage].enterApiKey, 'error');
      return;
  }

  try {
      const connected = await initPushbullet(apiKey);
      if (connected) {
          showNotification(translations[currentLanguage].syncEnabled, 'success');
          closePushbulletDialog();
          setupAutomaticSync();
          handleSync(); // Rozpocznij pierwszą synchronizację
      }
  } catch (error) {
      console.error('Pushbullet connection failed:', error);
      showNotification(`${translations[currentLanguage].syncError}: ${error.message}`, 'error');
  }
}

function closePushbulletDialog() {
  const dialog = document.querySelector('.pushbullet-dialog');
  const overlay = document.querySelector('.dialog-overlay');
  if (dialog) dialog.remove();
  if (overlay) overlay.remove();
}

function showNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  notification.innerHTML = `
      <div class="notification-content">
          <span class="notification-message">${message}</span>
          <button class="notification-close" onclick="this.parentElement.parentElement.remove()">×</button>
      </div>
  `;
  
  document.body.appendChild(notification);
  
  // Automatycznie usuń powiadomienie po 5 sekundach
  setTimeout(() => {
      if (notification.parentElement) {
          notification.remove();
      }
  }, 5000);
}

// Dodaj nasłuchiwanie na przycisk synchronizacji po załadowaniu DOM
document.addEventListener('DOMContentLoaded', () => {
  const syncButton = document.getElementById('sync-button');
  if (syncButton) {
      syncButton.addEventListener('click', handleSync);
  }

  // Sprawdź czy synchronizacja jest już skonfigurowana
  const apiKey = localStorage.getItem('pushbullet_api_key');
  if (apiKey) {
      setupAutomaticSync();
  }
});

// Dodaj nową funkcję inicjalizacji przycisku synchronizacji
function initializeSyncButton() {
    const syncButton = document.getElementById('sync-button');
    if (syncButton) {
        console.log('Initializing sync button');
        
        // Usuń wszystkie istniejące event listenery
        const newSyncButton = syncButton.cloneNode(true);
        syncButton.parentNode.replaceChild(newSyncButton, syncButton);
        
        // Dodaj nowy event listener
        newSyncButton.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Sync button clicked');
            if (typeof window.handleSync === 'function') {
                try {
                    await window.handleSync();
                } catch (error) {
                    console.error('Sync error:', error);
                    showNotification('Synchronization failed: ' + error.message, 'error');
                }
            } else {
                console.error('handleSync function not found');
                showNotification('Synchronization function not available', 'error');
            }
        });
    } else {
        console.error('Sync button not found');
    }
}

// Funkcja otwierająca okno ustawień
function openMainSettings() {
    const currentApiKey = localStorage.getItem('pushbullet_api_key') || '';
    const autoSync = localStorage.getItem('auto_sync') === 'true';
    const syncInterval = localStorage.getItem('sync_interval') || '5';
    const inactivityTimeout = localStorage.getItem('inactivity_timeout') || '10';
    const enableSyncCheck = localStorage.getItem('enable_sync_check') === 'true';
    const exportToServer = localStorage.getItem('export_to_server') === 'true';
    const enableAutoSave = localStorage.getItem('enable_auto_save') === 'true';
    const enableSyncAfterReview = localStorage.getItem('enable_sync_after_review') === 'true'; // Dodane
    
    const settingsDialog = document.createElement('div');
    settingsDialog.className = 'main-settings-dialog';

    const savedTtsLang = localStorage.getItem('ttsLanguage') || 'en'; //defalut
    
    // Pobierz zapisany prompt lub użyj domyślnego
    const savedPrompt = localStorage.getItem('exampleButtonPrompt') ;
    settingsDialog.innerHTML = `
        <h2 data-translate="mainSettings">Main Settings</h2>

        <div class="settings-section">
          <h3>Flashcard Context "Show Examples" - Prompt</h3>
            <div class="form-group">
                <textarea id="exampleButtonPrompt" rows="2" style="width: 100%;">${savedPrompt}</textarea>
                <small>Use {word} as placeholder for the current word</small>
            </div>

                        <!-- Dodajemy sekcję języka TTS -->
            <div class="settings-section">
                <h3>Text to Speech Language</h3>
                <div class="form-group">
                    <select id="ttsLanguage" style="width: 100%; padding: 8px; margin-bottom: 4px;">
                         <option value="af" ${savedTtsLang === 'af' ? 'selected' : ''}>Afrikaans</option>
                         <option value="sq" ${savedTtsLang === 'sq' ? 'selected' : ''}>Albanian</option>
                         <option value="am" ${savedTtsLang === 'am' ? 'selected' : ''}>Amharic</option>
                         <option value="ar" ${savedTtsLang === 'ar' ? 'selected' : ''}>Arabic</option>
                         <option value="hy" ${savedTtsLang === 'hy' ? 'selected' : ''}>Armenian</option>
                         <option value="az" ${savedTtsLang === 'az' ? 'selected' : ''}>Azerbaijani</option>
                         <option value="eu" ${savedTtsLang === 'eu' ? 'selected' : ''}>Basque</option>
                         <option value="be" ${savedTtsLang === 'be' ? 'selected' : ''}>Belarusian</option>
                         <option value="bn" ${savedTtsLang === 'bn' ? 'selected' : ''}>Bengali</option>
                         <option value="bs" ${savedTtsLang === 'bs' ? 'selected' : ''}>Bosnian</option>
                         <option value="bg" ${savedTtsLang === 'bg' ? 'selected' : ''}>Bulgarian</option>
                         <option value="ca" ${savedTtsLang === 'ca' ? 'selected' : ''}>Catalan</option>
                         <option value="ceb" ${savedTtsLang === 'ceb' ? 'selected' : ''}>Cebuano</option>
                         <option value="zh-CN" ${savedTtsLang === 'zh-CN' ? 'selected' : ''}>Chinese (Simplified)</option>
                         <option value="zh-TW" ${savedTtsLang === 'zh-TW' ? 'selected' : ''}>Chinese (Traditional)</option>
                         <option value="co" ${savedTtsLang === 'co' ? 'selected' : ''}>Corsican</option>
                         <option value="hr" ${savedTtsLang === 'hr' ? 'selected' : ''}>Croatian</option>
                         <option value="cs" ${savedTtsLang === 'cs' ? 'selected' : ''}>Czech</option>
                         <option value="da" ${savedTtsLang === 'da' ? 'selected' : ''}>Danish</option>
                         <option value="nl" ${savedTtsLang === 'nl' ? 'selected' : ''}>Dutch</option>
                         <option value="en" ${savedTtsLang === 'en' ? 'selected' : ''}>English</option>
                         <option value="eo" ${savedTtsLang === 'eo' ? 'selected' : ''}>Esperanto</option>
                         <option value="et" ${savedTtsLang === 'et' ? 'selected' : ''}>Estonian</option>
                         <option value="fi" ${savedTtsLang === 'fi' ? 'selected' : ''}>Finnish</option>
                         <option value="fr" ${savedTtsLang === 'fr' ? 'selected' : ''}>French</option>
                         <option value="fy" ${savedTtsLang === 'fy' ? 'selected' : ''}>Frisian</option>
                         <option value="gl" ${savedTtsLang === 'gl' ? 'selected' : ''}>Galician</option>
                         <option value="ka" ${savedTtsLang === 'ka' ? 'selected' : ''}>Georgian</option>
                         <option value="de" ${savedTtsLang === 'de' ? 'selected' : ''}>German</option>
                         <option value="el" ${savedTtsLang === 'el' ? 'selected' : ''}>Greek</option>
                         <option value="gu" ${savedTtsLang === 'gu' ? 'selected' : ''}>Gujarati</option>
                         <option value="ht" ${savedTtsLang === 'ht' ? 'selected' : ''}>Haitian Creole</option>
                         <option value="ha" ${savedTtsLang === 'ha' ? 'selected' : ''}>Hausa</option>
                         <option value="iw" ${savedTtsLang === 'iw' ? 'selected' : ''}>Hebrew</option>
                         <option value="hi" ${savedTtsLang === 'hi' ? 'selected' : ''}>Hindi</option>
                         <option value="hmn" ${savedTtsLang === 'hmn' ? 'selected' : ''}>Hmong</option>
                         <option value="hu" ${savedTtsLang === 'hu' ? 'selected' : ''}>Hungarian</option>
                         <option value="is" ${savedTtsLang === 'is' ? 'selected' : ''}>Icelandic</option>
                         <option value="ig" ${savedTtsLang === 'ig' ? 'selected' : ''}>Igbo</option>
                         <option value="id" ${savedTtsLang === 'id' ? 'selected' : ''}>Indonesian</option>
                         <option value="ga" ${savedTtsLang === 'ga' ? 'selected' : ''}>Irish</option>
                         <option value="it" ${savedTtsLang === 'it' ? 'selected' : ''}>Italian</option>
                         <option value="ja" ${savedTtsLang === 'ja' ? 'selected' : ''}>Japanese</option>
                         <option value="jw" ${savedTtsLang === 'jw' ? 'selected' : ''}>Javanese</option>
                         <option value="kn" ${savedTtsLang === 'kn' ? 'selected' : ''}>Kannada</option>
                         <option value="kk" ${savedTtsLang === 'kk' ? 'selected' : ''}>Kazakh</option>
                         <option value="km" ${savedTtsLang === 'km' ? 'selected' : ''}>Khmer</option>
                         <option value="ko" ${savedTtsLang === 'ko' ? 'selected' : ''}>Korean</option>
                         <option value="ku" ${savedTtsLang === 'ku' ? 'selected' : ''}>Kurdish</option>
                         <option value="ky" ${savedTtsLang === 'ky' ? 'selected' : ''}>Kyrgyz</option>
                         <option value="lo" ${savedTtsLang === 'lo' ? 'selected' : ''}>Lao</option>
                         <option value="la" ${savedTtsLang === 'la' ? 'selected' : ''}>Latin</option>
                         <option value="lv" ${savedTtsLang === 'lv' ? 'selected' : ''}>Latvian</option>
                         <option value="lt" ${savedTtsLang === 'lt' ? 'selected' : ''}>Lithuanian</option>
                         <option value="lb" ${savedTtsLang === 'lb' ? 'selected' : ''}>Luxembourgish</option>
                         <option value="mk" ${savedTtsLang === 'mk' ? 'selected' : ''}>Macedonian</option>
                         <option value="mg" ${savedTtsLang === 'mg' ? 'selected' : ''}>Malagasy</option>
                         <option value="ms" ${savedTtsLang === 'ms' ? 'selected' : ''}>Malay</option>
                         <option value="ml" ${savedTtsLang === 'ml' ? 'selected' : ''}>Malayalam</option>
                         <option value="mt" ${savedTtsLang === 'mt' ? 'selected' : ''}>Maltese</option>
                         <option value="mi" ${savedTtsLang === 'mi' ? 'selected' : ''}>Maori</option>
                         <option value="mr" ${savedTtsLang === 'mr' ? 'selected' : ''}>Marathi</option>
                         <option value="mn" ${savedTtsLang === 'mn' ? 'selected' : ''}>Mongolian</option>
                         <option value="ne" ${savedTtsLang === 'ne' ? 'selected' : ''}>Nepali</option>
                         <option value="no" ${savedTtsLang === 'no' ? 'selected' : ''}>Norwegian</option>
                         <option value="or" ${savedTtsLang === 'or' ? 'selected' : ''}>Odia (Oriya)</option>
                         <option value="pl" ${savedTtsLang === 'pl' ? 'selected' : ''}>Polish</option>
                         <option value="pt" ${savedTtsLang === 'pt' ? 'selected' : ''}>Portuguese</option>
                         <option value="ro" ${savedTtsLang === 'ro' ? 'selected' : ''}>Romanian</option>
                         <option value="ru" ${savedTtsLang === 'ru' ? 'selected' : ''}>Russian</option>
                         <option value="sr" ${savedTtsLang === 'sr' ? 'selected' : ''}>Serbian</option>
                         <option value="si" ${savedTtsLang === 'si' ? 'selected' : ''}>Sinhala</option>
                         <option value="sk" ${savedTtsLang === 'sk' ? 'selected' : ''}>Slovak</option>
                         <option value="sl" ${savedTtsLang === 'sl' ? 'selected' : ''}>Slovenian</option>
                         <option value="es" ${savedTtsLang === 'es' ? 'selected' : ''}>Spanish</option>
                         <option value="su" ${savedTtsLang === 'su' ? 'selected' : ''}>Sundanese</option>
                         <option value="sw" ${savedTtsLang === 'sw' ? 'selected' : ''}>Swahili</option>
                         <option value="sv" ${savedTtsLang === 'sv' ? 'selected' : ''}>Swedish</option>
                         <option value="tg" ${savedTtsLang === 'tg' ? 'selected' : ''}>Tajik</option>
                         <option value="ta" ${savedTtsLang === 'ta' ? 'selected' : ''}>Tamil</option>
                         <option value="te" ${savedTtsLang === 'te' ? 'selected' : ''}>Telugu</option>
                         <option value="th" ${savedTtsLang === 'th' ? 'selected' : ''}>Thai</option>
                         <option value="tr" ${savedTtsLang === 'tr' ? 'selected' : ''}>Turkish</option>
                         <option value="uk" ${savedTtsLang === 'uk' ? 'selected' : ''}>Ukrainian</option>
                         <option value="ur" ${savedTtsLang === 'ur' ? 'selected' : ''}>Urdu</option>
                         <option value="uz" ${savedTtsLang === 'uz' ? 'selected' : ''}>Uzbek</option>
                         <option value="vi" ${savedTtsLang === 'vi' ? 'selected' : ''}>Vietnamese</option>
                         <option value="cy" ${savedTtsLang === 'cy' ? 'selected' : ''}>Welsh</option>
                         <option value="xh" ${savedTtsLang === 'xh' ? 'selected' : ''}>Xhosa</option>
                         <option value="yi" ${savedTtsLang === 'yi' ? 'selected' : ''}>Yiddish</option>
                         <option value="yo" ${savedTtsLang === 'yo' ? 'selected' : ''}>Yoruba</option>
                         <option value="zu" ${savedTtsLang === 'zu' ? 'selected' : ''}>Zulu</option>                 
                        </select>
                    <small>Language used for text to speech pronunciation</small>
                </div>
            

            <h3 data-translate="syncSettings">Synchronization Settings</h3>
            <p class="settings-description" data-translate="syncDescription">Synchronization allows you to study on two devices.</p>
            <div class="settings-content">
                <div class="settings-group">
                    <label for="pushbullet-api-key" data-translate="pushbulletApiKey">Pushbullet API Key:</label>
                    <div class="api-key-input">
                        <input 
                            type="password" 
                            id="pushbullet-api-key" 
                            value="${currentApiKey}"
                            placeholder="Enter your Pushbullet API key"
                        >
                        <button type="button" class="toggle-password" onclick="togglePasswordVisibility(this)">
                            👁
                        </button>
                        <button type="button" class="remove-api-key" onclick="removeApiKey()">✕</button>
                    </div>
                    <div class="api-key-info">
                        <a href="https://www.pushbullet.com/#settings/account" 
                           target="_blank" 
                           data-translate="getApiKey">Get your API key</a>
                        <span style="margin-left: 5px;" data-translate="apiKeyLimit">(Free account: Limited to 500 pushes per month, which should be sufficient for daily synchronization of 100 reviewed flashcards)</span>
                    </div>
                </div>

                <div class="settings-group sync-settings">
                    <!-- Opcja Export to server z tooltipem -->
                    <div class="export-server-option">
                        <label class="checkbox-label" data-tooltip="${translations[currentLanguage].exportToServerTooltip}">
                            <input type="checkbox" id="export-to-server" ${exportToServer ? 'checked' : ''}>
                            <span data-translate="exportToServer">Enable Save button (useful if free 500 pushes is not enough)</span>
                        </label>
                    </div>

                    <!-- Dodajemy nową opcję Auto Save -->
                    <div class="auto-save-option">
                        <label class="checkbox-label">
                            <input type="checkbox" id="enable-auto-save" ${enableAutoSave ? 'checked' : ''}>
                            <span data-translate="enableAutoSave">Enable Auto Save during Sync</span>
                        </label>
                    </div>

                    <!-- Opcja Enable sync check -->
                    <div class="sync-check-option">
                        <label class="checkbox-label">
                            <input type="checkbox" id="enable-sync-check" ${enableSyncCheck ? 'checked' : ''}>
                            <span data-translate="enableSyncCheck">Enable sync check on start</span>
                        </label>
                    </div>

                    <!-- Dodajemy nową opcję Enable Sync after Review -->
                    <div class="sync-after-review-option">
                        <label class="checkbox-label">
                            <input type="checkbox" id="enable-sync-after-review" ${enableSyncAfterReview ? 'checked' : ''}>
                            <span data-translate="enableSyncAfterReview">Enable Sync after Review</span>
                        </label>
                    </div>

                    <!-- Pozostałe opcje -->
                    <div class="auto-sync-option">
                        <label class="checkbox-label">
                            <input type="checkbox" id="auto-sync" ${autoSync ? 'checked' : ''}>
                            <span data-translate="enableAutoSync">Enable automatic synchronization</span>
                        </label>
                    </div>
                    
                    <div class="sync-interval-option ${!autoSync ? 'disabled' : ''}">
                        <label for="sync-interval" data-translate="syncInterval">Sync interval (minutes):</label>
                        <select id="sync-interval" ${!autoSync ? 'disabled' : ''}>
                            <option value="5" ${syncInterval === '5' ? 'selected' : ''}>5</option>
                            <option value="10" ${syncInterval === '10' ? 'selected' : ''}>10</option>
                            <option value="15" ${syncInterval === '15' ? 'selected' : ''}>15</option>
                            <option value="30" ${syncInterval === '30' ? 'selected' : ''}>30</option>
                            <option value="60" ${syncInterval === '60' ? 'selected' : ''}>60</option>
                        </select>
                    </div>

                    <div class="inactivity-timeout-option">
                        <label for="inactivity-timeout" data-translate="inactivityTimeout">Stop sync after inactivity (minutes):</label>
                        <select id="inactivity-timeout">
                            <option value="5" ${inactivityTimeout === '5' ? 'selected' : ''}>5</option>
                            <option value="10" ${inactivityTimeout === '10' ? 'selected' : ''}>10</option>
                            <option value="15" ${inactivityTimeout === '15' ? 'selected' : ''}>15</option>
                            <option value="30" ${inactivityTimeout === '30' ? 'selected' : ''}>30</option>
                            <option value="60" ${inactivityTimeout === '60' ? 'selected' : ''}>60</option>
                        </select>
                    </div>

                    <div class="delete-notes-option">
                        <button type="button" class="delete-notes-button" onclick="handleDeleteNotes()">
                            <span data-translate="deleteAllNotes">Delete All Sync Notes</span>
                        </button>
                        <div class="delete-notes-info">
                            <span data-translate="deleteNotesWarning">Warning: This will delete all synchronization notes from Pushbullet</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="settings-section">
          <!--  <h3 data-translate="generalSettings">General Settings</h3>
            <div class="settings-content">
                <!-- Przyszłe opcje ustawień 
            </div> -->
        </div>

        <div class="settings-footer">
            <button class="settings-save" data-translate="save">Save</button>
            <button class="settings-cancel" data-translate="cancel">Cancel</button>
        </div>
    `;

    const overlay = document.createElement('div');
    overlay.className = 'settings-overlay';

    document.body.appendChild(overlay);
    document.body.appendChild(settingsDialog);

    // Obsługa zmiany stanu auto-sync
    const autoSyncCheckbox = settingsDialog.querySelector('#auto-sync');
    const syncIntervalSelect = settingsDialog.querySelector('#sync-interval');
    const syncIntervalOption = settingsDialog.querySelector('.sync-interval-option');

    autoSyncCheckbox.addEventListener('change', function() {
        syncIntervalSelect.disabled = !this.checked;
        syncIntervalOption.classList.toggle('disabled', !this.checked);
    });

    // Obsługa przycisków
    const saveButton = settingsDialog.querySelector('.settings-save');
    const cancelButton = settingsDialog.querySelector('.settings-cancel');

    // Funkcja do zapisywania ustawień
    async function saveSettings() {
        const newApiKey = document.getElementById('pushbullet-api-key').value.trim();
        const newAutoSync = document.getElementById('auto-sync').checked;
        const newSyncInterval = document.getElementById('sync-interval').value;
        const newInactivityTimeout = document.getElementById('inactivity-timeout').value;
        const newEnableSyncCheck = document.getElementById('enable-sync-check').checked;
        const newExportToServer = document.getElementById('export-to-server').checked;
        const newEnableAutoSave = document.getElementById('enable-auto-save').checked;
        const newEnableSyncAfterReview = document.getElementById('enable-sync-after-review').checked;
        
        if (newApiKey !== currentApiKey) {
            try {
                const isValid = await initPushbullet(newApiKey);
                if (isValid) {
                    showNotification(translations[currentLanguage].apiKeySaved || 'API key saved successfully', 'success');
                } else {
                    showNotification(translations[currentLanguage].invalidApiKey || 'Invalid API key', 'error');
                    return false;
                }
            } catch (error) {
                showNotification(translations[currentLanguage].apiKeyError || 'Error saving API key', 'error');
                return false;
            }
        }

        // Zapisz ustawienia
        localStorage.setItem('auto_sync', newAutoSync);
        localStorage.setItem('sync_interval', newSyncInterval);
        localStorage.setItem('inactivity_timeout', newInactivityTimeout);
        localStorage.setItem('enable_sync_check', newEnableSyncCheck);
        localStorage.setItem('export_to_server', newExportToServer);
        localStorage.setItem('enable_auto_save', newEnableAutoSave);
        localStorage.setItem('enable_sync_after_review', newEnableSyncAfterReview);

            // Zapisz template promptu
        const promptTemplate = document.getElementById('exampleButtonPrompt').value;
        localStorage.setItem('exampleButtonPrompt', promptTemplate);


        const ttsLangValue = document.getElementById('ttsLanguage').value;
    
        localStorage.setItem('ttsLanguage', ttsLangValue);

        if (newAutoSync) {
            setupAutomaticSync(parseInt(newSyncInterval) * 60 * 1000);
            showNotification(translations[currentLanguage].autoSyncEnabled || 'Automatic sync enabled', 'success');
        } else {
            clearAutomaticSync();
           // showNotification(translations[currentLanguage].autoSyncDisabled || 'Automatic sync disabled', 'info');
        }
        
        updateSaveButtonVisibility();
        return true;
    }

    // Obsługa kliknięcia na overlay
    overlay.addEventListener('click', async () => {
        if (await saveSettings()) {
            closeMainSettings();
        }
    });

    // Obsługa przycisku Save
    saveButton.addEventListener('click', async () => {
        if (await saveSettings()) {
            closeMainSettings();
        }
    });

    cancelButton.addEventListener('click', closeMainSettings);
    overlay.addEventListener('click', closeMainSettings);

    // Przetłumacz teksty
    changeLanguage();
}

// Funkcja zamykająca okno ustawień
function closeMainSettings() {
    const dialog = document.querySelector('.main-settings-dialog');
    const overlay = document.querySelector('.settings-overlay');
    
    if (dialog) dialog.remove();
    if (overlay) overlay.remove();
}

// Dodaj event listener do przycisku ustawień
document.addEventListener('DOMContentLoaded', () => {
    const settingsButton = document.getElementById('main-settings');
    if (settingsButton) {
        settingsButton.addEventListener('click', openMainSettings);
    }
});

// Funkcja do przełączania widoczności hasła
function togglePasswordVisibility(button) {
    const input = button.parentElement.querySelector('input');
    if (input.type === 'password') {
        input.type = 'text';
        button.textContent = '🔒';
    } else {
        input.type = 'password';
        button.textContent = '👁';
    }
}

// Funkcja do usuwania wszystkich notatek
async function handleDeleteNotes() {
    const deleteButton = document.querySelector('.delete-notes-button');
    if (!deleteButton) return;

    const originalContent = deleteButton.innerHTML;

    const confirmDialog = document.createElement('div');
    confirmDialog.className = 'confirm-dialog';
    confirmDialog.innerHTML = `
        <div class="confirm-content">
            <h3 data-translate="confirmDelete">Confirm Deletion</h3>
            <p data-translate="confirmDeleteMessage">Are you sure you want to delete all synchronization notes? This action cannot be undone.</p>
            <div class="confirm-buttons">
                <button class="confirm-yes" data-translate="yes">Yes, delete all</button>
                <button class="confirm-no" data-translate="no2">Cancel</button>
            </div>
        </div>
    `;

    document.body.appendChild(confirmDialog);
    changeLanguage();

    try {
        const confirmed = await new Promise((resolve) => {
            const yesButton = confirmDialog.querySelector('.confirm-yes');
            const noButton = confirmDialog.querySelector('.confirm-no');

            yesButton.addEventListener('click', () => {
                confirmDialog.remove();
                resolve(true);
            });

            noButton.addEventListener('click', () => {
                confirmDialog.remove();
                resolve(false);
            });

            confirmDialog.addEventListener('click', (e) => {
                if (e.target === confirmDialog) {
                    confirmDialog.remove();
                    resolve(false);
                }
            });
        });

        if (!confirmed) return;

        deleteButton.innerHTML = `
            <span class="loading-icon">↻</span>
            <span data-translate="deletingNotes">Deleting notes: 0/0</span>
        `;
        deleteButton.classList.add('deleting');
        deleteButton.disabled = true;

        const result = await window.deleteAllPushbulletNotes((deletedCount, skippedCount, totalNotes) => {
            deleteButton.innerHTML = `
                <span class="loading-icon">↻</span>
                <span data-translate="deletingNotes">Deleting notes: ${deletedCount + skippedCount}/${totalNotes}</span>
                <span class="delete-progress">(${Math.round(((deletedCount + skippedCount) / totalNotes) * 100)}%)</span>
            `;
        });

        const message = `Processed ${result.totalNotes} notes: ${result.deletedCount} deleted, ${result.skippedCount} skipped, ${result.errorCount} errors`;
        showNotification(message, result.errorCount > 0 ? 'warning' : 'success');

    } catch (error) {
        console.error('Error during deletion:', error);
        showNotification(translations[currentLanguage].deleteError || 'Error deleting notes', 'error');
    } finally {
        if (deleteButton) {
            deleteButton.innerHTML = originalContent;
            deleteButton.classList.remove('deleting');
            deleteButton.disabled = false;
        }
    }
}

// Funkcja do usuwania klucza API
function removeApiKey() {
    if (confirm(translations[currentLanguage].confirmRemoveKey || 'Are you sure you want to remove the API key?')) {
        localStorage.removeItem('pushbullet_api_key');
        localStorage.removeItem('last_sync_time');
        document.getElementById('pushbullet-api-key').value = '';
        showNotification(translations[currentLanguage].apiKeyRemoved || 'API key has been removed', 'success');
        
        // Wyłącz automatyczną synchronizację
        localStorage.setItem('auto_sync', 'false');
        clearAutomaticSync();
        
        // Odśwież widok ustawień
        closeMainSettings();
        openMainSettings();
    }
}

// Dodaj funkcję do aktualizacji widoczności przycisku Save
function updateSaveButtonVisibility() {
    const saveButton = document.getElementById('save-button');
    const exportToServer = localStorage.getItem('export_to_server') === 'true';
    
    if (saveButton) {
        saveButton.classList.toggle('show', exportToServer);
    }
}

// Dodaj funkcję obsługi przycisku Save
// Funkcja obsługi przycisku Save
async function handleSave() {
    const saveButton = document.getElementById('save-button');
    const saveLinkContainer = document.getElementById('save-link');
    const exportToServer = localStorage.getItem('export_to_server') === 'true';
    
    if (!saveButton || !saveLinkContainer || !exportToServer) return;

    try {
        saveLinkContainer.style.display = 'none';
        saveLinkContainer.innerHTML = '';

        saveButton.classList.add('syncing');
        saveButton.querySelector('[data-translate="save"]').textContent = 
            translations[currentLanguage].savingInProgress || 'Saving...';

        console.log('Starting save process...');
        const result = await sendExportToPushbullet();
        console.log('Save result:', result);

        if (result && result.file_url) {
            console.log('Creating download link for:', result.file_url);
            // Wyciągamy nazwę pliku z URL
            const fileName = result.file_name || result.file_url.split('/').pop();
            saveLinkContainer.innerHTML = `
                <a href="${result.file_url}" target="_blank">
                    Download ${fileName}
                </a>
            `;
            saveLinkContainer.style.display = 'block';
        } else {
            console.log('No file URL in result:', result);
        }

        showNotification(translations[currentLanguage].saveSuccess || 'Flashcards saved successfully', 'success');
    } catch (error) {
        console.error('Save failed:', error);
        showNotification(translations[currentLanguage].saveError || 'Error saving flashcards', 'error');
    } finally {
        saveButton.classList.remove('syncing');
        saveButton.querySelector('[data-translate="save"]').textContent = 
            translations[currentLanguage].save || 'Save';
    }
}



// Eksportujemy funkcje
window.sendExportToPushbullet = sendExportToPushbullet;
window.initSyncCheck = initSyncCheck;

// Dodaj na początku pliku
let isDarkMode = false;

// Dodaj funkcję do przełączania trybu
function toggleDarkMode() {
    isDarkMode = !isDarkMode;
    document.body.classList.toggle('dark-mode', isDarkMode);
    //localStorage.setItem('darkMode', isDarkMode);
    
    // Zmień ikonę na czarno-białą
    const darkModeIcon = document.querySelector('.dark-mode-icon');
    darkModeIcon.textContent = isDarkMode ? '☼' : '☽';
    
    // Aktualizuj wykresy jeśli istnieją
    if (typeof drawLearningProgressChart === 'function') {
        drawLearningProgressChart();
    }

    // Aktualizuj style dla wszystkich wykresów
    const charts = ['#leitnerBoxesChart', '#superMemoChart', '#superMemoIntervalsChart'];
    charts.forEach(chartId => {
        const chart = document.querySelector(chartId);
        if (chart) {
           // chart.style.backgroundColor = isDarkMode ? '#919191' : '#f8f9fa';
          //  chart.color = isDarkMode ? '#e0e0e0;' : '#e0e0e0';
           // chart.style.boxShadow = isDarkMode ? '#919191' : '0 4px 6px rgba(0, 0, 0, 0.1)';
        }
    });

    updateStats();
}



// Dodaj tłumaczenia do translations.js
translations.en.darkModeTooltip = "Toggle dark mode";
translations.pl.darkModeTooltip = "Przełącz tryb ciemny";

// W sekcji tłumaczeń
translations.en.noDictionaryAvailable = "No dictionary available";
translations.pl.noDictionaryAvailable = "Słownik nie jest dostępny";

// Dodaj funkcje pomocnicze
function hideDictionary() {
    const dictionaryFrame = document.getElementById('dictionary-frame');
    if (dictionaryFrame) {
        dictionaryFrame.classList.remove('show');
    }
}

// Modyfikacja funkcji changeDictionary
function repsChangeDictionary() {
    const repsSelect = document.getElementById('reps-dictionary-select');
    const repsIframe = document.querySelector('.reps-dictionary-frame-mobile');
    const repsCheckbox = document.getElementById('reps-dictionary-default-checkbox');
    const repsIndicator = repsCheckbox.parentElement.querySelector('.reps-default-indicator');
    
    if (repsSelect.value === 'add_new') {
        addNewDictionary();
    } else if (repsSelect.value === 'remove_dictionary') {
        removeDictionary();
    } else if (repsSelect && repsIframe) {
        repsIframe.src = repsSelect.value;
        
        const defaultDictionary = localStorage.getItem('defaultDictionary');
        repsCheckbox.checked = (defaultDictionary === repsSelect.value);
        
        if (repsIndicator) {
            repsIndicator.textContent = (defaultDictionary === repsSelect.value) ? '' : '';
        }
    }
}

function setDefaultDictionary() {
    const repsCheckbox = document.getElementById('reps-dictionary-default-checkbox');
    const repsSelect = document.getElementById('reps-dictionary-select');
    const repsIndicator = repsCheckbox.parentElement.querySelector('.reps-default-indicator');
    
    if (repsCheckbox && repsSelect) {
        if (repsCheckbox.checked) {
            localStorage.setItem('defaultDictionary', repsSelect.value);
            if (repsIndicator) {
                repsIndicator.textContent = '';
            }
        } else {
            localStorage.removeItem('defaultDictionary');
            if (repsIndicator) {
                repsIndicator.textContent = '';
            }
        }
    }
}

// Modyfikujemy funkcję hideDictionary
function hideDictionary() {
    const dictionaryFrame = document.getElementById('dictionary-frame');
    const dictionaryContainer = document.getElementById('dictionary-container');
    
    if (dictionaryContainer) {
        dictionaryContainer.classList.remove('show');
    } else if (dictionaryFrame) {
        dictionaryFrame.classList.remove('show');
    }
}

// Dodaj funkcje do obsługi dodawania i usuwania słowników
function addNewDictionary() {
    // Tworzymy okno dialogowe
    const dialog = document.createElement('dialog');
    dialog.innerHTML = `
        <h3>Add new dictionary</h3>
        <div>
            <label for="reps-dictionary-name">Dictionary name:</label>
            <input type="text" id="reps-dictionary-name" placeholder="Enter dictionary name">
        </div>
        <div>
            <label for="reps-dictionary-url">Dictionary URL:</label>
            <input type="text" id="reps-dictionary-url" placeholder="Enter URL (without https://)">
        </div>
        <div>
            <button id="reps-add-confirm">Add</button>
            <button id="reps-add-cancel">Cancel</button>
        </div>
    `;
    
    document.body.appendChild(dialog);
    dialog.showModal();

    dialog.querySelector('#reps-add-confirm').addEventListener('click', () => {
        const name = dialog.querySelector('#reps-dictionary-name').value;
        let url = dialog.querySelector('#reps-dictionary-url').value;
        
        if (name && url) {
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                url = 'https://' + url;
            }
            
            const repsSelect = document.getElementById('reps-dictionary-select');
            const option = document.createElement('option');
            option.value = url;
            option.textContent = name;
            
            const addNewOption = repsSelect.querySelector('option[value="add_new"]');
            repsSelect.insertBefore(option, addNewOption);
            
            repsSelect.value = url;
            repsChangeDictionary();
            
            const dictionaries = JSON.parse(localStorage.getItem('customDictionaries') || '[]');
            dictionaries.push({ name, url });
            localStorage.setItem('customDictionaries', JSON.stringify(dictionaries));
        }
        
        dialog.close();
        dialog.remove();
    });

    dialog.querySelector('#reps-add-cancel').addEventListener('click', () => {
        dialog.close();
        dialog.remove();
    });

    const repsSelect = document.getElementById('reps-dictionary-select');
    if (repsSelect.value === 'add_new') {
        repsSelect.value = repsSelect.querySelector('option:not([value="add_new"]):not([value="remove_dictionary"])').value;
    }
    repsChangeDictionary();
}

function removeDictionary() {
    const repsSelect = document.getElementById('reps-dictionary-select');
    
    // Tworzymy okno dialogowe
    const dialog = document.createElement('dialog');
    dialog.innerHTML = `
        <h3>Select a dictionary to remove</h3>
        <select id="reps-dictionary-to-remove">
            ${Array.from(repsSelect.options)
                .filter(option => !['add_new', 'remove_dictionary'].includes(option.value))
                .map(option => `<option value="${option.value}">${option.text}</option>`)
                .join('')}
        </select>
        <div>
            <button id="reps-confirm-remove">Remove</button>
            <button id="reps-cancel-remove">Cancel</button>
        </div>
    `;
    
    document.body.appendChild(dialog);
    dialog.showModal();

    dialog.querySelector('#reps-confirm-remove').addEventListener('click', () => {
        const selectToRemove = dialog.querySelector('#reps-dictionary-to-remove');
        const dictionaryToRemove = selectToRemove.options[selectToRemove.selectedIndex].text;
        const optionToRemove = Array.from(repsSelect.options).find(option => option.text === dictionaryToRemove);
        
        if (optionToRemove) {
            repsSelect.removeChild(optionToRemove);
            
            const dictionaries = JSON.parse(localStorage.getItem('customDictionaries') || '[]');
            const updatedDictionaries = dictionaries.filter(dict => dict.name !== dictionaryToRemove);
            localStorage.setItem('customDictionaries', JSON.stringify(updatedDictionaries));
            
            if (localStorage.getItem('defaultDictionary') === optionToRemove.value) {
                localStorage.removeItem('defaultDictionary');
                document.getElementById('reps-dictionary-default-checkbox').checked = false;
            }
            
            alert(`Dictionary "${dictionaryToRemove}" has been removed.`);
        }
        
        dialog.close();
        dialog.remove();
    });

    dialog.querySelector('#reps-cancel-remove').addEventListener('click', () => {
        dialog.close();
        dialog.remove();
    });

    repsSelect.value = repsSelect.querySelector('option:not([value="add_new"]):not([value="remove_dictionary"])').value;
    repsChangeDictionary();
}

// Dodaj nową funkcję do edycji fiszki podczas powtórki
function editFlashcardDuringReview(id) {
    const flashcard = flashcards.find(f => f.id === id);
    if (flashcard) {

    const editForm = document.createElement('div');
    editForm.className = 'section edit-form';

    editForm.id = 'edit';
    editForm.innerHTML = `
        <h2 data-translate="editFlashcard">Edit Flashcard</h2>
        <form id="editFlashcardForm" style="display: flex; flex-direction: column; gap: 10px;">
            <div class="word-container" style="display: flex; align-items: flex-start; gap: 0px; width: 100%;">
                <textarea id="editWord" data-placeholder="wordPhrase" required style="flex: 1;">${flashcard.word}</textarea>
                <button type="button" class="speaker-button" onclick="speakWord('editWord')" style="background: none; border: none; cursor: pointer; padding: 8px 0 0 0; margin-right: -12px;">
                    <svg width="23" height="23" viewBox="0 0 24 24" fill="#333333">
                        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                    </svg>
                </button>
            </div>
            <div class="context-container" style="display: flex; align-items: flex-start; gap: 0px; width: 100%;">
                <textarea id="editContext" data-placeholder="contextExample" style="flex: 1;">${flashcard.context || ''}</textarea>
                <button type="button" class="speaker-button" onclick="speakWord('editContext')" style="background: none; border: none; cursor: pointer; padding: 8px 0 0 0; margin-right: -12px;">
                    <svg width="23" height="23" viewBox="0 0 24 24" fill="#333333">
                        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                    </svg>
                </button>
            </div>
            <div class="examples-button-container">
                <button type="button" class="show-examples-button" onclick="showExamples('${flashcard.word}')">
                    <small data-translate="showExamples">Show examples</small>
                </button>
            </div>
            <div class="context-container2" style="display: flex; align-items: flex-start; gap: 0px;  margin-right: 15px;">
            <textarea id="editTranslation" data-placeholder="translation" required>${flashcard.translation}</textarea>
            </div>
            <div class="url-inputs" style="display: flex; flex-direction: column; gap: 0px;margin-right: 35px;">
                <input type="text" id="editMediaUrl" data-placeholder="imageLink" value="${flashcard.mediaUrl || ''}" style="width: 100%;">
                <input type="text" id="editAudioUrl" data-placeholder="audioLink" value="${flashcard.audioUrl || ''}" style="width: 100%;">
            </div>
            <div class="button-group">
                <button type="button" onclick="cancelEditDuringReview()" data-translate="cancel">Cancel</button>
                <button type="submit" data-translate="save">Save</button>
            </div>
        </form>
    `;

    // Funkcja do odtwarzania tekstu
    window.speakWord = function(textareaId) {
        const TtsLang = localStorage.getItem('ttsLanguage') || 'en';
        const text = document.getElementById(textareaId).value;
        const encodedText = encodeURIComponent(text);
        const url = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodedText}&tl=${TtsLang}&client=tw-ob`;
        
        const audio = new Audio(url);
        audio.play().catch(error => {
            console.error('Error playing audio:', error);
        });
    };

    // Reszta kodu pozostaje bez zmian...
    editForm.querySelector('form').addEventListener('submit', (e) => {
        e.preventDefault();
        updateFlashcardDuringReview(id, {
            word: document.getElementById('editWord').value,
            context: document.getElementById('editContext').value,
            translation: document.getElementById('editTranslation').value,
            mediaUrl: document.getElementById('editMediaUrl').value,
            audioUrl: document.getElementById('editAudioUrl').value
        });
    });

    const container = document.querySelector('.container');
    const existingEditForm = document.getElementById('edit');
    if (existingEditForm) {
        container.removeChild(existingEditForm);
    }
    container.appendChild(editForm);
    showSection('edit');

    adjustTextareaHeight('editWord', flashcard.word);
    adjustTextareaHeight('editContext', flashcard.context);
    adjustTextareaHeight('editTranslation', flashcard.translation);

    changeLanguage();
    }
}

// Funkcja do aktualizacji fiszki podczas powtórki
function updateFlashcardDuringReview(id, updatedData) {
    const index = flashcards.findIndex(f => f.id === id);
    if (index !== -1) {
        updatedData.lastModified = new Date().toISOString();
        flashcards[index] = { ...flashcards[index], ...updatedData };
        saveFlashcards();
        
        // Aktualizuj również fiszkę w tablicy flashcardsToReview
        const reviewIndex = flashcardsToReview.findIndex(f => f.id === id);
        if (reviewIndex !== -1) {
            flashcardsToReview[reviewIndex] = { ...flashcardsToReview[reviewIndex], ...updatedData };
        }

        showSection('review');
        showNextFlashcard(); // Pokaż ponownie aktualną fiszkę
        changeLanguage();
    }
}

// Funkcja do anulowania edycji podczas powtórki
function cancelEditDuringReview() {
    showSection('review');
    showNextFlashcard(); // Pokaż ponownie aktualną fiszkę
    changeLanguage();
}

// Dodaj nową funkcję do obsługi przycisku Show me examples
function showExamples(word) {
    // Najpierw wywołujemy funkcjonalność przycisku Dictionary
    const toggleDictionaryBtn = document.getElementById('toggle-dictionary');
    if (toggleDictionaryBtn) {
        toggleDictionaryBtn.click(); // Symulujemy kliknięcie przycisku Dictionary
        
        // Wybieramy you.com z listy słowników
        const dictionarySelect = document.querySelector('.reps-dictionary-select');
        if (dictionarySelect) {
            // Znajdujemy i wybieramy opcję z you.com
            const options = Array.from(dictionarySelect.options);
            const youcomOption = options[1]; // Druga opcja na liście
            if (youcomOption) {
                dictionarySelect.value = youcomOption.value;
                // Wywołujemy event change aby zaktualizować słownik
                dictionarySelect.dispatchEvent(new Event('change'));
            }
        }
    }

    // Następnie ustawiamy URL dla you.com
    // Pobierz zapisany prompt lub użyj domyślnego
    const promptTemplate = localStorage.getItem('exampleButtonPrompt');    
    const prompt = promptTemplate.replace('{word}', word);
    const encodedPrompt = encodeURIComponent(prompt);
    const url = `https://you.com/search?q=${encodedPrompt}&tbm=youchat&chatMode=default`;
    
    // Znajdź ramkę słownika i ustaw URL
    const dictionaryFrame = document.querySelector('.reps-dictionary-frame-mobile');
    if (dictionaryFrame) {
        dictionaryFrame.src = url;
        dictionaryFrame.removeAttribute('hidden');
    }
}




</script>
</body>
</html>